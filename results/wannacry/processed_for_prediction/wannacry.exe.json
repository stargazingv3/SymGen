{
    "0000657a": "\nint [MASK](undefined4 *param_1,int *param_2,int *param_3,int *param_4)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  int *piVar3;\n  int iVar4;\n  int iVar5;\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  piVar3 = param_2;\n  puVar2 = param_1;\n  iVar5 = 0;\n  *param_2 = 0;\n  *param_3 = 0;\n  *param_4 = 0;\n  iVar4 = FUN_00005d0e(*param_1,param_1[3] + param_1[0x1e],0);\n  if (iVar4 == 0) {\n    iVar4 = FUN_00005e6b(*puVar2,&local_c);\n    if (iVar4 == 0) {\n      if (local_c != 0x4034b50) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_2);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_1);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if ((iVar5 == 0) &&\n         ((piVar1 = (int *)puVar2[0xd], param_2 != piVar1 ||\n          ((piVar1 != (int *)0x0 && ((word *)piVar1 != &IMAGE_DOS_HEADER_00000000.e_cparhdr)))))) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0xf])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x10])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x11])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&local_8);\n    if (iVar4 == 0) {\n      if ((iVar5 == 0) && (local_8 != puVar2[0x12])) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    *piVar3 = *piVar3 + local_8;\n    iVar4 = FUN_00005e27(*puVar2,&local_10);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    *param_3 = puVar2[0x1e] + 0x1e + local_8;\n    *param_4 = local_10;\n    *piVar3 = *piVar3 + local_10;\n  }\n  else {\n    iVar5 = -1;\n  }\n  return iVar5;\n}\n\n",
    "000013ce": "\nundefined4 [MASK](int param_1)\n\n{\n  code *pcVar1;\n  undefined1 *puVar2;\n  int iVar3;\n  int iVar4;\n  \n  FUN_000018b9();\n  FUN_000018b9();\n  pcVar1 = pcRam004080e8;\n  puVar2 = *(undefined1 **)(param_1 + 0x4c8);\n  iVar4 = 0x100000;\n  if (puVar2 != (undefined1 *)0x0) {\n    iVar3 = 0x100000;\n    do {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n      iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    (*pcVar1)(*(undefined4 *)(param_1 + 0x4c8));\n    *(undefined4 *)(param_1 + 0x4c8) = 0;\n  }\n  puVar2 = *(undefined1 **)(param_1 + 0x4cc);\n  if (puVar2 != (undefined1 *)0x0) {\n    do {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n      iVar4 = iVar4 + -1;\n    } while (iVar4 != 0);\n    (*pcVar1)(*(undefined4 *)(param_1 + 0x4cc));\n    *(undefined4 *)(param_1 + 0x4cc) = 0;\n  }\n  return 1;\n}\n\n",
    "00005535": "\nvoid [MASK](uint *param_1,byte param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)((*param_1 & 0xff ^ (uint)param_2) * 4 + 0x40d054) ^ *param_1 >> 8;\n  *param_1 = uVar1;\n  uVar1 = ((uVar1 & 0xff) + param_1[1]) * 0x8088405 + 1;\n  param_1[1] = uVar1;\n  param_1[2] = *(uint *)((uVar1 >> 0x18 ^ param_1[2] & 0xff) * 4 + 0x40d054) ^ param_1[2] >> 8;\n  return;\n}\n\n",
    "00005777": "\n/* WARNING: Removing unreachable block (ram,0x00005836) */\n\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (param_1 == 0) {\n    uVar2 = 0xfffffffe;\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x18) = 0;\n    if (*(int *)(param_1 + 0x20) == 0) {\n      *(undefined4 *)(param_1 + 0x20) = 0x4056dd;\n      *(undefined4 *)(param_1 + 0x28) = 0;\n    }\n    if (*(int *)(param_1 + 0x24) == 0) {\n      *(undefined4 *)(param_1 + 0x24) = 0x4056ee;\n    }\n    iVar1 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x18);\n    *(int *)(param_1 + 0x1c) = iVar1;\n    if (iVar1 != 0) {\n      *(undefined4 *)(iVar1 + 0x14) = 0;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 0;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 1;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x10) = 0xf;\n      uVar2 = FUN_0000432b(param_1,~-(uint)(*(int *)(*(int *)(param_1 + 0x1c) + 0xc) != 0) &\n                                   0x4055c4,0x8000);\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14) = uVar2;\n      if (*(int *)(*(int *)(param_1 + 0x1c) + 0x14) != 0) {\n        FUN_000056fa(param_1);\n        return 0;\n      }\n      FUN_00005739();\n    }\n    uVar2 = 0xfffffffc;\n  }\n  return uVar2;\n}\n\n",
    "0000350f": "\nvoid [MASK](int param_1,byte *param_2,byte *param_3)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  byte *pbVar6;\n  undefined1 local_38 [12];\n  uint local_2c;\n  int local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  uint *local_c;\n  uint *local_8;\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_38,(ThrowInfo *)0x40d570);\n  }\n  if (*(int *)(param_1 + 0x3cc) == 0x10) {\n    FUN_00002e7e(param_2,param_3);\n  }\n  else {\n    iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;\n    local_1c = *(int *)(iVar4 + 0x40bc24);\n    local_18 = *(int *)(iVar4 + 0x40bc2c);\n    local_20 = *(int *)(iVar4 + 0x40bc34);\n    if (0 < iVar3) {\n      puVar5 = (uint *)(param_1 + 0x454);\n      local_10 = iVar3;\n      local_8 = (uint *)(param_1 + 8);\n      do {\n        *puVar5 = (uint)*param_2 << 0x18;\n        *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n        *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n        *puVar5 = *puVar5 | (uint)param_2[3];\n        puVar1 = local_8 + 1;\n        param_2 = param_2 + 4;\n        *puVar5 = *puVar5 ^ *local_8;\n        local_10 = local_10 + -1;\n        puVar5 = puVar5 + 1;\n        local_8 = puVar1;\n      } while (local_10 != 0);\n    }\n    local_10 = 1;\n    if (1 < *(int *)(param_1 + 0x410)) {\n      local_c = (uint *)(param_1 + 0x28);\n      do {\n        if (0 < iVar3) {\n          local_8 = local_c;\n          local_24 = local_18 - local_1c;\n          param_2 = (byte *)local_1c;\n          local_28 = local_20 - local_1c;\n          puVar5 = (uint *)(param_1 + 0x434);\n          local_14 = iVar3;\n          do {\n            local_2c = (uint)*(byte *)(param_1 + 0x455 + ((local_24 + (int)param_2) % iVar3) * 4);\n            puVar1 = local_8 + 1;\n            *puVar5 = *(uint *)(local_2c * 4 + 0x4093fc) ^\n                      *(uint *)((*(uint *)(param_1 + 0x454 + ((local_28 + (int)param_2) % iVar3) * 4\n                                          ) & 0xff) * 4 + 0x4097fc) ^\n                      *(uint *)((uint)*(byte *)(param_1 + 0x456 + ((int)param_2 % iVar3) * 4) * 4 +\n                               0x408ffc) ^\n                      *(uint *)((uint)*(byte *)((int)puVar5 + 0x23) * 4 + 0x408bfc) ^ *local_8;\n            puVar5 = puVar5 + 1;\n            param_2 = (byte *)((int)param_2 + 1);\n            local_14 = local_14 + -1;\n            local_8 = puVar1;\n          } while (local_14 != 0);\n        }\n        memcpy((void *)(param_1 + 0x454),(void *)(param_1 + 0x434),iVar3 << 2);\n        local_c = local_c + 8;\n        local_10 = local_10 + 1;\n      } while (local_10 < *(int *)(param_1 + 0x410));\n    }\n    local_8 = (uint *)0x0;\n    if (0 < iVar3) {\n      local_1c = local_1c - local_18;\n      local_20 = local_20 - local_18;\n      pbVar6 = param_3;\n      param_3 = (byte *)(param_1 + 0x454);\n      do {\n        uVar2 = *(undefined4 *)(param_1 + 8 + ((int)local_8 + *(int *)(param_1 + 0x410) * 8) * 4);\n        *pbVar6 = *(byte *)(*(byte *)((int)param_3 + 3) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n        pbVar6[1] = *(byte *)(*(byte *)(param_1 + 0x456 + ((local_1c + local_18) % iVar3) * 4) +\n                             0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n        pbVar6[2] = *(byte *)(*(byte *)(param_1 + 0x455 + (local_18 % iVar3) * 4) + 0x4089fc) ^\n                    (byte)((uint)uVar2 >> 8);\n        param_2._0_1_ = (byte)uVar2;\n        pbVar6[3] = *(byte *)((*(uint *)(param_1 + 0x454 + ((local_20 + local_18) % iVar3) * 4) &\n                              0xff) + 0x4089fc) ^ (byte)param_2;\n        pbVar6 = pbVar6 + 4;\n        local_8 = (uint *)((int)local_8 + 1);\n        local_18 = local_18 + 1;\n        param_3 = (byte *)((int)param_3 + 4);\n      } while ((int)local_8 < iVar3);\n    }\n  }\n  return;\n}\n\n",
    "00006b8e": "\nint * [MASK](int *param_1,undefined4 param_2,undefined4 param_3,int param_4)\n\n{\n  int *_Str;\n  char cVar1;\n  size_t sVar2;\n  int iVar3;\n  int *local_8;\n  \n  if ((*param_1 == 0) && (param_1[1] == -1)) {\n    _Str = param_1 + 0x50;\n    local_8 = param_1;\n    (*pcRam004080d4)(0x104,_Str);\n    sVar2 = strlen((char *)_Str);\n    cVar1 = *(char *)(sVar2 + 0x13f + (int)param_1);\n    if ((cVar1 != '\\\\') && (cVar1 != '/')) {\n      strcat((char *)_Str,(char *)0x40f818);\n    }\n    if ((param_4 == 1) && (iVar3 = (*pcRam004080c8)(param_2,0,0,1), iVar3 == -1)) {\n      local_8 = (int *)0x2000000;\n    }\n    else {\n      iVar3 = FUN_00005bae(param_2,param_3,param_4,&local_8);\n      if (iVar3 != 0) {\n        iVar3 = FUN_00005fe2(iVar3);\n        *param_1 = iVar3;\n        local_8 = (int *)((-(uint)(iVar3 != 0) & 0xfffffe00) + 0x200);\n      }\n    }\n  }\n  else {\n    local_8 = (int *)0x1000000;\n  }\n  return local_8;\n}\n\n",
    "000056fa": "\nundefined4 [MASK](int param_1)\n\n{\n  uint *puVar1;\n  \n  if ((param_1 != 0) && (puVar1 = *(uint **)(param_1 + 0x1c), puVar1 != (uint *)0x0)) {\n    *(undefined4 *)(param_1 + 0x14) = 0;\n    *(undefined4 *)(param_1 + 8) = 0;\n    *(undefined4 *)(param_1 + 0x18) = 0;\n    *puVar1 = -(uint)(puVar1[3] != 0) & 7;\n    FUN_000042c0(*(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14),param_1,0);\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n",
    "000077ba": "\nvoid [MASK](void)\n\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  byte *pbVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined1 local_74 [4];\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined1 local_68 [4];\n  undefined1 local_64 [4];\n  undefined1 local_60 [44];\n  uint local_34;\n  undefined2 local_30;\n  undefined1 *local_1c;\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x40d488;\n  uStack_10 = 0x4076f4;\n  uStack_14 = puRamffdff000;\n  local_1c = &stack0xffffff78;\n  local_8 = 0;\n  puRamffdff000 = &uStack_14;\n  (*pcRam004081c4)(2);\n  uRam0040f94c = 0xffffffff;\n  uRam0040f950 = 0xffffffff;\n  puVar1 = (undefined4 *)(*pcRam004081c0)();\n  *puVar1 = uRam0040f948;\n  puVar1 = (undefined4 *)(*pcRam004081bc)();\n  *puVar1 = uRam0040f944;\n  uRam0040f954 = *puRam004081b8;\n  FUN_0000793f();\n  if (iRam0040f870 == 0) {\n    (*pcRam004081b4)(0x40793c);\n  }\n  FUN_0000792a();\n  initterm(0x40e008,0x40e00c);\n  local_70 = uRam0040f940;\n  (*pcRam004081ac)(local_64,local_74,local_68,uRam0040f93c,&local_70);\n  initterm(0x40e000,0x40e004);\n  pbVar3 = (byte *)*puRam004081a8;\n  if (*pbVar3 != 0x22) {\n    do {\n      if (*pbVar3 < 0x21) goto LAB_000078ad;\n      pbVar3 = pbVar3 + 1;\n    } while( true );\n  }\n  do {\n    pbVar3 = pbVar3 + 1;\n    if (*pbVar3 == 0) break;\n  } while (*pbVar3 != 0x22);\n  if (*pbVar3 != 0x22) goto LAB_000078ad;\n  do {\n    pbVar3 = pbVar3 + 1;\nLAB_000078ad:\n  } while ((*pbVar3 != 0) && (*pbVar3 < 0x21));\n  local_34 = 0;\n  (*pcRam004080c4)(local_60);\n  if ((local_34 & 1) == 0) {\n    local_30 = 10;\n  }\n  uVar5 = 0;\n  uVar4 = 0;\n  uVar2 = (*pcRam004080a4)(0,0,pbVar3,local_30);\n  local_6c = FUN_00001fe7(uVar2,uVar4,uVar5,pbVar3);\n  (*pcRam004081a4)(local_6c);\n  return;\n}\n\n",
    "000031bc": "\nvoid [MASK](int param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint uVar7;\n  undefined1 local_30 [16];\n  int local_20;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  int local_8;\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    uVar4 = ((uint)*param_2 << 0x18 | (uint)param_2[1] << 0x10 | (uint)param_2[2] << 8 |\n            (uint)param_2[3]) ^ *(uint *)(param_1 + 0x1e8);\n    local_14 = ((uint)param_2[4] << 0x18 | (uint)param_2[5] << 0x10 | (uint)param_2[6] << 8 |\n               (uint)param_2[7]) ^ *(uint *)(param_1 + 0x1ec);\n    local_10 = ((uint)param_2[8] << 0x18 | (uint)param_2[9] << 0x10 | (uint)param_2[10] << 8 |\n               (uint)param_2[0xb]) ^ *(uint *)(param_1 + 0x1f0);\n    iVar1 = *(int *)(param_1 + 0x410);\n    local_c = ((uint)CONCAT11(param_2[0xe],param_2[0xf]) |\n              (uint)param_2[0xc] << 0x18 | (uint)param_2[0xd] << 0x10) ^ *(uint *)(param_1 + 500);\n    if (1 < iVar1) {\n      puVar5 = (uint *)(param_1 + 0x210);\n      local_8 = iVar1 + -1;\n      do {\n        uVar7 = *(uint *)((local_c >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((local_14 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((uVar4 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_10 & 0xff) * 4 + 0x40a7fc) ^ puVar5[-1];\n        uVar3 = *(uint *)((local_10 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_14 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((uVar4 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((local_c & 0xff) * 4 + 0x40a7fc) ^ *puVar5;\n        uVar6 = *(uint *)((local_c >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_10 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_14 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((uVar4 & 0xff) * 4 + 0x40a7fc) ^ puVar5[1];\n        uVar4 = *(uint *)((local_c >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_10 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((uVar4 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_14 & 0xff) * 4 + 0x40a7fc) ^ puVar5[-2];\n        puVar5 = puVar5 + 8;\n        local_8 = local_8 + -1;\n        local_14 = uVar7;\n        local_10 = uVar3;\n        local_c = uVar6;\n      } while (local_8 != 0);\n    }\n    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 0x1e8 + param_1);\n    param_1 = iVar1 * 0x20 + 0x1e8 + param_1;\n    *param_3 = *(byte *)((uVar4 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[1] = *(byte *)((local_c >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[2] = *(byte *)((local_10 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[3] = *(byte *)((local_14 & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 4);\n    param_3[4] = *(byte *)((local_14 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[5] = *(byte *)((uVar4 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[6] = *(byte *)((local_c >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[7] = *(byte *)((local_10 & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 8);\n    param_3[8] = *(byte *)((local_10 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[9] = *(byte *)((local_14 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[10] = *(byte *)((uVar4 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xb] = *(byte *)((local_c & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 0xc);\n    param_3[0xc] = *(byte *)((local_c >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[0xd] = *(byte *)((local_10 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[0xe] = *(byte *)((local_14 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xf] = *(byte *)((uVar4 & 0xff) + 0x408afc) ^ (byte)local_8;\n    return;\n  }\n  local_20 = param_1;\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_30,(ThrowInfo *)0x40d570);\n}\n\n",
    "00001064": "\nundefined4 [MASK](undefined4 param_1,int param_2,int param_3)\n\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 local_58;\n  undefined4 local_54 [10];\n  undefined4 local_2c;\n  undefined2 local_28;\n  undefined4 local_14;\n  undefined4 local_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  \n  local_58 = 0x44;\n  puVar4 = local_54;\n  for (iVar3 = 0x10; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  local_14 = 0;\n  local_10 = 0;\n  uStack_c = 0;\n  uStack_8 = 0;\n  uVar2 = 1;\n  local_28 = 0;\n  local_2c = 1;\n  iVar3 = (*pcRam004080ec)(0,param_1,0,0,0,0x8000000,0,0,&local_58,&local_14);\n  if (iVar3 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    if (param_2 != 0) {\n      iVar3 = (*pcRam004080f4)(local_14,param_2);\n      if (iVar3 != 0) {\n        (*pcRam004080f8)(local_14,0xffffffff);\n      }\n      if (param_3 != 0) {\n        (*pcRam004080fc)(local_14,param_3);\n      }\n    }\n    pcVar1 = pcRam004080f0;\n    (*pcRam004080f0)(local_14);\n    (*pcVar1)(local_10);\n  }\n  return uVar2;\n}\n\n",
    "000010fd": "\nundefined4 [MASK](int param_1)\n\n{\n  size_t sVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  bool bVar5;\n  undefined4 uVar6;\n  char local_2e0;\n  undefined4 local_2df;\n  undefined4 local_d8 [5];\n  undefined4 local_c4 [45];\n  undefined4 local_10;\n  int local_c;\n  int local_8;\n  \n  puVar3 = (undefined4 *)0x40e04c;\n  puVar4 = local_d8;\n  for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar4 = *puVar3;\n    puVar3 = puVar3 + 1;\n    puVar4 = puVar4 + 1;\n  }\n  local_2e0 = '\\0';\n  local_8 = 0;\n  puVar3 = local_c4;\n  for (iVar2 = 0x2d; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puVar3 = &local_2df;\n  for (iVar2 = 0x81; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  *(undefined2 *)puVar3 = 0;\n  *(undefined1 *)((int)puVar3 + 2) = 0;\n  (*pcRam00408134)(local_d8,0x40e034);\n  local_c = 0;\n  do {\n    if (local_c == 0) {\n      uVar6 = 0x80000002;\n    }\n    else {\n      uVar6 = 0x80000001;\n    }\n    (*pcRam00408014)(uVar6,local_d8,&local_8);\n    if (local_8 != 0) {\n      if (param_1 == 0) {\n        local_10 = 0x207;\n        iVar2 = (*pcRam0040801c)(local_8,0x40e030,0,0,&local_2e0,&local_10);\n        bVar5 = iVar2 == 0;\n        if (bVar5) {\n          (*pcRam004080d8)(&local_2e0);\n        }\n      }\n      else {\n        (*pcRam004080d4)(0x207,&local_2e0);\n        sVar1 = strlen(&local_2e0);\n        iVar2 = (*pcRam00408018)(local_8,0x40e030,0,1,&local_2e0,sVar1 + 1);\n        bVar5 = iVar2 == 0;\n      }\n      (*pcRam00408020)(local_8);\n      if (bVar5) {\n        return 1;\n      }\n    }\n    local_c = local_c + 1;\n    if (1 < local_c) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
    "00006191": "\nvoid [MASK](uint param_1,int *param_2)\n\n{\n  param_2[3] = param_1 >> 0x10 & 0x1f;\n  param_2[5] = (param_1 >> 0x19) + 0x7bc;\n  param_2[2] = param_1 >> 0xb & 0x1f;\n  param_2[4] = (param_1 >> 0x15 & 0xf) - 1;\n  param_2[1] = param_1 >> 5 & 0x3f;\n  *param_2 = (param_1 & 0x1f) << 1;\n  return;\n}\n\n",
    "00001eff": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined1 local_68 [100];\n  \n  (*pcRam0040811c)(local_68,0x40f4ac,0x40f4b4,0);\n  iVar2 = 0;\n  if (0 < param_1) {\n    do {\n      iVar1 = (*pcRam00408080)(0x100000,1,local_68);\n      if (iVar1 != 0) {\n        (*pcRam004080f0)(iVar1);\n        return 1;\n      }\n      (*pcRam0040807c)(1000);\n      iVar2 = iVar2 + 1;\n    } while (iVar2 < param_1);\n  }\n  return 0;\n}\n\n",
    "000076a8": "\nchar * [MASK](char *_Dest,char *_Source)\n\n{\n  char *pcVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076a8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pcVar1 = (char *)(*pcRam00408128)();\n  return pcVar1;\n}\n\n",
    "00004c19": "\nundefined4\n[MASK](int *param_1,uint param_2,uint param_3,int param_4,int param_5,int *param_6,\n            uint *param_7,int param_8,uint *param_9,uint *param_10)\n\n{\n  undefined4 uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint *puVar6;\n  int *piVar7;\n  int iVar8;\n  uint uVar9;\n  undefined4 *puVar10;\n  byte bVar11;\n  int iVar12;\n  uint uVar13;\n  uint *puVar14;\n  int local_f4 [15];\n  uint local_b8 [16];\n  uint local_78 [19];\n  undefined4 local_2c;\n  uint local_28;\n  uint *local_24;\n  int local_20;\n  uint local_1c;\n  uint local_18;\n  uint *local_14;\n  uint local_10;\n  int local_c;\n  uint local_8;\n  \n  puVar6 = param_7;\n  local_78[0] = 0;\n  local_78[1] = 0;\n  local_78[2] = 0;\n  local_78[3] = 0;\n  local_78[4] = 0;\n  local_78[5] = 0;\n  local_78[6] = 0;\n  local_78[7] = 0;\n  local_78[8] = 0;\n  local_78[9] = 0;\n  local_78[10] = 0;\n  local_78[0xb] = 0;\n  local_78[0xc] = 0;\n  local_78[0xd] = 0;\n  local_78[0xe] = 0;\n  local_78[0xf] = 0;\n  piVar7 = param_1;\n  uVar13 = param_2;\n  do {\n    iVar12 = *piVar7;\n    piVar7 = piVar7 + 1;\n    local_78[iVar12] = local_78[iVar12] + 1;\n    uVar13 = uVar13 - 1;\n  } while (uVar13 != 0);\n  if (local_78[0] == param_2) {\n    *param_6 = 0;\n    *param_7 = 0;\n  }\n  else {\n    uVar13 = 1;\n    puVar14 = local_78;\n    param_7 = (uint *)*param_7;\n    do {\n      puVar14 = puVar14 + 1;\n      if (*puVar14 != 0) break;\n      uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x10);\n    local_8 = uVar13;\n    if (param_7 < uVar13) {\n      param_7 = (uint *)uVar13;\n    }\n    puVar14 = local_78 + 0xf;\n    uVar2 = 0xf;\n    do {\n      if (*puVar14 != 0) break;\n      uVar2 = uVar2 - 1;\n      puVar14 = puVar14 + -1;\n    } while (uVar2 != 0);\n    local_1c = uVar2;\n    if (uVar2 < param_7) {\n      param_7 = (uint *)uVar2;\n    }\n    iVar12 = 1 << ((byte)uVar13 & 0x1f);\n    *puVar6 = (uint)param_7;\n    if (uVar13 < uVar2) {\n      puVar6 = local_78 + uVar13;\n      do {\n        uVar3 = *puVar6;\n        if ((int)(iVar12 - uVar3) < 0) {\n          return 0xfffffffd;\n        }\n        uVar13 = uVar13 + 1;\n        puVar6 = puVar6 + 1;\n        iVar12 = (iVar12 - uVar3) * 2;\n      } while (uVar13 < uVar2);\n    }\n    local_78[0x11] = iVar12 - local_78[uVar2];\n    if ((int)local_78[0x11] < 0) {\n      return 0xfffffffd;\n    }\n    local_b8[1] = 0;\n    local_78[uVar2] = local_78[uVar2] + local_78[0x11];\n    iVar8 = 0;\n    iVar12 = uVar2 - 1;\n    if (iVar12 != 0) {\n      iVar4 = 0;\n      do {\n        iVar8 = iVar8 + *(int *)((int)local_78 + iVar4 + 4);\n        iVar12 = iVar12 + -1;\n        *(int *)((int)local_b8 + iVar4 + 8) = iVar8;\n        iVar4 = iVar4 + 4;\n      } while (iVar12 != 0);\n    }\n    uVar13 = 0;\n    do {\n      iVar12 = *param_1;\n      param_1 = param_1 + 1;\n      if (iVar12 != 0) {\n        uVar3 = local_b8[iVar12];\n        param_10[uVar3] = uVar13;\n        local_b8[iVar12] = uVar3 + 1;\n      }\n      uVar13 = uVar13 + 1;\n    } while (uVar13 < param_2);\n    uVar13 = local_b8[uVar2];\n    local_c = -1;\n    local_10 = 0;\n    local_14 = param_10;\n    iVar12 = -(int)param_7;\n    local_b8[0] = 0;\n    local_f4[0] = 0;\n    local_20 = 0;\n    param_1 = (int *)0x0;\n    if ((int)local_8 <= (int)local_1c) {\n      local_78[0x12] = local_8 - 1;\n      local_24 = local_78 + local_8;\n      uVar2 = local_28;\n      do {\n        uVar3 = *local_24;\n        local_18 = uVar3 - 1;\n        uVar1 = local_2c;\n        while (uVar3 != 0) {\n          local_2c._2_2_ = (undefined2)((uint)uVar1 >> 0x10);\n          local_78[0x10] = (int)param_7 + iVar12;\n          if ((int)local_78[0x10] < (int)local_8) {\n            do {\n              local_2c = uVar1;\n              iVar8 = local_c;\n              local_c = local_c + 1;\n              iVar12 = iVar12 + (int)param_7;\n              local_78[0x10] = local_78[0x10] + (int)param_7;\n              param_1 = (int *)(local_1c - iVar12);\n              if (param_7 < param_1) {\n                param_1 = (int *)param_7;\n              }\n              uVar9 = local_8 - iVar12;\n              uVar3 = 1 << ((byte)uVar9 & 0x1f);\n              if ((local_18 + 1 < uVar3) &&\n                 (iVar4 = uVar3 + (-1 - local_18), puVar6 = local_24, uVar9 < param_1)) {\n                while (uVar9 = uVar9 + 1, uVar9 < param_1) {\n                  uVar3 = puVar6[1];\n                  puVar6 = puVar6 + 1;\n                  uVar5 = iVar4 * 2;\n                  if (uVar5 < uVar3 || uVar5 - uVar3 == 0) break;\n                  iVar4 = uVar5 - uVar3;\n                }\n              }\n              param_1 = (int *)(1 << ((byte)uVar9 & 0x1f));\n              uVar3 = *param_9 + (int)param_1;\n              if (0x5a0 < uVar3) {\n                return 0xfffffffd;\n              }\n              local_20 = param_8 + *param_9 * 8;\n              local_f4[local_c] = local_20;\n              uVar5 = local_10;\n              iVar4 = local_20;\n              *param_9 = uVar3;\n              if (local_c == 0) {\n                *param_6 = local_20;\n              }\n              else {\n                local_b8[local_c] = local_10;\n                local_2c._0_2_ = CONCAT11((char)param_7,(byte)uVar9);\n                uVar5 = uVar5 >> ((char)iVar12 - (char)param_7 & 0x1fU);\n                iVar8 = local_f4[iVar8];\n                uVar2 = (iVar4 - iVar8 >> 3) - uVar5;\n                *(undefined4 *)(iVar8 + uVar5 * 8) = local_2c;\n                *(uint *)(iVar8 + 4 + uVar5 * 8) = uVar2;\n              }\n              uVar1 = local_2c;\n            } while ((int)local_78[0x10] < (int)local_8);\n          }\n          uVar3 = local_18;\n          bVar11 = (byte)iVar12;\n          if (local_14 < param_10 + uVar13) {\n            uVar2 = *local_14;\n            if (uVar2 < param_3) {\n              local_2c._0_1_ = (-(uVar2 < 0x100) & 0xa0U) + 0x60;\n            }\n            else {\n              iVar8 = (uVar2 - param_3) * 4;\n              local_2c._0_1_ = *(char *)(iVar8 + param_5) + 'P';\n              uVar2 = *(uint *)(iVar8 + param_4);\n            }\n            local_14 = local_14 + 1;\n          }\n          else {\n            local_2c._0_1_ = -0x40;\n          }\n          local_2c = CONCAT31(CONCAT21(local_2c._2_2_,(char)local_8 - bVar11),(char)local_2c);\n          iVar8 = 1 << ((char)local_8 - bVar11 & 0x1f);\n          uVar9 = local_10 >> (bVar11 & 0x1f);\n          if (uVar9 < param_1) {\n            puVar10 = (undefined4 *)(local_20 + uVar9 * 8);\n            do {\n              uVar9 = uVar9 + iVar8;\n              *puVar10 = local_2c;\n              puVar10[1] = uVar2;\n              puVar10 = puVar10 + iVar8 * 2;\n            } while (uVar9 < param_1);\n          }\n          uVar9 = 1 << ((byte)local_78[0x12] & 0x1f);\n          while ((local_10 & uVar9) != 0) {\n            local_10 = local_10 ^ uVar9;\n            uVar9 = uVar9 >> 1;\n          }\n          local_10 = local_10 ^ uVar9;\n          for (puVar6 = local_b8 + local_c;\n              ((1 << ((byte)iVar12 & 0x1f)) - 1U & local_10) != *puVar6; puVar6 = puVar6 + -1) {\n            local_c = local_c + -1;\n            iVar12 = iVar12 - (int)param_7;\n          }\n          local_18 = local_18 - 1;\n          uVar1 = local_2c;\n        }\n        local_8 = local_8 + 1;\n        local_24 = local_24 + 1;\n        local_78[0x12] = local_78[0x12] + 1;\n        local_2c = uVar1;\n      } while ((int)local_8 <= (int)local_1c);\n    }\n    if ((local_78[0x11] != 0) && (local_1c != 1)) {\n      return 0xfffffffb;\n    }\n  }\n  return 0;\n}\n\n",
    "00005e27": "\nvoid [MASK](undefined4 param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int local_8;\n  \n  iVar2 = FUN_00005def(param_1,&local_8);\n  iVar1 = local_8;\n  if ((iVar2 == 0) && (iVar2 = FUN_00005def(param_1,&local_8), iVar2 == 0)) {\n    *param_2 = local_8 * 0x100 + iVar1;\n    return;\n  }\n  *param_2 = 0;\n  return;\n}\n\n",
    "000017dd": "\nundefined4 * [MASK](undefined4 *param_1)\n\n{\n  param_1[1] = 0;\n  param_1[2] = 0;\n  param_1[3] = 0;\n  *param_1 = 0x4081ec;\n  (*pcRam00408038)(param_1 + 4);\n  return param_1;\n}\n\n",
    "00001225": "\nvoid [MASK](int param_1)\n\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  undefined4 *puVar6;\n  ushort *puVar7;\n  int iVar8;\n  ushort local_19c;\n  undefined4 local_19a [99];\n  undefined4 local_c;\n  uint local_8;\n  \n  local_19c = uRam0040f874;\n  local_c = 399;\n  puVar6 = local_19a;\n  for (iVar5 = 99; iVar5 != 0; iVar5 = iVar5 + -1) {\n    *puVar6 = 0;\n    puVar6 = puVar6 + 1;\n  }\n  *(undefined2 *)puVar6 = 0;\n  (*pcRam004080d0)(&local_19c,&local_c);\n  pcVar1 = pcRam00408138;\n  local_8 = 0;\n  iVar5 = 1;\n  iVar2 = (*pcRam00408138)(&local_19c);\n  if (iVar2 != 0) {\n    puVar7 = &local_19c;\n    do {\n      iVar5 = iVar5 * (uint)*puVar7;\n      local_8 = local_8 + 1;\n      puVar7 = puVar7 + 1;\n      uVar3 = (*pcVar1)(&local_19c);\n    } while (local_8 < uVar3);\n  }\n  (*pcRam00408124)(iVar5);\n  pcVar1 = pcRam00408120;\n  iVar5 = (*pcRam00408120)();\n  iVar8 = 0;\n  iVar2 = iVar5 % 8 + 8;\n  if (0 < iVar2) {\n    do {\n      iVar4 = (*pcVar1)();\n      *(char *)(iVar8 + param_1) = (char)(iVar4 % 0x1a) + 'a';\n      iVar8 = iVar8 + 1;\n    } while (iVar8 < iVar2);\n  }\n  for (; iVar8 < iVar5 % 8 + 0xb; iVar8 = iVar8 + 1) {\n    iVar2 = (*pcVar1)();\n    *(char *)(iVar8 + param_1) = (char)(iVar2 % 10) + '0';\n  }\n  *(undefined1 *)(iVar8 + param_1) = 0;\n  return;\n}\n\n",
    "000042c0": "\nvoid [MASK](int *param_1,int param_2,int *param_3)\n\n{\n  int iVar1;\n  \n  if (param_3 != (int *)0x0) {\n    *param_3 = param_1[0xf];\n  }\n  if ((*param_1 == 4) || (*param_1 == 5)) {\n    (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1[3]);\n  }\n  if (*param_1 == 6) {\n    FUN_000042af(param_1[1],param_2);\n  }\n  *param_1 = 0;\n  param_1[0xd] = param_1[10];\n  param_1[0xc] = param_1[10];\n  param_1[7] = 0;\n  param_1[8] = 0;\n  if ((code *)param_1[0xe] != (code *)0x0) {\n    iVar1 = (*(code *)param_1[0xe])(0,0,0);\n    param_1[0xf] = iVar1;\n    *(int *)(param_2 + 0x30) = iVar1;\n  }\n  return;\n}\n\n",
    "00006c40": "\nundefined4 [MASK](int *param_1,int param_2,undefined4 *param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  code *pcVar3;\n  undefined4 *_Src;\n  int *piVar4;\n  void *pvVar5;\n  byte bVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  byte bVar10;\n  byte bVar11;\n  char *_Source;\n  undefined8 uVar12;\n  char local_284 [260];\n  char local_180 [260];\n  uint local_7c [4];\n  uint local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  uint local_48;\n  undefined1 local_2c [4];\n  undefined8 local_28;\n  undefined4 local_20;\n  undefined4 local_1c;\n  int *local_18;\n  undefined4 local_14;\n  uint local_10;\n  undefined4 local_c;\n  byte local_5;\n  \n  _Src = param_3;\n  if ((param_2 < -1) || (*(int *)(*param_1 + 4) <= param_2)) {\n    return 0x10000;\n  }\n  local_18 = param_1;\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  param_1[1] = -1;\n  if (param_2 == param_1[0x4d]) {\n    if (param_2 != -1) {\n      memcpy(param_3,param_1 + 2,300);\n      return 0;\n    }\n  }\n  else if (param_2 != -1) {\n    if (param_2 < *(int *)(*param_1 + 0x10)) {\n      FUN_000064e2(*param_1);\n    }\n    while (*(int *)(*param_1 + 0x10) < param_2) {\n      FUN_00006520(*param_1);\n    }\n    FUN_000064bb(*param_1,local_7c,local_180,0x104,0,0,0,0);\n    iVar7 = FUN_0000657a(*param_1,local_2c,&local_14,&local_10);\n    if (iVar7 != 0) {\n      return 0x700;\n    }\n    iVar7 = FUN_00005d0e(*(undefined4 *)*param_1,local_14,0);\n    if (iVar7 == 0) {\n      local_c = operator_new(local_10);\n      uVar8 = FUN_00005d8a(local_c,1,local_10,*(undefined4 *)*param_1);\n      if (uVar8 == local_10) {\n        *param_3 = *(undefined4 *)(*param_1 + 0x10);\n        strcpy(local_284,local_180);\n        pcVar3 = pcRam00408194;\n        _Source = local_284;\n        while( true ) {\n          while( true ) {\n            for (; (cVar2 = *_Source, cVar2 != '\\0' && (_Source[1] == ':')); _Source = _Source + 2)\n            {\n            }\n            if ((cVar2 != '\\\\') && (cVar2 != '/')) break;\n            _Source = _Source + 1;\n          }\n          iVar7 = (*pcVar3)(_Source,0x40f838);\n          if ((iVar7 == 0) &&\n             (((iVar7 = (*pcVar3)(_Source,0x40f830), iVar7 == 0 &&\n               (iVar7 = (*pcVar3)(_Source,0x40f828), iVar7 == 0)) &&\n              (iVar7 = (*pcVar3)(_Source,0x40f820), iVar7 == 0)))) break;\n          _Source = (char *)(iVar7 + 4);\n        }\n        strcpy((char *)(param_3 + 1),_Source);\n        param_3._3_1_ = 0;\n        local_5 = 0;\n        bVar10 = ~(byte)(local_48 >> 0x17);\n        bVar6 = (byte)(local_48 >> 0x1e);\n        local_7c[0] = local_7c[0] >> 8;\n        bVar11 = 1;\n        if ((((local_7c[0] == 0) || (local_7c[0] == 7)) || (local_7c[0] == 0xb)) ||\n           (local_7c[0] == 0xe)) {\n          bVar10 = (byte)local_48;\n          param_3._3_1_ = (byte)(local_48 >> 1) & 1;\n          local_5 = (byte)(local_48 >> 2) & 1;\n          bVar6 = (byte)(local_48 >> 4);\n          bVar11 = (byte)(local_48 >> 5) & 1;\n        }\n        iVar7 = 0;\n        _Src[0x42] = 0;\n        if ((bVar6 & 1) != 0) {\n          _Src[0x42] = 0x10;\n        }\n        if (bVar11 != 0) {\n          _Src[0x42] = _Src[0x42] | 0x20;\n        }\n        if (param_3._3_1_ != 0) {\n          _Src[0x42] = _Src[0x42] | 2;\n        }\n        if ((bVar10 & 1) != 0) {\n          _Src[0x42] = _Src[0x42] | 1;\n        }\n        if (local_5 != 0) {\n          _Src[0x42] = _Src[0x42] | 4;\n        }\n        _Src[0x49] = local_64;\n        _Src[0x4a] = local_60;\n        local_28 = FUN_00006b23(local_6c >> 0x10,local_6c);\n        (*pcRam004080bc)(&local_28,&local_20);\n        pvVar5 = local_c;\n        _Src[0x43] = local_20;\n        _Src[0x45] = local_20;\n        _Src[0x47] = local_20;\n        _Src[0x44] = local_1c;\n        _Src[0x46] = local_1c;\n        _Src[0x48] = local_1c;\n        if (4 < local_10) {\n          do {\n            uVar8 = (uint)local_c >> 0x10;\n            local_c._0_2_ =\n                 CONCAT11(*(undefined1 *)((int)pvVar5 + iVar7 + 1),\n                          *(undefined1 *)(iVar7 + (int)pvVar5));\n            local_c = (void *)(CONCAT22((short)uVar8,(undefined2)local_c) & 0xff00ffff);\n            bVar10 = *(byte *)((int)pvVar5 + iVar7 + 2);\n            iVar9 = strcmp((char *)&local_c,(char *)0x40f81c);\n            if (iVar9 == 0) {\n              bVar10 = *(byte *)(iVar7 + 4 + (int)pvVar5);\n              local_5 = bVar10 >> 2 & 1;\n              iVar9 = iVar7 + 5;\n              if ((bVar10 & 1) != 0) {\n                puVar1 = (undefined1 *)(iVar9 + (int)pvVar5);\n                iVar9 = iVar7 + 9;\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),\n                                                        *(undefined1 *)(iVar7 + 6 + (int)pvVar5)),\n                                               *puVar1));\n                *(undefined8 *)(_Src + 0x47) = uVar12;\n              }\n              if ((bVar10 >> 1 & 1) != 0) {\n                iVar7 = iVar9 + 1;\n                puVar1 = (undefined1 *)(iVar9 + (int)pvVar5);\n                iVar9 = iVar9 + 4;\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),\n                                                        *(undefined1 *)(iVar7 + (int)pvVar5)),\n                                               *puVar1));\n                *(undefined8 *)(_Src + 0x43) = uVar12;\n              }\n              if (local_5 != 0) {\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)\n                                                         ((undefined1 *)(iVar9 + (int)pvVar5) + 2),\n                                                        *(undefined1 *)(iVar9 + 1 + (int)pvVar5)),\n                                               *(undefined1 *)(iVar9 + (int)pvVar5)));\n                *(undefined8 *)(_Src + 0x45) = uVar12;\n              }\n              break;\n            }\n            iVar7 = iVar7 + 4 + (uint)bVar10;\n          } while (iVar7 + 4U < local_10);\n        }\n        if (pvVar5 != (void *)0x0) {\n          operator_delete(pvVar5);\n        }\n        piVar4 = local_18;\n        memcpy(local_18 + 2,_Src,300);\n        piVar4[0x4d] = param_2;\n        return 0;\n      }\n      operator_delete(local_c);\n    }\n    return 0x800;\n  }\n  *param_3 = *(undefined4 *)(*param_1 + 4);\n  *(undefined1 *)(param_3 + 1) = 0;\n  param_3[0x42] = 0;\n  param_3[0x43] = 0;\n  param_3[0x44] = 0;\n  param_3[0x45] = 0;\n  param_3[0x46] = 0;\n  param_3[0x47] = 0;\n  param_3[0x48] = 0;\n  param_3[0x49] = 0;\n  param_3[0x4a] = 0;\n  return 0;\n}\n\n",
    "00001861": "\nundefined4 [MASK](int param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_0000182c();\n  if (iVar1 != 0) {\n    if (param_2 == 0) {\n      iVar1 = (*pcRam0040f898)(*(undefined4 *)(param_1 + 4),0x40ebf8,0x494,0,0,param_1 + 8);\n    }\n    else {\n      iVar1 = FUN_000018f9(*(undefined4 *)(param_1 + 4),param_1 + 8,param_2);\n    }\n    if (iVar1 != 0) {\n      return 1;\n    }\n  }\n  FUN_000018b9();\n  return 0;\n}\n\n",
    "0000795b": "\nvoid [MASK](void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
    "0000432b": "\nundefined4 * [MASK](int param_1,undefined4 param_2,int param_3)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  puVar1 = (undefined4 *)(**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x40);\n  if (puVar1 != (undefined4 *)0x0) {\n    iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),8,0x5a0);\n    puVar1[9] = iVar2;\n    if (iVar2 == 0) {\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);\n    }\n    else {\n      iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,param_3);\n      puVar1[10] = iVar2;\n      if (iVar2 != 0) {\n        *puVar1 = 0;\n        puVar1[0xb] = iVar2 + param_3;\n        puVar1[0xe] = param_2;\n        FUN_000042c0(puVar1,param_1,0);\n        return puVar1;\n      }\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1[9]);\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);\n    }\n  }\n  return (undefined4 *)0x0;\n}\n\n",
    "00006b23": "\nundefined8 [MASK](uint param_1,uint param_2)\n\n{\n  short local_1c;\n  ushort local_1a;\n  ushort local_16;\n  ushort local_14;\n  ushort local_12;\n  undefined2 local_10;\n  undefined2 local_e;\n  undefined8 local_c;\n  \n  local_e = 0;\n  local_1c = ((ushort)param_1 >> 9) + 0x7bc;\n  local_16 = (ushort)param_1 & 0x1f;\n  local_1a = (ushort)(param_1 >> 5) & 0xf;\n  local_14 = (ushort)param_2 >> 0xb;\n  local_10 = (undefined2)((param_2 & 0x1f) << 1);\n  local_12 = (ushort)(param_2 >> 5) & 0x3f;\n  (*pcRam004080b8)(&local_1c,&local_c);\n  return local_c;\n}\n\n",
    "00003bd6": "\nint [MASK](int param_1,void *param_2,int param_3)\n\n{\n  void *_Src;\n  uint uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  void *pvVar4;\n  uint uVar5;\n  undefined4 local_8;\n  \n  iVar2 = (int)param_2;\n  _Src = *(void **)(param_1 + 0x30);\n  pvVar4 = *(void **)(param_1 + 0x34);\n  local_8 = *(void **)((int)param_2 + 0xc);\n  if (pvVar4 < _Src) {\n    pvVar4 = *(void **)(param_1 + 0x2c);\n  }\n  uVar1 = *(uint *)((int)param_2 + 0x10);\n  uVar5 = (int)pvVar4 - (int)_Src;\n  if (uVar1 < (uint)((int)pvVar4 - (int)_Src)) {\n    uVar5 = uVar1;\n  }\n  if ((uVar5 != 0) && (param_3 == -5)) {\n    param_3 = 0;\n  }\n  *(int *)((int)param_2 + 0x14) = *(int *)((int)param_2 + 0x14) + uVar5;\n  *(uint *)((int)param_2 + 0x10) = uVar1 - uVar5;\n  if (*(code **)(param_1 + 0x38) != (code *)0x0) {\n    uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),_Src,uVar5);\n    *(undefined4 *)(param_1 + 0x3c) = uVar3;\n    *(undefined4 *)((int)param_2 + 0x30) = uVar3;\n  }\n  param_2 = _Src;\n  if (uVar5 != 0) {\n    memcpy(local_8,_Src,uVar5);\n    local_8 = (void *)((int)local_8 + uVar5);\n    param_2 = (void *)((int)_Src + uVar5);\n  }\n  if (param_2 == *(void **)(param_1 + 0x2c)) {\n    param_2 = *(void **)(param_1 + 0x28);\n    if (*(void **)(param_1 + 0x34) == *(void **)(param_1 + 0x2c)) {\n      *(void **)(param_1 + 0x34) = param_2;\n    }\n    uVar1 = *(uint *)(iVar2 + 0x10);\n    uVar5 = *(int *)(param_1 + 0x34) - (int)param_2;\n    if (uVar1 < uVar5) {\n      uVar5 = uVar1;\n    }\n    if ((uVar5 != 0) && (param_3 == -5)) {\n      param_3 = 0;\n    }\n    *(int *)(iVar2 + 0x14) = *(int *)(iVar2 + 0x14) + uVar5;\n    *(uint *)(iVar2 + 0x10) = uVar1 - uVar5;\n    if (*(code **)(param_1 + 0x38) != (code *)0x0) {\n      uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),param_2,uVar5);\n      *(undefined4 *)(param_1 + 0x3c) = uVar3;\n      *(undefined4 *)(iVar2 + 0x30) = uVar3;\n    }\n    if (uVar5 != 0) {\n      memcpy(local_8,param_2,uVar5);\n      local_8 = (void *)((int)local_8 + uVar5);\n      param_2 = (void *)((int)param_2 + uVar5);\n    }\n  }\n  *(void **)(iVar2 + 0xc) = local_8;\n  *(void **)(param_1 + 0x30) = param_2;\n  return param_3;\n}\n\n",
    "00004fa0": "\nint [MASK](undefined4 param_1,int *param_2,undefined4 param_3,undefined4 param_4,int param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 local_8;\n  \n  local_8 = 0;\n  iVar1 = (**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),0x13,4);\n  if (iVar1 == 0) {\n    iVar2 = -4;\n  }\n  else {\n    iVar2 = FUN_00004c19(param_1,0x13,0x13,0,0,param_3,param_2,param_4,&local_8,iVar1);\n    if (iVar2 == -3) {\n      *(undefined4 *)(param_5 + 0x18) = 0x40f6e4;\n    }\n    else if ((iVar2 == -5) || (*param_2 == 0)) {\n      *(undefined4 *)(param_5 + 0x18) = 0x40f6c0;\n      iVar2 = -3;\n    }\n    (**(code **)(param_5 + 0x24))(*(undefined4 *)(param_5 + 0x28),iVar1);\n  }\n  return iVar2;\n}\n\n",
    "00007603": "\nvoid [MASK](int *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5)\n\n{\n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else if (*param_1 == 1) {\n    uRam0040f938 = FUN_00007136(param_2,param_3,param_4,param_5);\n  }\n  else {\n    uRam0040f938 = 0x80000;\n  }\n  return;\n}\n\n",
    "000042af": "\nvoid [MASK](undefined4 param_1,int param_2)\n\n{\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);\n  return;\n}\n\n",
    "00007970": "\nvoid [MASK](void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
    "00005d8a": "\nuint [MASK](void *param_1,uint param_2,int param_3,char *param_4)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  int iVar3;\n  void *_Size;\n  \n  pcVar2 = param_4;\n  _Size = (void *)(param_2 * param_3);\n  if (*param_4 == '\\0') {\n    iVar3 = *(int *)(param_4 + 0x1c);\n    if (*(uint *)(param_4 + 0x18) < (uint)(iVar3 + (int)_Size)) {\n      _Size = (void *)(*(uint *)(param_4 + 0x18) - iVar3);\n    }\n    memcpy(param_1,(void *)(*(int *)(param_4 + 0x14) + iVar3),(size_t)_Size);\n    piVar1 = (int *)(pcVar2 + 0x1c);\n    *piVar1 = *piVar1 + (int)_Size;\n    param_1 = _Size;\n  }\n  else {\n    iVar3 = (*pcRam00408040)(*(undefined4 *)(param_4 + 4),param_1,_Size,&param_1,0);\n    if (iVar3 == 0) {\n      pcVar2[8] = '\\x01';\n    }\n  }\n  return (uint)param_1 / param_2;\n}\n\n",
    "00006880": "\nint [MASK](uint param_1,int param_2,uint param_3,undefined1 *param_4)\n\n{\n  int *piVar1;\n  char cVar2;\n  int *piVar3;\n  undefined1 uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  int local_c;\n  int local_8;\n  \n  local_c = 0;\n  local_8 = 0;\n  if (param_4 != (undefined1 *)0x0) {\n    *param_4 = 0;\n  }\n  if ((param_1 == 0) || (piVar3 = *(int **)(param_1 + 0x7c), piVar3 == (int *)0x0)) {\n    local_8 = -0x66;\n  }\n  else if (*piVar3 == 0) {\n    local_8 = -100;\n  }\n  else if (param_3 == 0) {\nLAB_00006a75:\n    local_8 = 0;\n  }\n  else {\n    piVar3[5] = param_3;\n    piVar3[4] = param_2;\n    if ((uint)piVar3[0x17] < param_3) {\n      piVar3[5] = piVar3[0x17];\n    }\n    if (piVar3[5] != 0) {\n      do {\n        if ((piVar3[2] == 0) && (uVar7 = piVar3[0x16], uVar7 != 0)) {\n          uVar6 = 0x4000;\n          if ((uVar7 < 0x4000) && (uVar6 = uVar7, uVar7 == 0)) {\n            if (param_4 != (undefined1 *)0x0) {\n              *param_4 = 1;\n            }\n            goto LAB_00006a75;\n          }\n          iVar5 = FUN_00005d0e(piVar3[0x18],piVar3[0x1a] + piVar3[0xf],0);\n          if ((iVar5 != 0) || (iVar5 = FUN_00005d8a(*piVar3,uVar6,1,piVar3[0x18]), iVar5 != 1)) {\n            return -1;\n          }\n          piVar3[0xf] = piVar3[0xf] + uVar6;\n          piVar3[0x16] = piVar3[0x16] - uVar6;\n          iVar5 = *piVar3;\n          piVar3[1] = iVar5;\n          piVar3[2] = uVar6;\n          if (((char)piVar3[0x1b] != '\\0') && (param_1 = 0, uVar6 != 0)) {\n            do {\n              uVar4 = FUN_000055a3(piVar3 + 0x1c,\n                                   CONCAT31((int3)(param_1 >> 8),*(undefined1 *)(param_1 + iVar5)));\n              uVar7 = param_1 + 1;\n              *(undefined1 *)(param_1 + iVar5) = uVar4;\n              param_1 = uVar7;\n            } while (uVar7 < uVar6);\n          }\n        }\n        uVar7 = piVar3[2];\n        uVar6 = piVar3[0x1f];\n        if (uVar7 < (uint)piVar3[0x1f]) {\n          uVar6 = uVar7;\n        }\n        if (uVar6 != 0) {\n          cVar2 = *(char *)(piVar3[1] + -1 + uVar6);\n          piVar1 = piVar3 + 0x1f;\n          *piVar1 = *piVar1 - uVar6;\n          piVar3[2] = uVar7 - uVar6;\n          piVar3[1] = piVar3[1] + uVar6;\n          if ((*piVar1 == 0) && (cVar2 != (char)piVar3[0x20])) {\n            return -0x6a;\n          }\n        }\n        if (piVar3[0x19] == 0) {\n          uVar7 = piVar3[2];\n          if ((uint)piVar3[5] < (uint)piVar3[2]) {\n            uVar7 = piVar3[5];\n          }\n          uVar6 = 0;\n          if (uVar7 != 0) {\n            do {\n              *(undefined1 *)(piVar3[4] + uVar6) = *(undefined1 *)(piVar3[1] + uVar6);\n              uVar6 = uVar6 + 1;\n            } while (uVar6 < uVar7);\n          }\n          iVar5 = FUN_0000541f(piVar3[0x14],piVar3[4],uVar7);\n          piVar3[0x17] = piVar3[0x17] - uVar7;\n          piVar3[2] = piVar3[2] - uVar7;\n          piVar3[5] = piVar3[5] - uVar7;\n          piVar3[4] = piVar3[4] + uVar7;\n          piVar3[1] = piVar3[1] + uVar7;\n          piVar3[6] = piVar3[6] + uVar7;\n          local_8 = local_8 + uVar7;\n          piVar3[0x14] = iVar5;\n          if ((piVar3[0x17] == 0) && (param_4 != (undefined1 *)0x0)) {\n            *param_4 = 1;\n          }\n        }\n        else {\n          iVar5 = piVar3[4];\n          iVar8 = piVar3[6];\n          local_c = FUN_0000583c(piVar3 + 1,2);\n          iVar8 = piVar3[6] - iVar8;\n          iVar5 = FUN_0000541f(piVar3[0x14],iVar5,iVar8);\n          piVar3[0x17] = piVar3[0x17] - iVar8;\n          local_8 = local_8 + iVar8;\n          piVar3[0x14] = iVar5;\n          if ((local_c == 1) || (piVar3[0x17] == 0)) {\n            if (param_4 == (undefined1 *)0x0) {\n              return local_8;\n            }\n            *param_4 = 1;\n            return local_8;\n          }\n          if (local_c != 0) {\n            return local_c;\n          }\n        }\n      } while (piVar3[5] != 0);\n      if (local_c != 0) {\n        return local_c;\n      }\n    }\n  }\n  return local_8;\n}\n\n",
    "00007572": "\nvoid [MASK](int param_1)\n\n{\n  if (*(void **)(param_1 + 0x138) != (void *)0x0) {\n    operator_delete(*(void **)(param_1 + 0x138));\n  }\n  *(undefined4 *)(param_1 + 0x138) = 0;\n  if (*(void **)(param_1 + 0x13c) != (void *)0x0) {\n    operator_delete(*(void **)(param_1 + 0x13c));\n  }\n  *(undefined4 *)(param_1 + 0x13c) = 0;\n  return;\n}\n\n",
    "00006520": "\nint [MASK](int param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 == 0) {\n    iVar1 = -0x66;\n  }\n  else if ((*(int *)(param_1 + 0x18) == 0) ||\n          (iVar1 = *(int *)(param_1 + 0x10) + 1, iVar1 == *(int *)(param_1 + 4))) {\n    iVar1 = -100;\n  }\n  else {\n    *(int *)(param_1 + 0x10) = iVar1;\n    *(int *)(param_1 + 0x14) =\n         *(int *)(param_1 + 0x14) +\n         *(int *)(param_1 + 0x50) + *(int *)(param_1 + 0x4c) + 0x2e + *(int *)(param_1 + 0x48);\n    iVar1 = FUN_000061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);\n    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);\n  }\n  return iVar1;\n}\n\n",
    "0000254b": "\nbool [MASK](int *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  uint local_20;\n  uint local_1c;\n  int local_18;\n  uint local_14;\n  undefined4 local_10;\n  int local_c;\n  uint local_8;\n  \n  piVar1 = param_1;\n  iVar3 = *(ushort *)(*param_1 + 0x14) + 0x18 + *param_1;\n  local_20 = *(uint *)(iVar3 + 8);\n  local_1c = ~(param_1[0xe] - 1U) & local_20;\n  local_18 = FUN_0000264f(param_1,iVar3);\n  local_14 = *(uint *)(iVar3 + 0x24);\n  local_10 = 0;\n  iVar2 = *param_1;\n  param_1 = (int *)0x1;\n  if (1 < *(ushort *)(iVar2 + 6)) {\n    do {\n      local_8 = *(uint *)(iVar3 + 0x30);\n      uVar4 = ~(piVar1[0xe] - 1U) & local_8;\n      local_c = FUN_0000264f(piVar1,iVar3 + 0x28);\n      if ((local_1c == uVar4) || (uVar4 < local_18 + local_20)) {\n        uVar4 = *(uint *)(iVar3 + 0x4c);\n        if (((uVar4 & 0x2000000) == 0) || ((local_14 & 0x2000000) == 0)) {\n          local_14 = (uVar4 | local_14) & 0xfdffffff;\n        }\n        else {\n          local_14 = local_14 | uVar4;\n        }\n        local_18 = (local_c - local_20) + local_8;\n      }\n      else {\n        iVar2 = FUN_0000267b(piVar1,&local_20);\n        if (iVar2 == 0) {\n          return false;\n        }\n        local_20 = local_8;\n        local_18 = local_c;\n        local_14 = *(uint *)(iVar3 + 0x4c);\n        local_1c = uVar4;\n      }\n      param_1 = (int *)((int)param_1 + 1);\n      iVar3 = iVar3 + 0x28;\n    } while ((int)param_1 < (int)(uint)*(ushort *)(*piVar1 + 6));\n  }\n  local_10 = 1;\n  iVar3 = FUN_0000267b(piVar1,&local_20);\n  return iVar3 != 0;\n}\n\n",
    "00002a46": "\nvoid [MASK](undefined4 *param_1)\n\n{\n  *(undefined1 *)(param_1 + 1) = 0;\n  *param_1 = 0x40bc7c;\n  return;\n}\n\n",
    "0000501f": "\nint [MASK](uint param_1,undefined4 param_2,int param_3,int *param_4,int *param_5,\n                undefined4 param_6,undefined4 param_7,undefined4 param_8,int param_9)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 local_8;\n  \n  local_8 = 0;\n  iVar1 = (**(code **)(param_9 + 0x20))(*(undefined4 *)(param_9 + 0x28),0x120,4);\n  if (iVar1 == 0) {\n    return -4;\n  }\n  iVar2 = FUN_00004c19(param_3,param_1,0x101,0x40ce6c,0x40cee8,param_6,param_4,param_8,&local_8,\n                       iVar1);\n  if (iVar2 == 0) {\n    if (*param_4 == 0) goto LAB_00005104;\n    iVar2 = FUN_00004c19(param_3 + param_1 * 4,param_2,0,0x40cf64,0x40cfdc,param_7,param_5,param_8,\n                         &local_8,iVar1);\n    if (iVar2 == 0) {\n      if ((*param_5 != 0) || (param_1 < 0x102)) {\n        iVar2 = 0;\n        goto LAB_00005110;\n      }\nLAB_000050e8:\n      *(undefined4 *)(param_9 + 0x18) = 0x40f750;\n    }\n    else {\n      if (iVar2 == -3) {\n        *(undefined4 *)(param_9 + 0x18) = 0x40f790;\n        goto LAB_00005110;\n      }\n      if (iVar2 != -5) {\n        if (iVar2 == -4) goto LAB_00005110;\n        goto LAB_000050e8;\n      }\n      *(undefined4 *)(param_9 + 0x18) = 0x40f774;\n    }\n  }\n  else {\n    if (iVar2 == -3) {\n      *(undefined4 *)(param_9 + 0x18) = 0x40f72c;\n      goto LAB_00005110;\n    }\n    if (iVar2 == -4) goto LAB_00005110;\nLAB_00005104:\n    *(undefined4 *)(param_9 + 0x18) = 0x40f70c;\n  }\n  iVar2 = -3;\nLAB_00005110:\n  (**(code **)(param_9 + 0x24))(*(undefined4 *)(param_9 + 0x28),iVar1);\n  return iVar2;\n}\n\n",
    "000076b4": "\nsize_t [MASK](char *_Str)\n\n{\n  size_t sVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076b4. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  sVar1 = (*pcRam00408130)();\n  return sVar1;\n}\n\n",
    "0000541f": "\nuint [MASK](uint param_1,byte *param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_2 == (byte *)0x0) {\n    return 0;\n  }\n  param_1 = ~param_1;\n  if (7 < param_3) {\n    uVar2 = param_3 >> 3;\n    do {\n      param_3 = param_3 - 8;\n      uVar1 = *(uint *)((param_1 & 0xff ^ (uint)*param_2) * 4 + 0x40d054) ^ param_1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[1]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[2]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[3]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[4]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[5]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[6]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      param_1 = uVar1 >> 8 ^ *(uint *)((uVar1 & 0xff ^ (uint)param_2[7]) * 4 + 0x40d054);\n      param_2 = param_2 + 8;\n      uVar2 = uVar2 - 1;\n    } while (uVar2 != 0);\n  }\n  for (; param_3 != 0; param_3 = param_3 - 1) {\n    param_1 = param_1 >> 8 ^ *(uint *)((param_1 & 0xff ^ (uint)*param_2) * 4 + 0x40d054);\n    param_2 = param_2 + 1;\n  }\n  return ~param_1;\n}\n\n",
    "00006a97": "\nundefined4 [MASK](int param_1)\n\n{\n  int *piVar1;\n  code *pcVar2;\n  undefined4 local_4;\n  \n  pcVar2 = pcRam00408174;\n  local_4 = 0;\n  if ((param_1 == 0) || (piVar1 = *(int **)(param_1 + 0x7c), piVar1 == (int *)0x0)) {\n    local_4 = 0xffffff9a;\n  }\n  else {\n    if ((piVar1[0x17] == 0) && (piVar1[0x14] != piVar1[0x15])) {\n      local_4 = 0xffffff97;\n    }\n    if (*piVar1 != 0) {\n      (*pcRam00408174)(*piVar1);\n      *piVar1 = 0;\n    }\n    *piVar1 = 0;\n    if (piVar1[0x10] != 0) {\n      FUN_00005739(piVar1 + 1);\n    }\n    piVar1[0x10] = 0;\n    (*pcVar2)(piVar1);\n    *(undefined4 *)(param_1 + 0x7c) = 0;\n  }\n  return local_4;\n}\n\n",
    "00003cfc": "\nvoid [MASK](int param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  \n  iVar1 = *param_2;\n  iVar2 = param_2[1];\n  uVar3 = *(undefined4 *)(param_1 + 0x34);\n  if (**(uint **)(param_1 + 4) < 10) {\n                    /* WARNING: Could not emulate address calculation at 0x00003d47 */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(**(uint **)(param_1 + 4) * 4 + 0x404287))();\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x20);\n  *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x1c);\n  param_2[1] = iVar2;\n  iVar2 = *param_2;\n  *param_2 = iVar1;\n  param_2[2] = param_2[2] + (iVar1 - iVar2);\n  *(undefined4 *)(param_1 + 0x34) = uVar3;\n  FUN_00003bd6(param_1,param_2,0xfffffffe);\n  return;\n}\n\n",
    "00002a53": "\nvoid * [MASK](void *param_1,byte param_2)\n\n{\n  FUN_00002a6f();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
    "0000514d": "\nundefined4 [MASK](int param_1,int param_2,int param_3,int param_4,int param_5,int *param_6)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  int iVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  byte *pbVar12;\n  undefined4 uStack_2c;\n  byte *local_14;\n  byte *local_10;\n  byte *local_c;\n  uint local_8;\n  \n  piVar3 = param_6;\n  local_10 = *(byte **)(param_5 + 0x34);\n  uVar9 = *(uint *)(param_5 + 0x1c);\n  local_c = (byte *)*param_6;\n  local_8 = param_6[1];\n  param_6 = *(int **)(param_5 + 0x20);\n  if (local_10 < *(byte **)(param_5 + 0x30)) {\n    local_14 = *(byte **)(param_5 + 0x30) + (-1 - (int)local_10);\n  }\n  else {\n    local_14 = (byte *)(*(int *)(param_5 + 0x2c) - (int)local_10);\n  }\n  uVar8 = *(uint *)(param_1 * 4 + 0x40bca8);\n  uVar2 = *(uint *)(param_2 * 4 + 0x40bca8);\n  do {\n    for (; uVar9 < 0x14; uVar9 = uVar9 + 8) {\n      local_8 = local_8 - 1;\n      param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n      local_c = local_c + 1;\n    }\n    pbVar12 = (byte *)(param_3 + (uVar8 & (uint)param_6) * 8);\n    bVar1 = *pbVar12;\nLAB_000051d5:\n    uVar6 = (uint)bVar1;\n    if (uVar6 != 0) {\n      param_6 = (int *)((uint)param_6 >> (pbVar12[1] & 0x1f));\n      uVar9 = uVar9 - pbVar12[1];\n      if ((bVar1 & 0x10) != 0) {\n        uVar6 = uVar6 & 0xf;\n        uVar10 = *(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6;\n        param_6 = (int *)((uint)param_6 >> (sbyte)uVar6);\n        uVar10 = uVar10 + *(int *)(pbVar12 + 4);\n        for (uVar9 = uVar9 - uVar6; uVar9 < 0xf; uVar9 = uVar9 + 8) {\n          local_8 = local_8 - 1;\n          param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n          local_c = local_c + 1;\n        }\n        uVar6 = uVar2 & (uint)param_6;\n        iVar4 = param_4 + uVar6 * 8;\n        param_6 = (int *)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));\n        uVar9 = uVar9 - *(byte *)(iVar4 + 1);\n        bVar1 = *(byte *)(param_4 + uVar6 * 8);\n        while ((bVar1 & 0x10) == 0) {\n          if ((bVar1 & 0x40) != 0) {\n            piVar3[6] = 0x40f618;\n            uVar8 = piVar3[1] - local_8;\n            if (uVar9 >> 3 < piVar3[1] - local_8) {\n              uVar8 = uVar9 >> 3;\n            }\n            uStack_2c = 0xfffffffd;\n            goto LAB_000053ed;\n          }\n          iVar7 = (*(uint *)((uint)bVar1 * 4 + 0x40bca8) & (uint)param_6) + *(int *)(iVar4 + 4);\n          pbVar12 = (byte *)(iVar4 + iVar7 * 8);\n          iVar4 = iVar4 + iVar7 * 8;\n          param_6 = (int *)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));\n          uVar9 = uVar9 - *(byte *)(iVar4 + 1);\n          bVar1 = *pbVar12;\n        }\n        uVar6 = bVar1 & 0xf;\n        for (; uVar9 < uVar6; uVar9 = uVar9 + 8) {\n          local_8 = local_8 - 1;\n          param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n          local_c = local_c + 1;\n        }\n        uVar11 = *(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6;\n        uVar9 = uVar9 - uVar6;\n        param_6 = (int *)((uint)param_6 >> (sbyte)uVar6);\n        local_14 = local_14 + -uVar10;\n        pbVar5 = local_10 + -(uVar11 + *(int *)(iVar4 + 4));\n        pbVar12 = *(byte **)(param_5 + 0x28);\n        if (pbVar5 < pbVar12) {\n          do {\n            pbVar5 = pbVar5 + (*(int *)(param_5 + 0x2c) - (int)pbVar12);\n          } while (pbVar5 < pbVar12);\n          uVar6 = *(int *)(param_5 + 0x2c) - (int)pbVar5;\n          if (uVar6 < uVar10) {\n            param_1 = uVar10 - uVar6;\n            do {\n              *local_10 = *pbVar5;\n              local_10 = local_10 + 1;\n              pbVar5 = pbVar5 + 1;\n              uVar6 = uVar6 - 1;\n            } while (uVar6 != 0);\n            pbVar12 = *(byte **)(param_5 + 0x28);\n            do {\n              *local_10 = *pbVar12;\n              local_10 = local_10 + 1;\n              pbVar12 = pbVar12 + 1;\n              param_1 = param_1 + -1;\n            } while (param_1 != 0);\n          }\n          else {\n            *local_10 = *pbVar5;\n            local_10[1] = pbVar5[1];\n            local_10 = local_10 + 2;\n            pbVar5 = pbVar5 + 2;\n            param_1 = uVar10 - 2;\n            do {\n              *local_10 = *pbVar5;\n              local_10 = local_10 + 1;\n              pbVar5 = pbVar5 + 1;\n              param_1 = param_1 + -1;\n            } while (param_1 != 0);\n          }\n        }\n        else {\n          *local_10 = *pbVar5;\n          local_10[1] = pbVar5[1];\n          local_10 = local_10 + 2;\n          pbVar5 = pbVar5 + 2;\n          param_1 = uVar10 - 2;\n          do {\n            *local_10 = *pbVar5;\n            local_10 = local_10 + 1;\n            pbVar5 = pbVar5 + 1;\n            param_1 = param_1 + -1;\n          } while (param_1 != 0);\n        }\n        goto LAB_0000536f;\n      }\n      if ((bVar1 & 0x40) == 0) break;\n      if ((bVar1 & 0x20) == 0) {\n        piVar3[6] = 0x40f630;\n        uVar8 = piVar3[1] - local_8;\n        if (uVar9 >> 3 < piVar3[1] - local_8) {\n          uVar8 = uVar9 >> 3;\n        }\n        uStack_2c = 0xfffffffd;\n      }\n      else {\n        uVar8 = piVar3[1] - local_8;\n        if (uVar9 >> 3 < piVar3[1] - local_8) {\n          uVar8 = uVar9 >> 3;\n        }\n        uStack_2c = 1;\n      }\n      goto LAB_000053ed;\n    }\n    param_6 = (int *)((uint)param_6 >> (pbVar12[1] & 0x1f));\n    uVar9 = uVar9 - pbVar12[1];\n    local_14 = local_14 + -1;\n    *local_10 = pbVar12[4];\n    local_10 = local_10 + 1;\nLAB_0000536f:\n    if ((local_14 < (byte *)0x102) || (local_8 < 10)) {\n      uVar8 = piVar3[1] - local_8;\n      if (uVar9 >> 3 < piVar3[1] - local_8) {\n        uVar8 = uVar9 >> 3;\n      }\n      uStack_2c = 0;\nLAB_000053ed:\n      *(int **)(param_5 + 0x20) = param_6;\n      *(uint *)(param_5 + 0x1c) = uVar9 + uVar8 * -8;\n      piVar3[1] = uVar8 + local_8;\n      iVar4 = *piVar3;\n      *piVar3 = (int)local_c - uVar8;\n      piVar3[2] = piVar3[2] + (((int)local_c - uVar8) - iVar4);\n      *(byte **)(param_5 + 0x34) = local_10;\n      return uStack_2c;\n    }\n  } while( true );\n  pbVar12 = pbVar12 + ((*(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6) + *(int *)(pbVar12 + 4)) *\n                      8;\n  bVar1 = *pbVar12;\n  goto LAB_000051d5;\n}\n\n",
    "0000267b": "\nbool [MASK](int *param_1,int *param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar1 = param_2[2];\n  if (uVar1 == 0) {\n    bVar5 = true;\n  }\n  else {\n    uVar2 = param_2[3];\n    if ((uVar2 & 0x2000000) == 0) {\n      uVar4 = *(uint *)((((uVar2 >> 0x1e & 1) + (uVar2 >> 0x1d & 1) * 2) * 2 - ((int)uVar2 >> 0x1f))\n                        * 4 + 0x40f53c);\n      if ((uVar2 & 0x4000000) != 0) {\n        uVar4 = uVar4 | 0x200;\n      }\n      iVar3 = (*pcRam004080ac)(*param_2,uVar1,uVar4,&param_2);\n      bVar5 = iVar3 != 0;\n    }\n    else {\n      if ((*param_2 == param_2[1]) &&\n         (((param_2[4] != 0 || (*(uint *)(*param_1 + 0x38) == param_1[0xe])) ||\n          (uVar1 % (uint)param_1[0xe] == 0)))) {\n        (*(code *)param_1[8])(*param_2,uVar1,0x4000,param_1[0xc]);\n      }\n      bVar5 = true;\n    }\n  }\n  return bVar5;\n}\n\n",
    "000076ae": "\nvoid * [MASK](void *_Dst,int _Val,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076ae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam0040812c)();\n  return pvVar1;\n}\n\n",
    "00001ce8": "\nundefined4 [MASK](undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined1 local_410 [1024];\n  int local_10;\n  undefined4 local_c;\n  int local_8;\n  \n  local_c = 0;\n  local_8 = (*pcRam00408024)(0,0,0xf003f);\n  if (local_8 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    local_10 = (*pcRam00408004)(local_8,0x40f8ac,0xf01ff);\n    if (local_10 == 0) {\n      (*pcRam0040811c)(local_410,0x40f42c,param_1);\n      iVar2 = (*pcRam00408000)(local_8,0x40f8ac,0x40f8ac,0xf01ff,0x10,2,1,local_410,0,0,0,0,0);\n      uVar1 = local_c;\n      if (iVar2 != 0) {\n        (*pcRam00408008)(iVar2,0,0);\n        (*pcRam0040800c)(iVar2);\n        local_c = 1;\n        uVar1 = local_c;\n      }\n    }\n    else {\n      (*pcRam00408008)(local_10,0,0);\n      (*pcRam0040800c)(local_10);\n      uVar1 = 1;\n    }\n    (*pcRam0040800c)(local_8);\n  }\n  return uVar1;\n}\n\n",
    "00005d0e": "\nundefined4 [MASK](char *param_1,int param_2,int param_3)\n\n{\n  undefined4 uVar1;\n  \n  if (*param_1 != '\\0') {\n    if (param_1[1] != '\\0') {\n      if (param_3 == 0) {\n        uVar1 = 0;\n        param_2 = *(int *)(param_1 + 0xc) + param_2;\n      }\n      else if (param_3 == 1) {\n        uVar1 = 1;\n      }\n      else {\n        if (param_3 != 2) {\n          return 0x13;\n        }\n        uVar1 = 2;\n      }\n      (*pcRam004080c8)(*(undefined4 *)(param_1 + 4),param_2,0,uVar1);\n      return 0;\n    }\n    if (*param_1 != '\\0') {\n      return 0x1d;\n    }\n  }\n  if (param_3 != 0) {\n    if (param_3 == 1) {\n      *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + param_2;\n      return 0;\n    }\n    if (param_3 != 2) {\n      return 0;\n    }\n    param_2 = *(int *)(param_1 + 0x18) + param_2;\n  }\n  *(int *)(param_1 + 0x1c) = param_2;\n  return 0;\n}\n\n",
    "0000271d": "\nundefined4 [MASK](int *param_1)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0xc0) == 0) {\n    return 1;\n  }\n  puVar2 = *(undefined4 **)(*(int *)(*param_1 + 0xc0) + 0xc + iVar1);\n  if (puVar2 != (undefined4 *)0x0) {\n    for (; (code *)*puVar2 != (code *)0x0; puVar2 = puVar2 + 1) {\n      (*(code *)*puVar2)(iVar1,1,0);\n    }\n  }\n  return 1;\n}\n\n",
    "00007740": "\nint [MASK](char *_Str1,char *_Str2)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007740. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = (*pcRam00408160)();\n  return iVar1;\n}\n\n",
    "00001000": "\nbool [MASK](undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  bool bVar3;\n  undefined4 uVar4;\n  \n  if (param_2 == 0) {\n    uVar4 = 0x40e018;\n  }\n  else {\n    uVar4 = 0x40e01c;\n  }\n  iVar1 = (*pcRam00408118)(0x40e010,uVar4);\n  if (iVar1 == 0) {\n    bVar3 = false;\n  }\n  else {\n    if (param_2 == 0) {\n      iVar2 = (*pcRam00408110)(param_1,0x30c,1,iVar1);\n    }\n    else {\n      iVar2 = (*pcRam00408114)();\n    }\n    bVar3 = iVar2 != 0;\n    (*pcRam0040810c)(iVar1);\n  }\n  return bVar3;\n}\n\n",
    "00005edf": "\nint [MASK](undefined4 param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int local_10;\n  uint local_c;\n  uint local_8;\n  \n  iVar1 = FUN_00005d0e(param_1,0,2);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00005cdd(param_1);\n    local_8 = 0xffff;\n    if (uVar2 < 0xffff) {\n      local_8 = uVar2;\n    }\n    iVar1 = (*pcRam00408178)(0x404);\n    if (iVar1 != 0) {\n      local_10 = -1;\n      local_c = 4;\n      if (4 < local_8) {\n        while( true ) {\n          uVar3 = local_c + 0x400;\n          local_c = local_8;\n          if (uVar3 <= local_8) {\n            local_c = uVar3;\n          }\n          iVar6 = uVar2 - local_c;\n          uVar3 = 0x404;\n          if (uVar2 - iVar6 < 0x405) {\n            uVar3 = uVar2 - iVar6;\n          }\n          iVar4 = FUN_00005d0e(param_1,iVar6,0);\n          if ((iVar4 != 0) || (iVar4 = FUN_00005d8a(iVar1,uVar3,1,param_1), iVar4 != 1)) break;\n          iVar4 = uVar3 - 3;\n          do {\n            iVar5 = iVar4;\n            iVar4 = iVar5 + -1;\n            if (iVar5 < 0) goto LAB_00005fc0;\n          } while ((((*(char *)(iVar4 + iVar1) != 'P') || (*(char *)(iVar5 + iVar1) != 'K')) ||\n                   (*(char *)(iVar5 + 1 + iVar1) != '\\x05')) ||\n                  (*(char *)(iVar5 + 2 + iVar1) != '\\x06'));\n          local_10 = iVar4 + iVar6;\nLAB_00005fc0:\n          if ((local_10 != 0) || (local_8 <= local_c)) break;\n        }\n      }\n      (*pcRam00408174)(iVar1);\n      return local_10;\n    }\n  }\n  return -1;\n}\n\n",
    "00003a28": "\nvoid [MASK](int param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined1 local_10 [12];\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    iVar1 = 0;\n    if (0 < *(int *)(param_1 + 0x3cc)) {\n      do {\n        *param_2 = *param_2 ^ *param_3;\n        param_3 = param_3 + 1;\n        param_2 = param_2 + 1;\n        iVar1 = iVar1 + 1;\n      } while (iVar1 < *(int *)(param_1 + 0x3cc));\n    }\n    return;\n  }\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n}\n\n",
    "000076c8": "\nvoid [MASK](void)\n\n{\n  undefined1 auStack_c [12];\n  \n  puRamffdff000 = auStack_c;\n  return;\n}\n\n",
    "000014a6": "\n/* WARNING: Type propagation algorithm not settling */\n\nint [MASK](int param_1,undefined4 param_2,uint *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int local_248 [2];\n  undefined1 local_240;\n  undefined4 local_23f;\n  undefined2 uStack_23b;\n  undefined1 uStack_239;\n  uint local_238;\n  uint local_234;\n  undefined1 local_230 [512];\n  undefined4 local_30;\n  int local_2c;\n  uint local_28;\n  int local_24;\n  uint local_20 [3];\n  undefined4 local_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x4081e0;\n  uStack_10 = 0x4076f4;\n  local_14 = puRamffdff000;\n  iVar3 = 0;\n  local_30 = 0;\n  local_248[0] = 0;\n  local_240 = 0;\n  local_23f = 0;\n  uStack_23b = 0;\n  uStack_239 = 0;\n  local_248[1] = 0;\n  local_20[0] = 0;\n  local_8 = 0;\n  puRamffdff000 = &local_14;\n  iVar1 = (*pcRam00408034)(param_2,0x80000000,1,0,3,0,0);\n  if (iVar1 != -1) {\n    (*pcRam00408030)(iVar1,&local_28);\n    if ((local_24 < 1) && ((local_24 < 0 || (local_28 < 0x6400001)))) {\n      iVar2 = (*pcRam0040f880)(iVar1,&local_240,8,local_20,0);\n      if (iVar2 != 0) {\n        iVar2 = memcmp(&local_240,(void *)0x40eb7c,8);\n        if (iVar2 == 0) {\n          iVar2 = (*pcRam0040f880)(iVar1,local_248,4,local_20,0);\n          if ((iVar2 != 0) && (local_248[0] == 0x100)) {\n            iVar2 = (*pcRam0040f880)(iVar1,*(undefined4 *)(param_1 + 0x4c8),0x100,local_20,0);\n            if (iVar2 != 0) {\n              iVar2 = (*pcRam0040f880)(iVar1,local_248 + 1,4,local_20,0);\n              if (iVar2 != 0) {\n                iVar2 = (*pcRam0040f880)(iVar1,&local_238,8,local_20,0);\n                if (((iVar2 != 0) && ((int)local_234 < 1)) &&\n                   (((int)local_234 < 0 || (local_238 < 0x6400001)))) {\n                  iVar2 = FUN_000019e1(*(undefined4 *)(param_1 + 0x4c8),local_248[0],local_230,\n                                       &local_30);\n                  if (iVar2 != 0) {\n                    FUN_00002a76(local_230,uRam0040f578,local_30,0x10);\n                    local_2c = (*pcRam004080dc)(0,local_238);\n                    if (local_2c != 0) {\n                      iVar2 = (*pcRam0040f880)(iVar1,*(undefined4 *)(param_1 + 0x4c8),local_28,\n                                               local_20,0);\n                      iVar1 = local_2c;\n                      if (((iVar2 != 0) && (local_20[0] != 0)) &&\n                         ((0x7fffffff < local_234 ||\n                          (((int)local_234 < 1 && (local_238 <= local_20[0])))))) {\n                        FUN_00003a77(*(undefined4 *)(param_1 + 0x4c8),local_2c,local_20[0],1);\n                        *param_3 = local_238;\n                        iVar3 = iVar1;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  local_unwind2(&local_14,0xffffffff);\n  puRamffdff000 = (undefined4 *)local_14;\n  return iVar3;\n}\n\n",
    "000017ff": "\nvoid * [MASK](void *param_1,byte param_2)\n\n{\n  FUN_0000181b();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
    "0000797b": "\nvoid [MASK](void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
    "00007986": "\nvoid [MASK](void)\n\n{\n  FUN_00002a6f();\n  return;\n}\n\n",
    "00002457": "\nundefined4 [MASK](uint param_1,uint param_2)\n\n{\n  if (param_1 < param_2) {\n    (*pcRam004080a8)(0xd);\n    return 0;\n  }\n  return 1;\n}\n\n",
    "000061e0": "\nint [MASK](undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,int param_4,\n                uint param_5,int param_6,uint param_7,int param_8,uint param_9)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 *puVar3;\n  uint uVar4;\n  undefined4 local_60;\n  undefined1 local_5c [4];\n  undefined1 local_58 [4];\n  undefined1 local_54 [4];\n  undefined4 local_50;\n  undefined1 local_4c [4];\n  undefined1 local_48 [4];\n  undefined1 local_44 [4];\n  uint local_40;\n  uint local_3c;\n  uint local_38;\n  undefined1 local_34 [4];\n  undefined1 local_30 [4];\n  undefined1 local_2c [4];\n  undefined1 local_28 [24];\n  undefined4 local_10;\n  int local_c;\n  int local_8;\n  \n  puVar3 = param_1;\n  local_8 = 0;\n  if (param_1 == (undefined4 *)0x0) {\n    return -0x66;\n  }\n  iVar1 = FUN_00005d0e(*param_1,param_1[5] + param_1[3],0);\n  if (iVar1 == 0) {\n    iVar1 = FUN_00005e6b(*param_1,&local_c);\n    if (iVar1 == 0) {\n      if (local_c != 0x2014b50) {\n        local_8 = -0x67;\n      }\n    }\n    else {\n      local_8 = -1;\n    }\n  }\n  else {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_60);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_5c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_58);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_54);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,&local_50);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  FUN_00006191(local_50,local_28);\n  iVar1 = FUN_00005e6b(*param_1,local_4c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_48);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_44);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_40);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_3c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_38);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_34);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_30);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_2c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,&local_10);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  uVar2 = local_40;\n  if (local_8 == 0) {\n    if (param_4 != 0) {\n      uVar2 = param_5;\n      if (local_40 < param_5) {\n        *(undefined1 *)(local_40 + param_4) = 0;\n        uVar2 = local_40;\n      }\n      if (((local_40 != 0) && (param_5 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_4,uVar2,1,*param_1), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      uVar2 = local_40 - uVar2;\n      if (local_8 != 0) goto LAB_00006435;\n    }\n    if (param_6 != 0) {\n      uVar4 = local_3c;\n      if (param_7 <= local_3c) {\n        uVar4 = param_7;\n      }\n      if (uVar2 != 0) {\n        iVar1 = FUN_00005d0e(*param_1,uVar2,1);\n        if (iVar1 == 0) {\n          param_1 = (undefined4 *)0x0;\n          uVar2 = (uint)param_1;\n        }\n        else {\n          local_8 = -1;\n        }\n      }\n      param_1 = (undefined4 *)uVar2;\n      if (((local_3c != 0) && (param_7 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_6,uVar4,1,*puVar3), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      iVar1 = (int)param_1 + (local_3c - uVar4);\n      goto LAB_00006438;\n    }\n  }\nLAB_00006435:\n  iVar1 = uVar2 + local_3c;\nLAB_00006438:\n  if (local_8 == 0) {\n    if (param_8 != 0) {\n      uVar2 = param_9;\n      if (local_38 < param_9) {\n        *(undefined1 *)(local_38 + param_8) = 0;\n        uVar2 = local_38;\n      }\n      if ((iVar1 != 0) && (iVar1 = FUN_00005d0e(*puVar3,iVar1,1), iVar1 != 0)) {\n        local_8 = -1;\n      }\n      if (((local_38 != 0) && (param_9 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_8,uVar2,1,*puVar3), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      if (local_8 != 0) {\n        return local_8;\n      }\n    }\n    if (param_2 != (undefined4 *)0x0) {\n      puVar3 = &local_60;\n      for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *param_2 = *puVar3;\n        puVar3 = puVar3 + 1;\n        param_2 = param_2 + 1;\n      }\n    }\n    if (param_3 != (undefined4 *)0x0) {\n      *param_3 = local_10;\n    }\n  }\n  return local_8;\n}\n\n",
    "0000135e": "\nvoid * [MASK](void *param_1,byte param_2)\n\n{\n  FUN_0000137a();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
    "000064bb": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)\n\n{\n  FUN_000061e0(param_1,param_2,0,param_3,param_4,param_5,param_6,param_7,param_8);\n  return;\n}\n\n",
    "00007070": "\nvoid [MASK](char *param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined1 local_20c [260];\n  char local_108 [260];\n  \n  if ((param_1 != (char *)0x0) && (iVar2 = (*pcRam00408068)(param_1), iVar2 == -1)) {\n    (*pcRam004080c0)(param_1,0);\n  }\n  cVar1 = *param_2;\n  pcVar3 = param_2;\n  pcVar4 = param_2;\n  if (cVar1 != '\\0') {\n    do {\n      if ((cVar1 == '/') || (cVar1 == '\\\\')) {\n        pcVar4 = pcVar3;\n      }\n      cVar1 = pcVar3[1];\n      pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    if (pcVar4 != param_2) {\n      memcpy(local_20c,param_2,(int)pcVar4 - (int)param_2);\n      local_20c[(int)pcVar4 - (int)param_2] = 0;\n      FUN_00007070(param_1,local_20c);\n    }\n    local_108[0] = '\\0';\n    if (param_1 != (char *)0x0) {\n      strcpy(local_108,param_1);\n    }\n    strcat(local_108,param_2);\n    iVar2 = (*pcRam00408068)(local_108);\n    if (iVar2 == -1) {\n      (*pcRam004080c0)(local_108,0);\n    }\n  }\n  return;\n}\n\n",
    "000018b9": "\nundefined4 [MASK](int param_1)\n\n{\n  if (*(int *)(param_1 + 8) != 0) {\n    (*pcRam0040f89c)(*(int *)(param_1 + 8));\n    *(undefined4 *)(param_1 + 8) = 0;\n  }\n  if (*(int *)(param_1 + 0xc) != 0) {\n    (*pcRam0040f89c)(*(int *)(param_1 + 0xc));\n    *(undefined4 *)(param_1 + 0xc) = 0;\n  }\n  if (*(int *)(param_1 + 4) != 0) {\n    (*pcRam00408010)(*(int *)(param_1 + 4),0);\n    *(undefined4 *)(param_1 + 4) = 0;\n  }\n  return 1;\n}\n\n",
    "0000583c": "\nundefined4 [MASK](int *param_1)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  \n  if ((((param_1 != (int *)0x0) && ((uint *)param_1[7] != (uint *)0x0)) && (*param_1 != 0)) &&\n     (uVar1 = *(uint *)param_1[7], uVar1 < 0xe)) {\n                    /* WARNING: Could not emulate address calculation at 0x00005880 */\n                    /* WARNING: Treating indirect jump as call */\n    uVar2 = (**(code **)(uVar1 * 4 + 0x405b76))();\n    return uVar2;\n  }\n  return 0xfffffffe;\n}\n\n",
    "00005739": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  \n  if (((param_1 != 0) && (*(int *)(param_1 + 0x1c) != 0)) && (*(int *)(param_1 + 0x24) != 0)) {\n    iVar1 = *(int *)(*(int *)(param_1 + 0x1c) + 0x14);\n    if (iVar1 != 0) {\n      FUN_00004be5(iVar1,param_1);\n    }\n    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),*(undefined4 *)(param_1 + 0x1c));\n    *(undefined4 *)(param_1 + 0x1c) = 0;\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n",
    "00007918": "\nvoid __thiscall type_info::~[MASK](type_info *this)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00007918. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408198)();\n  return;\n}\n\n",
    "000075c4": "\nvoid [MASK](int *param_1,undefined4 param_2,undefined4 *param_3)\n\n{\n  *param_3 = 0;\n  *(undefined1 *)(param_3 + 1) = 0;\n  param_3[0x4a] = 0;\n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else if (*param_1 == 1) {\n    uRam0040f938 = FUN_00006c40(param_2,param_3);\n  }\n  else {\n    uRam0040f938 = 0x80000;\n  }\n  return;\n}\n\n",
    "00002a76": "\nvoid [MASK](int param_1,byte *param_2,uint *param_3,int param_4,byte *param_5)\n\n{\n  undefined4 uVar1;\n  uint uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  undefined4 *puVar6;\n  int iVar7;\n  int iVar8;\n  undefined4 *puVar9;\n  int iVar10;\n  undefined1 local_18 [20];\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  if (((param_4 != 0x10) && (param_4 != 0x18)) && (param_4 != 0x20)) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  if (((param_5 != (byte *)0x10) && (param_5 != (byte *)0x18)) && (param_5 != (byte *)0x20)) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  *(byte **)(param_1 + 0x3cc) = param_5;\n  *(int *)(param_1 + 0x3c8) = param_4;\n  memcpy((void *)(param_1 + 0x3d0),param_3,(size_t)param_5);\n  memcpy((void *)(param_1 + 0x3f0),param_3,*(size_t *)(param_1 + 0x3cc));\n  if (*(int *)(param_1 + 0x3c8) == 0x10) {\n    if (*(int *)(param_1 + 0x3cc) == 0x10) {\n      iVar3 = 10;\n    }\n    else {\n      iVar3 = ((*(int *)(param_1 + 0x3cc) != 0x18) - 1 & 0xfffffffe) + 0xe;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0x3c8) != 0x18) {\n      *(undefined4 *)(param_1 + 0x410) = 0xe;\n      goto LAB_00002b9a;\n    }\n    iVar3 = ((*(int *)(param_1 + 0x3cc) == 0x20) - 1 & 0xfffffffe) + 0xe;\n  }\n  *(int *)(param_1 + 0x410) = iVar3;\nLAB_00002b9a:\n  iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n  iVar7 = 0;\n  if (-1 < *(int *)(param_1 + 0x410)) {\n    puVar6 = (undefined4 *)(param_1 + 8);\n    do {\n      iVar10 = iVar3;\n      puVar9 = puVar6;\n      if (0 < iVar3) {\n        for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n          *puVar9 = 0;\n          puVar9 = puVar9 + 1;\n        }\n      }\n      iVar7 = iVar7 + 1;\n      puVar6 = puVar6 + 8;\n    } while (iVar7 <= *(int *)(param_1 + 0x410));\n  }\n  iVar7 = 0;\n  if (-1 < *(int *)(param_1 + 0x410)) {\n    puVar6 = (undefined4 *)(param_1 + 0x1e8);\n    do {\n      iVar10 = iVar3;\n      puVar9 = puVar6;\n      if (0 < iVar3) {\n        for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n          *puVar9 = 0;\n          puVar9 = puVar9 + 1;\n        }\n      }\n      iVar7 = iVar7 + 1;\n      puVar6 = puVar6 + 8;\n    } while (iVar7 <= *(int *)(param_1 + 0x410));\n  }\n  iVar7 = *(int *)(param_1 + 0x3c8) / 4;\n  iVar10 = (*(int *)(param_1 + 0x410) + 1) * iVar3;\n  puVar5 = (uint *)(param_1 + 0x414);\n  param_3 = (uint *)iVar7;\n  if (0 < iVar7) {\n    do {\n      *puVar5 = (uint)*param_2 << 0x18;\n      *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n      *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n      *puVar5 = *puVar5 | (uint)param_2[3];\n      param_2 = param_2 + 4;\n      puVar5 = puVar5 + 1;\n      param_3 = (uint *)((int)param_3 + -1);\n    } while (param_3 != (uint *)0x0);\n  }\n  param_3 = (uint *)0x0;\n  if (0 < iVar7) {\n    puVar6 = (undefined4 *)(param_1 + 0x414);\n    do {\n      if (iVar10 <= (int)param_3) goto LAB_00002e04;\n      iVar4 = (int)param_3 / iVar3;\n      iVar8 = (int)param_3 % iVar3;\n      *(undefined4 *)(param_1 + 8 + (iVar8 + iVar4 * 8) * 4) = *puVar6;\n      param_3 = (uint *)((int)param_3 + 1);\n      uVar1 = *puVar6;\n      puVar6 = puVar6 + 1;\n      *(undefined4 *)(param_1 + 0x1e8 + (iVar8 + (*(int *)(param_1 + 0x410) - iVar4) * 8) * 4) =\n           uVar1;\n    } while ((int)param_3 < iVar7);\n  }\n  if ((int)param_3 < iVar10) {\n    param_5 = (byte *)0x40bbfc;\n    do {\n      uVar2 = *(uint *)(param_1 + 0x410 + iVar7 * 4);\n      *(uint *)(param_1 + 0x414) =\n           *(uint *)(param_1 + 0x414) ^\n           CONCAT31(CONCAT21(CONCAT11(*(byte *)((uVar2 >> 0x10 & 0xff) + 0x4089fc) ^ *param_5,\n                                      *(undefined1 *)((uVar2 >> 8 & 0xff) + 0x4089fc)),\n                             *(undefined1 *)((uVar2 & 0xff) + 0x4089fc)),\n                    *(undefined1 *)((uVar2 >> 0x18) + 0x4089fc));\n      param_5 = param_5 + 1;\n      if (iVar7 == 8) {\n        puVar5 = (uint *)(param_1 + 0x418);\n        iVar4 = 3;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n        uVar2 = *(uint *)(param_1 + 0x420);\n        puVar5 = (uint *)(param_1 + 0x428);\n        *(uint *)(param_1 + 0x424) =\n             *(uint *)(param_1 + 0x424) ^\n             CONCAT31(CONCAT21(CONCAT11(*(undefined1 *)((uVar2 >> 0x18) + 0x4089fc),\n                                        *(undefined1 *)((uVar2 >> 0x10 & 0xff) + 0x4089fc)),\n                               *(undefined1 *)((uVar2 >> 8 & 0xff) + 0x4089fc)),\n                      *(undefined1 *)((uVar2 & 0xff) + 0x4089fc));\n        iVar4 = 3;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n      }\n      else if (1 < iVar7) {\n        puVar5 = (uint *)(param_1 + 0x418);\n        iVar4 = iVar7 + -1;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n      }\n      param_2 = (byte *)0x0;\n      if (0 < iVar7) {\n        puVar6 = (undefined4 *)(param_1 + 0x414);\n        do {\n          if (iVar10 <= (int)param_3) goto LAB_00002e04;\n          iVar4 = (int)param_3 / iVar3;\n          iVar8 = (int)param_3 % iVar3;\n          *(undefined4 *)(param_1 + 8 + (iVar8 + iVar4 * 8) * 4) = *puVar6;\n          param_2 = (byte *)((int)param_2 + 1);\n          uVar1 = *puVar6;\n          puVar6 = puVar6 + 1;\n          param_3 = (uint *)((int)param_3 + 1);\n          *(undefined4 *)(param_1 + 0x1e8 + (iVar8 + (*(int *)(param_1 + 0x410) - iVar4) * 8) * 4) =\n               uVar1;\n        } while ((int)param_2 < iVar7);\n      }\n    } while ((int)param_3 < iVar10);\n  }\nLAB_00002e04:\n  param_5 = (byte *)0x1;\n  if (1 < *(int *)(param_1 + 0x410)) {\n    param_3 = (uint *)(param_1 + 0x208);\n    do {\n      iVar7 = iVar3;\n      puVar5 = param_3;\n      if (0 < iVar3) {\n        do {\n          uVar2 = *puVar5;\n          *puVar5 = *(uint *)((uVar2 >> 0x18) * 4 + 0x40abfc) ^\n                    *(uint *)((uVar2 >> 0x10 & 0xff) * 4 + 0x40affc) ^\n                    *(uint *)((uVar2 >> 8 & 0xff) * 4 + 0x40b3fc) ^\n                    *(uint *)((uVar2 & 0xff) * 4 + 0x40b7fc);\n          iVar7 = iVar7 + -1;\n          puVar5 = puVar5 + 1;\n        } while (iVar7 != 0);\n      }\n      param_5 = (byte *)((int)param_5 + 1);\n      param_3 = param_3 + 8;\n    } while ((int)param_5 < *(int *)(param_1 + 0x410));\n  }\n  *(undefined1 *)(param_1 + 4) = 1;\n  return;\n}\n\n",
    "00005cc7": "\nundefined4 [MASK](char *param_1)\n\n{\n  if ((*param_1 != '\\0') && (param_1[8] != '\\0')) {\n    return 1;\n  }\n  return 0;\n}\n\n",
    "00003797": "\nvoid [MASK](int param_1,byte *param_2,byte *param_3)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  byte *pbVar6;\n  undefined1 local_38 [12];\n  uint local_2c;\n  int local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  uint *local_c;\n  uint *local_8;\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_38,(ThrowInfo *)0x40d570);\n  }\n  if (*(int *)(param_1 + 0x3cc) == 0x10) {\n    FUN_000031bc(param_2,param_3);\n  }\n  else {\n    iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;\n    local_1c = *(int *)(iVar4 + 0x40bc28);\n    local_18 = *(int *)(iVar4 + 0x40bc30);\n    local_20 = *(int *)(iVar4 + 0x40bc38);\n    if (0 < iVar3) {\n      puVar5 = (uint *)(param_1 + 0x454);\n      local_10 = iVar3;\n      local_8 = (uint *)(param_1 + 0x1e8);\n      do {\n        *puVar5 = (uint)*param_2 << 0x18;\n        *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n        *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n        *puVar5 = *puVar5 | (uint)param_2[3];\n        puVar1 = local_8 + 1;\n        param_2 = param_2 + 4;\n        *puVar5 = *puVar5 ^ *local_8;\n        local_10 = local_10 + -1;\n        puVar5 = puVar5 + 1;\n        local_8 = puVar1;\n      } while (local_10 != 0);\n    }\n    local_10 = 1;\n    if (1 < *(int *)(param_1 + 0x410)) {\n      local_c = (uint *)(param_1 + 0x208);\n      do {\n        if (0 < iVar3) {\n          local_8 = local_c;\n          local_24 = local_18 - local_1c;\n          param_2 = (byte *)local_1c;\n          local_28 = local_20 - local_1c;\n          puVar5 = (uint *)(param_1 + 0x434);\n          local_14 = iVar3;\n          do {\n            local_2c = (uint)*(byte *)(param_1 + 0x455 + ((local_24 + (int)param_2) % iVar3) * 4);\n            puVar1 = local_8 + 1;\n            *puVar5 = *(uint *)(local_2c * 4 + 0x40a3fc) ^\n                      *(uint *)((*(uint *)(param_1 + 0x454 + ((local_28 + (int)param_2) % iVar3) * 4\n                                          ) & 0xff) * 4 + 0x40a7fc) ^\n                      *(uint *)((uint)*(byte *)(param_1 + 0x456 + ((int)param_2 % iVar3) * 4) * 4 +\n                               0x409ffc) ^\n                      *(uint *)((uint)*(byte *)((int)puVar5 + 0x23) * 4 + 0x409bfc) ^ *local_8;\n            puVar5 = puVar5 + 1;\n            param_2 = (byte *)((int)param_2 + 1);\n            local_14 = local_14 + -1;\n            local_8 = puVar1;\n          } while (local_14 != 0);\n        }\n        memcpy((void *)(param_1 + 0x454),(void *)(param_1 + 0x434),iVar3 << 2);\n        local_c = local_c + 8;\n        local_10 = local_10 + 1;\n      } while (local_10 < *(int *)(param_1 + 0x410));\n    }\n    local_8 = (uint *)0x0;\n    if (0 < iVar3) {\n      local_1c = local_1c - local_18;\n      local_20 = local_20 - local_18;\n      pbVar6 = param_3;\n      param_3 = (byte *)(param_1 + 0x454);\n      do {\n        uVar2 = *(undefined4 *)\n                 (param_1 + 0x1e8 + ((int)local_8 + *(int *)(param_1 + 0x410) * 8) * 4);\n        *pbVar6 = *(byte *)(*(byte *)((int)param_3 + 3) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n        pbVar6[1] = *(byte *)(*(byte *)(param_1 + 0x456 + ((local_1c + local_18) % iVar3) * 4) +\n                             0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n        pbVar6[2] = *(byte *)(*(byte *)(param_1 + 0x455 + (local_18 % iVar3) * 4) + 0x408afc) ^\n                    (byte)((uint)uVar2 >> 8);\n        param_2._0_1_ = (byte)uVar2;\n        pbVar6[3] = *(byte *)((*(uint *)(param_1 + 0x454 + ((local_20 + local_18) % iVar3) * 4) &\n                              0xff) + 0x408afc) ^ (byte)param_2;\n        pbVar6 = pbVar6 + 4;\n        local_8 = (uint *)((int)local_8 + 1);\n        local_18 = local_18 + 1;\n        param_3 = (byte *)((int)param_3 + 4);\n      } while ((int)local_8 < iVar3);\n    }\n  }\n  return;\n}\n\n",
    "000075ad": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  FUN_000074a4(param_1,param_2,3,param_3);\n  return;\n}\n\n",
    "00001fe7": "\nundefined4 [MASK](void)\n\n{\n  int *piVar1;\n  undefined1 *puVar2;\n  code *pcVar3;\n  int iVar4;\n  undefined4 *puVar5;\n  char *_Str2;\n  undefined1 local_210;\n  undefined4 local_20f;\n  undefined4 local_8;\n  \n  local_210 = uRam0040f910;\n  puVar5 = &local_20f;\n  for (iVar4 = 0x81; iVar4 != 0; iVar4 = iVar4 + -1) {\n    *puVar5 = 0;\n    puVar5 = puVar5 + 1;\n  }\n  *(undefined2 *)puVar5 = 0;\n  *(undefined1 *)((int)puVar5 + 2) = 0;\n  (*pcRam0040808c)(0,&local_210,0x208);\n  FUN_00001225(0x40f8ac);\n  piVar1 = (int *)(*pcRam0040816c)();\n  if (*piVar1 == 2) {\n    _Str2 = (char *)0x40f538;\n    piVar1 = (int *)(*pcRam00408168)();\n    iVar4 = strcmp(*(char **)(*piVar1 + 4),_Str2);\n    if ((iVar4 == 0) && (iVar4 = FUN_00001b5f(0), iVar4 != 0)) {\n      (*pcRam00408088)(&local_210,0x40f4d8,0);\n      iVar4 = (*pcRam00408068)(0x40f4d8);\n      if ((iVar4 != -1) && (iVar4 = FUN_00001f5d(), iVar4 != 0)) {\n        return 0;\n      }\n    }\n  }\n  pcVar3 = pcRam00408164;\n  iVar4 = (*pcRam00408164)(&local_210,0x5c);\n  if (iVar4 != 0) {\n    puVar2 = (undefined1 *)(*pcVar3)(&local_210,0x5c);\n    *puVar2 = 0;\n  }\n  (*pcRam004080d8)(&local_210);\n  FUN_000010fd(1);\n  FUN_00001dab(0,0x40f52c);\n  FUN_00001e9e();\n  FUN_00001064(0x40f520,0,0);\n  FUN_00001064(0x40f4fc,0,0);\n  iVar4 = FUN_0000170a();\n  if (iVar4 != 0) {\n    FUN_000012fd();\n    iVar4 = FUN_00001437(0,0,0);\n    if (iVar4 != 0) {\n      local_8 = 0;\n      iVar4 = FUN_000014a6(0x40f4f4,&local_8);\n      if (((iVar4 != 0) && (iVar4 = FUN_000021bd(iVar4,local_8), iVar4 != 0)) &&\n         (pcVar3 = (code *)FUN_00002924(iVar4,0x40f4e8), pcVar3 != (code *)0x0)) {\n        (*pcVar3)(0,0);\n      }\n    }\n    FUN_0000137a();\n  }\n  return 0;\n}\n\n",
    "000027df": "\nint [MASK](uint *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  int *piVar6;\n  uint *puVar7;\n  undefined4 uVar8;\n  int local_c;\n  \n  piVar2 = (int *)param_1;\n  iVar1 = ((int *)param_1)[1];\n  iVar3 = 1;\n  local_c = 1;\n  if (*(int *)(*param_1 + 0x84) != 0) {\n    piVar6 = (int *)(*(int *)(*param_1 + 0x80) + iVar1);\n    iVar3 = (*pcRam004080b0)(piVar6,0x14);\n    while( true ) {\n      if (iVar3 != 0) {\n        return local_c;\n      }\n      if (piVar6[3] == 0) {\n        return local_c;\n      }\n      iVar3 = (*(code *)piVar2[9])(piVar6[3] + iVar1,piVar2[0xc]);\n      if (iVar3 == 0) break;\n      iVar4 = (*pcRam00408108)(piVar2[2],piVar2[3] * 4 + 4);\n      if (iVar4 == 0) {\n        (*(code *)piVar2[0xb])(iVar3,piVar2[0xc]);\n        uVar8 = 0xe;\n        goto LAB_000028fd;\n      }\n      piVar2[2] = iVar4;\n      *(int *)(iVar4 + piVar2[3] * 4) = iVar3;\n      piVar2[3] = piVar2[3] + 1;\n      if (*piVar6 == 0) {\n        puVar7 = (uint *)(iVar1 + piVar6[4]);\n        param_1 = puVar7;\n      }\n      else {\n        puVar7 = (uint *)(piVar6[4] + iVar1);\n        param_1 = (uint *)(*piVar6 + iVar1);\n      }\n      for (; uVar5 = *param_1, uVar5 != 0; param_1 = param_1 + 1) {\n        if ((uVar5 & 0x80000000) == 0) {\n          iVar4 = piVar2[0xc];\n          uVar5 = uVar5 + iVar1 + 2;\n        }\n        else {\n          iVar4 = piVar2[0xc];\n          uVar5 = uVar5 & 0xffff;\n        }\n        uVar5 = (*(code *)piVar2[10])(iVar3,uVar5,iVar4);\n        *puVar7 = uVar5;\n        if (uVar5 == 0) {\n          local_c = 0;\n          break;\n        }\n        puVar7 = puVar7 + 1;\n      }\n      if (local_c == 0) {\n        (*(code *)piVar2[0xb])(iVar3,piVar2[0xc]);\n        (*pcRam004080a8)(0x7f);\n        return 0;\n      }\n      piVar6 = piVar6 + 5;\n      iVar3 = (*pcRam004080b0)(piVar6,0x14);\n    }\n    uVar8 = 0x7e;\nLAB_000028fd:\n    (*pcRam004080a8)(uVar8);\n    local_c = 0;\n    iVar3 = local_c;\n  }\n  return iVar3;\n}\n\n",
    "00005c9f": "\nundefined4 [MASK](void *param_1)\n\n{\n  if (param_1 == (void *)0x0) {\n    return 0xffffffff;\n  }\n  if (*(char *)((int)param_1 + 0x10) != '\\0') {\n    (*pcRam004080f0)(*(undefined4 *)((int)param_1 + 4));\n  }\n  operator_delete(param_1);\n  return 0;\n}\n\n",
    "000019e1": "\nundefined4 [MASK](int param_1,void *param_2,size_t param_3,void *param_4,size_t *param_5)\nFUN_000019e1(int param_1,void *param_2,size_t param_3,void *param_4,size_t *param_5)\n\n{\n  int iVar1;\n  \n  if (*(int *)(param_1 + 8) != 0) {\n    (*pcRam00408050)(param_1 + 0x10);\n    iVar1 = (*pcRam0040f8a4)(*(undefined4 *)(param_1 + 8),0,1,0,param_2,&param_3);\n    if (iVar1 != 0) {\n      (*pcRam0040804c)(param_1 + 0x10);\n      memcpy(param_4,param_2,param_3);\n      *param_5 = param_3;\n      return 1;\n    }\n    (*pcRam0040804c)();\n  }\n  return 0;\n}\n\n",
    "00002470": "\nundefined4 [MASK](int param_1,undefined4 param_2,int param_3,int *param_4)\n\n{\n  size_t *psVar1;\n  int iVar2;\n  size_t sVar3;\n  int iVar4;\n  size_t *psVar5;\n  int local_8;\n  \n  local_8 = 0;\n  iVar2 = param_4[1];\n  iVar4 = *param_4;\n  psVar1 = (size_t *)((uint)*(ushort *)(iVar4 + 0x14) + iVar4);\n  if (*(short *)(iVar4 + 6) != 0) {\n    do {\n      psVar5 = psVar1 + 10;\n      if (*psVar5 == 0) {\n        sVar3 = *(size_t *)(param_3 + 0x38);\n        if (0 < (int)sVar3) {\n          iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],sVar3,0x1000,4,param_4[0xc]);\n          if (iVar4 == 0) {\n            return 0;\n          }\n          psVar1[8] = iVar2 + psVar1[9];\n          memset((void *)(iVar2 + psVar1[9]),0,sVar3);\n        }\n      }\n      else {\n        iVar4 = FUN_00002457(param_2,psVar1[0xb] + *psVar5);\n        if ((iVar4 == 0) ||\n           (iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],*psVar5,0x1000,4,param_4[0xc]),\n           iVar4 == 0)) {\n          return 0;\n        }\n        sVar3 = psVar1[9];\n        memcpy((void *)(iVar2 + sVar3),(void *)(psVar1[0xb] + param_1),*psVar5);\n        psVar1[8] = iVar2 + sVar3;\n      }\n      local_8 = local_8 + 1;\n      psVar1 = psVar5;\n    } while (local_8 < (int)(uint)*(ushort *)(*param_4 + 6));\n  }\n  return 1;\n}\n\n",
    "00002a6f": "\nvoid [MASK](undefined4 *param_1)\n\n{\n  *param_1 = 0x40bc7c;\n  return;\n}\n\n",
    "00004be5": "\nundefined4 [MASK](int param_1,int param_2)\n\n{\n  FUN_000042c0(param_1,param_2,0);\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x28));\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x24));\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);\n  return 0;\n}\n\n",
    "000012fd": "\nundefined4 * [MASK](void)\n\n{\n  undefined4 *extraout_ECX;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;\n  FUN_000017dd();\n  *(undefined4 *)(unaff_EBP + -4) = 0;\n  FUN_000017dd();\n  *(undefined1 *)(unaff_EBP + -4) = 1;\n  FUN_00002a46();\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  extraout_ECX[0x132] = 0;\n  extraout_ECX[0x133] = 0;\n  extraout_ECX[0x134] = 0;\n  extraout_ECX[0x135] = 0;\n  *extraout_ECX = 0x4081d8;\n  return extraout_ECX;\n}\n\n",
    "000076e8": "\nvoid [MASK](void *param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000076e8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408140)();\n  return;\n}\n\n",
    "000074a4": "\nundefined4 * [MASK](void)\n\n{\n  void *pvVar1;\n  undefined4 *puVar2;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  pvVar1 = operator_new(0x244);\n  *(void **)(unaff_EBP + -0x10) = pvVar1;\n  *(undefined4 *)(unaff_EBP + -4) = 0;\n  if (pvVar1 == (void *)0x0) {\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    pvVar1 = (void *)FUN_00007527(*(undefined4 *)(unaff_EBP + 0x14));\n  }\n  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;\n  iRam0040f938 = FUN_00006b8e(*(undefined4 *)(unaff_EBP + 8),*(undefined4 *)(unaff_EBP + 0xc),\n                              *(undefined4 *)(unaff_EBP + 0x10));\n  if (iRam0040f938 == 0) {\n    puVar2 = (undefined4 *)operator_new(8);\n    *puVar2 = 1;\n    puVar2[1] = pvVar1;\n  }\n  else {\n    if (pvVar1 != (void *)0x0) {\n      FUN_00007572();\n      operator_delete(pvVar1);\n    }\n    puVar2 = (undefined4 *)0x0;\n  }\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  return puVar2;\n}\n\n",
    "000055a3": "\nbyte [MASK](undefined4 param_1,byte param_2)\n\n{\n  byte bVar1;\n  \n  bVar1 = FUN_00005588(param_1);\n  FUN_00005535(param_1,param_2 ^ bVar1);\n  return param_2 ^ bVar1;\n}\n\n",
    "00002758": "\nbool [MASK](int *param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  int *piVar4;\n  ushort *puVar5;\n  bool bVar6;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0xa4) == 0) {\n    bVar6 = param_2 == 0;\n  }\n  else {\n    piVar3 = (int *)(*(int *)(*param_1 + 0xa0) + iVar1);\n    iVar2 = *piVar3;\n    while (iVar2 != 0) {\n      param_1 = (int *)0x0;\n      puVar5 = (ushort *)(piVar3 + 2);\n      if ((piVar3[1] - 8U & 0xfffffffe) != 0) {\n        do {\n          if ((*puVar5 & 0xf000) == 0x3000) {\n            piVar4 = (int *)((*puVar5 & 0xfff) + iVar2 + iVar1);\n            *piVar4 = *piVar4 + param_2;\n          }\n          param_1 = (int *)((int)param_1 + 1);\n          puVar5 = puVar5 + 1;\n        } while (param_1 < piVar3[1] - 8U >> 1);\n      }\n      piVar3 = (int *)((int)piVar3 + piVar3[1]);\n      iVar2 = *piVar3;\n    }\n    bVar6 = true;\n  }\n  return bVar6;\n}\n\n",
    "000064e2": "\nint [MASK](int param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 == 0) {\n    iVar1 = -0x66;\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(param_1 + 0x24);\n    *(undefined4 *)(param_1 + 0x10) = 0;\n    iVar1 = FUN_000061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);\n    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);\n  }\n  return iVar1;\n}\n\n",
    "0000747b": "\nundefined4 [MASK](int *param_1)\n\n{\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  param_1[1] = -1;\n  if (*param_1 != 0) {\n    FUN_00006162(*param_1);\n  }\n  *param_1 = 0;\n  return 0;\n}\n\n",
    "0000799c": "\nvoid [MASK](void)\n\n{\n  int unaff_EBP;\n  \n  operator_delete(*(void **)(unaff_EBP + -0x10));\n  return;\n}\n\n",
    "00001e9e": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  undefined1 local_31c [178];\n  char local_26a [602];\n  undefined4 local_10 [3];\n  \n  local_10[0] = 0x40f488;\n  local_10[1] = 0x40f464;\n  local_10[2] = 0x40f440;\n  iVar1 = FUN_00001000(local_31c,1);\n  if (iVar1 != 0) {\n    iVar1 = (*pcRam00408120)();\n    strcpy(local_26a,(char *)local_10[iVar1 % 3]);\n    FUN_00001000(local_31c,0);\n  }\n  return;\n}\n\n",
    "00005588": "\nuint [MASK](int param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)(param_1 + 8) & 0xfffd | 2;\n  return (uVar1 ^ 1) * uVar1 >> 8 & 0xff;\n}\n\n",
    "00007527": "\nundefined4 * [MASK](undefined4 *param_1,char *param_2)\n\n{\n  size_t sVar1;\n  char *_Dest;\n  \n  param_1[1] = 0xffffffff;\n  param_1[0x4d] = 0xffffffff;\n  *param_1 = 0;\n  param_1[0x4e] = 0;\n  param_1[0x4f] = 0;\n  if (param_2 != (char *)0x0) {\n    sVar1 = strlen(param_2);\n    _Dest = (char *)operator_new(sVar1 + 1);\n    param_1[0x4e] = _Dest;\n    strcpy(_Dest,param_2);\n  }\n  return param_1;\n}\n\n",
    "0000137a": "\nvoid [MASK](void)\n\n{\n  undefined4 *extraout_ECX;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;\n  *extraout_ECX = 0x4081d8;\n  *(undefined4 *)(unaff_EBP + -4) = 2;\n  FUN_000013ce();\n  *(undefined1 *)(unaff_EBP + -4) = 1;\n  FUN_00002a6f();\n  *(undefined1 *)(unaff_EBP + -4) = 0;\n  FUN_0000181b();\n  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;\n  FUN_0000181b();\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  return;\n}\n\n",
    "00007924": "\nvoid [MASK](void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00007924. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam004081b0)();\n  return;\n}\n\n",
    "000076ee": "\nint [MASK](void *_Buf1,void *_Buf2,size_t _Size)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076ee. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = (*pcRam00408144)();\n  return iVar1;\n}\n\n",
    "00005e6b": "\nvoid [MASK](int param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  \n  iVar3 = param_1;\n  iVar2 = FUN_00005def(param_1,&param_1);\n  iVar1 = param_1;\n  if (iVar2 == 0) {\n    iVar2 = FUN_00005def(iVar3,&param_1);\n  }\n  iVar4 = param_1 * 0x100;\n  if (iVar2 == 0) {\n    iVar2 = FUN_00005def(iVar3,&param_1);\n  }\n  iVar5 = param_1 * 0x10000;\n  if ((iVar2 == 0) && (iVar3 = FUN_00005def(iVar3,&param_1), iVar3 == 0)) {\n    *param_2 = param_1 * 0x1000000 + iVar1 + iVar4 + iVar5;\n    return;\n  }\n  *param_2 = 0;\n  return;\n}\n\n",
    "00007136": "\nint [MASK](int *param_1,char *param_2,char *param_3,int param_4,int param_5)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char cVar3;\n  char *pcVar4;\n  void *pvVar5;\n  int iVar6;\n  int iVar7;\n  char *pcVar8;\n  char *pcVar9;\n  undefined1 local_33c [260];\n  undefined1 local_238 [264];\n  uint local_130;\n  undefined1 local_12c [8];\n  undefined1 local_124 [8];\n  undefined1 local_11c [16];\n  char local_10c [260];\n  undefined1 local_8 [4];\n  \n  iVar7 = param_5;\n  iVar6 = (int)param_2;\n  if (param_5 == 3) {\n    if (param_2 != (char *)param_1[1]) {\n      if (param_1[1] != -1) {\n        FUN_00006a97(*param_1);\n      }\n      iVar7 = *param_1;\n      param_1[1] = -1;\n      if (*(int *)(iVar7 + 4) <= iVar6) {\n        return 0x10000;\n      }\n      if (iVar6 < *(int *)(iVar7 + 0x10)) {\n        FUN_000064e2(iVar7);\n      }\n      while (*(int *)(*param_1 + 0x10) < iVar6) {\n        FUN_00006520(*param_1);\n      }\n      FUN_0000671d(*param_1,param_1[0x4e]);\n      param_1[1] = iVar6;\n    }\n    iVar6 = FUN_00006880(*param_1,param_3,param_4,(int)&param_2 + 3);\n    if (iVar6 < 1) {\n      FUN_00006a97(*param_1);\n      param_1[1] = -1;\n    }\n    if (param_2._3_1_ != '\\0') {\n      return 0;\n    }\n    if (iVar6 < 1) {\n      return ((iVar6 != -0x6a) - 1 & 0xfb001000) + 0x5000000;\n    }\n    return 0x600;\n  }\n  if ((param_5 != 2) && (param_5 != 1)) {\n    return 0x10000;\n  }\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  iVar2 = (int)param_2;\n  iVar6 = *param_1;\n  param_1[1] = -1;\n  if (*(int *)(iVar6 + 4) <= (int)param_2) {\n    return 0x10000;\n  }\n  if ((int)param_2 < *(int *)(iVar6 + 0x10)) {\n    FUN_000064e2(iVar6);\n  }\n  while (*(int *)(*param_1 + 0x10) < iVar2) {\n    FUN_00006520(*param_1);\n  }\n  FUN_00006c40(iVar2,local_238);\n  pcVar4 = param_3;\n  if ((local_130 & 0x10) != 0) {\n    if (iVar7 == 1) {\n      return 0;\n    }\n    cVar3 = *param_3;\n    if (((cVar3 == '/') || (cVar3 == '\\\\')) || ((cVar3 != '\\0' && (param_3[1] == ':')))) {\n      param_1 = (int *)0x0;\n    }\n    else {\n      param_1 = param_1 + 0x50;\n    }\n    FUN_00007070(param_1,param_3);\n    return 0;\n  }\n  if (iVar7 == 1) goto LAB_00007331;\n  cVar3 = *param_3;\n  pcVar8 = param_3;\n  pcVar9 = param_3;\n  while (cVar3 != '\\0') {\n    if ((cVar3 == '/') || (cVar3 == '\\\\')) {\n      pcVar9 = pcVar8 + 1;\n    }\n    pcVar1 = pcVar8 + 1;\n    pcVar8 = pcVar8 + 1;\n    cVar3 = *pcVar1;\n  }\n  strcpy(local_10c,param_3);\n  if (pcVar9 == pcVar4) {\n    local_10c[0] = '\\0';\nLAB_000072e1:\n    (*pcRam004081d0)(local_33c,0x40f848,param_1 + 0x50,local_10c,pcVar9);\n    FUN_00007070(param_1 + 0x50,local_10c);\n  }\n  else {\n    pcVar9[(int)(local_10c + -(int)pcVar4)] = '\\0';\n    if (((local_10c[0] != '/') && (local_10c[0] != '\\\\')) &&\n       ((local_10c[0] == '\\0' || (local_10c[1] != ':')))) goto LAB_000072e1;\n    (*pcRam004081d0)(local_33c,0x40f840,local_10c,pcVar9);\n    FUN_00007070(0,local_10c);\n  }\n  pcVar4 = (char *)(*pcRam00408034)(local_33c,0x40000000,0,0,2,local_130,0);\nLAB_00007331:\n  if (pcVar4 == (char *)0xffffffff) {\n    return 0x200;\n  }\n  param_2 = pcVar4;\n  FUN_0000671d(*param_1,param_1[0x4e]);\n  if (param_1[0x4f] == 0) {\n    pvVar5 = operator_new(0x4000);\n    param_1[0x4f] = (int)pvVar5;\n  }\n  param_4 = 0;\n  do {\n    iVar6 = FUN_00006880(*param_1,param_1[0x4f],0x4000,(int)&param_3 + 3);\n    if (iVar6 == -0x6a) {\n      param_4 = 0x1000;\n      goto LAB_0000745a;\n    }\n    if (iVar6 < 0) break;\n    if ((0 < iVar6) && (iVar7 = (*pcRam00408048)(param_2,param_1[0x4f],iVar6,local_8,0), iVar7 == 0)\n       ) {\n      param_4 = 0x400;\n      goto LAB_0000745a;\n    }\n    if (param_3._3_1_ != '\\0') {\n      (*pcRam004080cc)(param_2,local_124,local_12c,local_11c);\n      goto LAB_0000745a;\n    }\n  } while (iVar6 != 0);\n  param_4 = 0x5000000;\nLAB_0000745a:\n  if (param_5 != 1) {\n    (*pcRam004080f0)(param_2);\n  }\n  FUN_00006a97(*param_1);\n  return param_4;\n}\n\n",
    "00005def": "\nint [MASK](undefined4 param_1,uint *param_2)\n\n{\n  int iVar1;\n  undefined4 uStack_8;\n  \n  iVar1 = FUN_00005d8a((int)&uStack_8 + 3,1,1,param_1);\n  if (iVar1 == 1) {\n    *param_2 = uStack_8 >> 0x18;\n    return 0;\n  }\n  iVar1 = FUN_00005cc7(param_1);\n  return -(uint)(iVar1 != 0);\n}\n\n",
    "0000763d": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  FUN_00007603(param_1,param_2,param_3,0,2);\n  return;\n}\n\n",
    "00005bae": "\nundefined1 * [MASK](int param_1,undefined4 param_2,int param_3,undefined4 *param_4)\n\n{\n  undefined1 uVar1;\n  int iVar2;\n  int iVar3;\n  undefined1 *puVar4;\n  undefined4 uVar5;\n  bool local_6;\n  undefined1 local_5;\n  \n  if (((param_3 != 1) && (param_3 != 2)) && (param_3 != 3)) {\n    *param_4 = 0x10000;\n    return (undefined1 *)0x0;\n  }\n  *param_4 = 0;\n  local_6 = false;\n  local_5 = 0;\n  iVar2 = param_1;\n  uVar1 = 0;\n  if (param_3 != 1) {\n    iVar2 = 0;\n    if (param_3 != 2) goto LAB_00005c36;\n    iVar2 = (*pcRam00408034)(param_1,0x80000000,1,0,3,0x80,0);\n    if (iVar2 == -1) {\n      *param_4 = 0x200;\n      return (undefined1 *)0x0;\n    }\n    local_5 = 1;\n    uVar1 = local_5;\n  }\n  local_5 = uVar1;\n  iVar3 = (*pcRam004080c8)(iVar2,0,0,1);\n  local_6 = iVar3 != -1;\nLAB_00005c36:\n  puVar4 = (undefined1 *)operator_new(0x20);\n  if ((param_3 == 1) || (param_3 == 2)) {\n    *puVar4 = 1;\n    puVar4[0x10] = local_5;\n    puVar4[1] = local_6;\n    *(int *)(puVar4 + 4) = iVar2;\n    puVar4[8] = 0;\n    *(undefined4 *)(puVar4 + 0xc) = 0;\n    if (local_6 != false) {\n      uVar5 = (*pcRam004080c8)(iVar2,0,0,1);\n      *(undefined4 *)(puVar4 + 0xc) = uVar5;\n    }\n  }\n  else {\n    *puVar4 = 0;\n    *(int *)(puVar4 + 0x14) = param_1;\n    puVar4[1] = 1;\n    puVar4[0x10] = 0;\n    *(undefined4 *)(puVar4 + 0x18) = param_2;\n    *(undefined4 *)(puVar4 + 0x1c) = 0;\n    *(undefined4 *)(puVar4 + 0xc) = 0;\n  }\n  *param_4 = 0;\n  return puVar4;\n}\n\n",
    "00001dab": "\nundefined4 [MASK](undefined4 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int iVar4;\n  char *pcVar5;\n  int iVar6;\n  int local_130;\n  char local_12c [296];\n  \n  iVar1 = (*pcRam00408100)(param_1,0x80a,0x40f43c);\n  if (((iVar1 != 0) && (iVar2 = (*pcRam00408074)(param_1,iVar1), iVar2 != 0)) &&\n     (iVar2 = (*pcRam00408070)(iVar2), iVar2 != 0)) {\n    uVar3 = (*pcRam0040806c)(param_1,iVar1,param_2);\n    iVar1 = FUN_000075ad(iVar2,uVar3);\n    if (iVar1 != 0) {\n      local_130 = 0;\n      pcVar5 = local_12c;\n      for (iVar2 = 0x4a; iVar2 != 0; iVar2 = iVar2 + -1) {\n        pcVar5[0] = '\\0';\n        pcVar5[1] = '\\0';\n        pcVar5[2] = '\\0';\n        pcVar5[3] = '\\0';\n        pcVar5 = pcVar5 + 4;\n      }\n      FUN_000075c4(iVar1,0xffffffff,&local_130);\n      iVar2 = local_130;\n      iVar6 = 0;\n      if (0 < local_130) {\n        do {\n          FUN_000075c4(iVar1,iVar6,&local_130);\n          iVar4 = strcmp(local_12c,(char *)0x40e010);\n          if ((iVar4 != 0) || (iVar4 = (*pcRam00408068)(local_12c), iVar4 == -1)) {\n            FUN_0000763d(iVar1,iVar6,local_12c);\n          }\n          iVar6 = iVar6 + 1;\n        } while (iVar6 < iVar2);\n      }\n      FUN_00007656(iVar1);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
    "00006162": "\nundefined4 [MASK](undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    return 0xffffff9a;\n  }\n  if (param_1[0x1f] != 0) {\n    FUN_00006a97(param_1);\n  }\n  FUN_00005c9f(*param_1);\n  (*pcRam00408174)(param_1);\n  return 0;\n}\n\n",
    "0000181b": "\nvoid [MASK](undefined4 *param_1)\n\n{\n  *param_1 = 0x4081ec;\n  (*pcRam0040803c)(param_1 + 4);\n  return;\n}\n\n",
    "00001437": "\nundefined4 [MASK](int param_1,int param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 unaff_EBX;\n  undefined4 unaff_ESI;\n  \n  iVar2 = FUN_00001861(param_2);\n  if (iVar2 != 0) {\n    if (param_2 != 0) {\n      FUN_00001861(0);\n    }\n    pcVar1 = pcRam004080dc;\n    iVar2 = (*pcRam004080dc)(0,0x100000);\n    *(int *)(param_1 + 0x4c8) = iVar2;\n    if (iVar2 != 0) {\n      iVar2 = (*pcVar1)(0,0x100000);\n      *(int *)(param_1 + 0x4cc) = iVar2;\n      if (iVar2 != 0) {\n        *(undefined4 *)(param_1 + 0x4d4) = unaff_ESI;\n        *(undefined4 *)(param_1 + 0x4d0) = unaff_EBX;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
    "00002924": "\nint [MASK](int *param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  ushort *puVar4;\n  int iVar5;\n  int *piVar6;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0x7c) != 0) {\n    iVar5 = *(int *)(*param_1 + 0x78);\n    iVar3 = *(int *)(iVar5 + 0x18 + iVar1);\n    iVar5 = iVar5 + iVar1;\n    if ((iVar3 != 0) && (*(int *)(iVar5 + 0x14) != 0)) {\n      if ((short)(param_2 >> 0x10) == 0) {\n        if (*(uint *)(iVar5 + 0x10) <= (param_2 & 0xffff)) {\n          uVar2 = (param_2 & 0xffff) - *(uint *)(iVar5 + 0x10);\nLAB_000029ba:\n          if (uVar2 <= *(uint *)(iVar5 + 0x14)) {\n            return *(int *)(*(int *)(iVar5 + 0x1c) + uVar2 * 4 + iVar1) + iVar1;\n          }\n        }\n      }\n      else {\n        piVar6 = (int *)(*(int *)(iVar5 + 0x20) + iVar1);\n        puVar4 = (ushort *)(*(int *)(iVar5 + 0x24) + iVar1);\n        param_1 = (int *)0x0;\n        if (iVar3 != 0) {\n          do {\n            iVar3 = (*pcRam00408170)(param_2,*piVar6 + iVar1);\n            if (iVar3 == 0) {\n              uVar2 = (uint)*puVar4;\n              goto LAB_000029ba;\n            }\n            param_1 = (int *)((int)param_1 + 1);\n            piVar6 = piVar6 + 1;\n            puVar4 = puVar4 + 1;\n          } while (param_1 < *(uint *)(iVar5 + 0x18));\n        }\n      }\n    }\n  }\n  (*pcRam004080a8)(0x7f);\n  return 0;\n}\n\n",
    "00005cdd": "\nint [MASK](char *param_1)\n\n{\n  int iVar1;\n  \n  if (*param_1 != '\\0') {\n    if (param_1[1] != '\\0') {\n      iVar1 = (*pcRam004080c8)(*(undefined4 *)(param_1 + 4),0,0,1);\n      return iVar1 - *(int *)(param_1 + 0xc);\n    }\n    if (*param_1 != '\\0') {\n      return 0;\n    }\n  }\n  return *(int *)(param_1 + 0x1c);\n}\n\n",
    "0000776e": "\nvoid [MASK](void *pExceptionObject,ThrowInfo *pThrowInfo)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x0000776e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408188)();\n  return;\n}\n\n",
    "000021bd": "\nvoid [MASK](undefined4 param_1,undefined4 param_2)\n\n{\n  FUN_000021e9(param_1,param_2,0x40216e,0x402185,0x402198,0x4021a3,0x4021b2,0);\n  return;\n}\n\n",
    "00002e7e": "\nvoid [MASK](int param_1,uint *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined1 local_2c [12];\n  int local_20;\n  uint local_18;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  int local_8;\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    local_14 = ((uint)*(byte *)param_2 << 0x18 | (uint)*(byte *)((int)param_2 + 1) << 0x10 |\n                (uint)*(byte *)((int)param_2 + 2) << 8 | (uint)*(byte *)((int)param_2 + 3)) ^\n               *(uint *)(param_1 + 8);\n    local_10 = ((uint)*(byte *)((int)param_2 + 4) << 0x18 |\n                (uint)*(byte *)((int)param_2 + 5) << 0x10 | (uint)*(byte *)((int)param_2 + 6) << 8 |\n               (uint)*(byte *)((int)param_2 + 7)) ^ *(uint *)(param_1 + 0xc);\n    uVar4 = ((uint)*(byte *)((int)param_2 + 8) << 0x18 | (uint)*(byte *)((int)param_2 + 9) << 0x10 |\n             (uint)*(byte *)((int)param_2 + 10) << 8 | (uint)*(byte *)((int)param_2 + 0xb)) ^\n            *(uint *)(param_1 + 0x10);\n    iVar1 = *(int *)(param_1 + 0x410);\n    local_c = ((uint)CONCAT11(*(byte *)((int)param_2 + 0xe),*(byte *)((int)param_2 + 0xf)) |\n              (uint)*(byte *)((int)param_2 + 0xc) << 0x18 |\n              (uint)*(byte *)((int)param_2 + 0xd) << 0x10) ^ *(uint *)(param_1 + 0x14);\n    if (1 < iVar1) {\n      local_8 = iVar1 + -1;\n      param_2 = (uint *)(param_1 + 0x30);\n      local_18 = uVar4;\n      do {\n        uVar5 = *(uint *)((local_c >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_18 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_10 >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_14 & 0xff) * 4 + 0x4097fc) ^ param_2[-1];\n        uVar4 = *(uint *)((local_c >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_18 >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_14 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_10 & 0xff) * 4 + 0x4097fc) ^ *param_2;\n        uVar3 = *(uint *)((local_c >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_10 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_14 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_18 & 0xff) * 4 + 0x4097fc) ^ param_2[1];\n        local_14 = *(uint *)((local_18 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                   *(uint *)((local_10 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                   *(uint *)((local_14 >> 0x18) * 4 + 0x408bfc) ^\n                   *(uint *)((local_c & 0xff) * 4 + 0x4097fc) ^ param_2[-2];\n        local_8 = local_8 + -1;\n        param_2 = param_2 + 8;\n        local_18 = uVar4;\n        local_10 = uVar5;\n        local_c = uVar3;\n      } while (local_8 != 0);\n    }\n    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 8 + param_1);\n    param_1 = iVar1 * 0x20 + 8 + param_1;\n    *param_3 = *(byte *)((local_14 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[1] = *(byte *)((local_10 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[2] = *(byte *)((uVar4 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[3] = *(byte *)((local_c & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 4);\n    param_3[4] = *(byte *)((local_10 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[5] = *(byte *)((uVar4 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[6] = *(byte *)((local_c >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[7] = *(byte *)((local_14 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 8);\n    param_3[8] = *(byte *)((uVar4 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[9] = *(byte *)((local_c >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[10] = *(byte *)((local_14 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xb] = *(byte *)((local_10 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 0xc);\n    param_3[0xc] = *(byte *)((local_c >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[0xd] = *(byte *)((local_14 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[0xe] = *(byte *)((local_10 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xf] = *(byte *)((uVar4 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    return;\n  }\n  local_20 = param_1;\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_2c,(ThrowInfo *)0x40d570);\n}\n\n",
    "00007656": "\nundefined4 [MASK](int *param_1)\n\n{\n  void *pvVar1;\n  \n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else {\n    if (*param_1 == 1) {\n      pvVar1 = (void *)param_1[1];\n      uRam0040f938 = FUN_0000747b();\n      if (pvVar1 != (void *)0x0) {\n        FUN_00007572();\n        operator_delete(pvVar1);\n      }\n      operator_delete(param_1);\n      return uRam0040f938;\n    }\n    uRam0040f938 = 0x80000;\n  }\n  return uRam0040f938;\n}\n\n",
    "00003cc8": "\nvoid [MASK](undefined1 param_1,undefined1 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)(**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),1,0x1c);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    *(undefined1 *)(puVar1 + 4) = param_1;\n    *(undefined1 *)((int)puVar1 + 0x11) = param_2;\n    puVar1[5] = param_3;\n    puVar1[6] = param_4;\n  }\n  return;\n}\n\n",
    "0000170a": "\nundefined4 [MASK](void)\n\n{\n  code *pcVar1;\n  int iVar2;\n  \n  iVar2 = FUN_00001a45();\n  if (iVar2 != 0) {\n    if (iRam0040f878 != 0) {\n      return 1;\n    }\n    iVar2 = (*pcRam004080e0)(0x40ebe8);\n    pcVar1 = pcRam004080e4;\n    if (iVar2 != 0) {\n      iRam0040f878 = (*pcRam004080e4)(iVar2,0x40ebdc);\n      iRam0040f87c = (*pcVar1)(iVar2,0x40ebd0);\n      iRam0040f880 = (*pcVar1)(iVar2,0x40ebc4);\n      iRam0040f884 = (*pcVar1)(iVar2,0x40ebb8);\n      iRam0040f888 = (*pcVar1)(iVar2,0x40ebac);\n      iRam0040f88c = (*pcVar1)(iVar2,0x40eba0);\n      iRam0040f890 = (*pcVar1)(iVar2,0x40eb94);\n      if ((((iRam0040f878 != 0) && (iRam0040f87c != 0)) && (iRam0040f880 != 0)) &&\n         (((iRam0040f884 != 0 && (iRam0040f888 != 0)) &&\n          ((iRam0040f88c != 0 && (iRam0040f890 != 0)))))) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
    "000076fa": "\nvoid [MASK](void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000076fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam0040814c)();\n  return;\n}\n\n",
    "00007780": "\n/* Library Function - Single Match\n    __allmul\n   \n   Library: Visual Studio */\n\nlonglong [MASK](uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if (param_4 == 0 && param_2 == 0) {\n    return (ulonglong)param_1 * (ulonglong)param_3;\n  }\n  return CONCAT44((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +\n                  param_2 * param_3 + param_1 * param_4,\n                  (int)((ulonglong)param_1 * (ulonglong)param_3));\n}\n\n",
    "00007940": "\nuint [MASK](uint _NewValue,uint _Mask)\n\n{\n  uint uVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007940. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  uVar1 = (*pcRam004081c8)();\n  return uVar1;\n}\n\n",
    "00005122": "\nundefined4\n[MASK](undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined4 *param_4)\n\n{\n  *param_1 = 9;\n  *param_2 = 5;\n  *param_3 = 0x40bcf0;\n  *param_4 = 0x40ccf0;\n  return 0;\n}\n\n",
    "000055c4": "\nuint [MASK](uint param_1,byte *param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  int iVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  int iVar18;\n  \n  uVar3 = param_1 & 0xffff;\n  param_1 = param_1 >> 0x10;\n  if (param_2 == (byte *)0x0) {\n    uVar3 = 1;\n  }\n  else {\n    if (param_3 != 0) {\n      do {\n        uVar2 = 0x15b0;\n        if (param_3 < 0x15b0) {\n          uVar2 = param_3;\n        }\n        param_3 = param_3 - uVar2;\n        if (0xf < (int)uVar2) {\n          uVar1 = uVar2 >> 4;\n          uVar2 = uVar2 + uVar1 * -0x10;\n          do {\n            iVar4 = uVar3 + *param_2;\n            iVar5 = iVar4 + (uint)param_2[1];\n            iVar6 = iVar5 + (uint)param_2[2];\n            iVar7 = iVar6 + (uint)param_2[3];\n            iVar8 = iVar7 + (uint)param_2[4];\n            iVar9 = iVar8 + (uint)param_2[5];\n            iVar10 = iVar9 + (uint)param_2[6];\n            iVar11 = iVar10 + (uint)param_2[7];\n            iVar12 = iVar11 + (uint)param_2[8];\n            iVar13 = iVar12 + (uint)param_2[9];\n            iVar14 = iVar13 + (uint)param_2[10];\n            iVar15 = iVar14 + (uint)param_2[0xb];\n            iVar16 = iVar15 + (uint)param_2[0xc];\n            iVar17 = iVar16 + (uint)param_2[0xd];\n            iVar18 = iVar17 + (uint)param_2[0xe];\n            uVar3 = iVar18 + (uint)param_2[0xf];\n            param_1 = param_1 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 +\n                      iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;\n            param_2 = param_2 + 0x10;\n            uVar1 = uVar1 - 1;\n          } while (uVar1 != 0);\n        }\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n          uVar3 = uVar3 + *param_2;\n          param_2 = param_2 + 1;\n          param_1 = param_1 + uVar3;\n        }\n        uVar3 = uVar3 % 0xfff1;\n        param_1 = param_1 % 0xfff1;\n      } while (param_3 != 0);\n    }\n    uVar3 = param_1 << 0x10 | uVar3;\n  }\n  return uVar3;\n}\n\n",
    "00001a45": "\nundefined4 [MASK](void)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 uVar3;\n  \n  if (iRam0040f894 == 0) {\n    iVar2 = (*pcRam004080e0)(0x40e020);\n    pcVar1 = pcRam004080e4;\n    if (iVar2 != 0) {\n      iRam0040f894 = (*pcRam004080e4)(iVar2,0x40f110);\n      iRam0040f898 = (*pcVar1)(iVar2,0x40f100);\n      iRam0040f89c = (*pcVar1)(iVar2,0x40f0f0);\n      iRam0040f8a0 = (*pcVar1)(iVar2,0x40f0e0);\n      iRam0040f8a4 = (*pcVar1)(iVar2,0x40f0d0);\n      iRam0040f8a8 = (*pcVar1)(iVar2,0x40f0c4);\n      if ((((iRam0040f894 != 0) && (iRam0040f898 != 0)) && (iRam0040f89c != 0)) &&\n         (((iRam0040f8a0 != 0 && (iRam0040f8a4 != 0)) && (iRam0040f8a8 != 0)))) goto LAB_00001aec;\n    }\n    uVar3 = 0;\n  }\n  else {\nLAB_00001aec:\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n",
    "000043b6": "\nvoid [MASK](uint *param_1,int *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  \n  uVar1 = param_1[0xd];\n  iVar2 = param_2[1];\n  iVar3 = *param_2;\n  if (*param_1 < 10) {\n                    /* WARNING: Could not emulate address calculation at 0x00004408 */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(*param_1 * 4 + 0x404bbd))();\n    return;\n  }\n  param_1[8] = param_1[8];\n  param_1[7] = param_1[7];\n  param_2[1] = iVar2;\n  iVar2 = *param_2;\n  *param_2 = iVar3;\n  param_2[2] = param_2[2] + (iVar3 - iVar2);\n  param_1[0xd] = uVar1;\n  FUN_00003bd6(param_1,param_2,0xfffffffe);\n  return;\n}\n\n",
    "0000792a": "\nvoid [MASK](void)\n\n{\n  _controlfp(0x10000,0x30000);\n  return;\n}\n\n",
    "0000671d": "\nundefined4 [MASK](int *param_1,char *param_2)\n\n{\n  int *piVar1;\n  undefined1 uVar2;\n  int iVar3;\n  int *piVar4;\n  undefined4 uVar5;\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  piVar1 = param_1;\n  if ((param_1 == (int *)0x0) || (param_1[6] == 0)) {\n    uVar5 = 0xffffff9a;\n  }\n  else {\n    if (param_1[0x1f] != 0) {\n      FUN_00006a97(param_1);\n    }\n    iVar3 = FUN_0000657a(param_1,&local_10,&local_8,&local_c);\n    if (iVar3 == 0) {\n      piVar4 = (int *)(*pcRam00408178)(0x84);\n      if (piVar4 != (int *)0x0) {\n        iVar3 = (*pcRam00408178)(0x4000);\n        *piVar4 = iVar3;\n        piVar4[0x11] = local_8;\n        piVar4[0x12] = local_c;\n        piVar4[0x13] = 0;\n        if (iVar3 != 0) {\n          piVar4[0x10] = 0;\n          iVar3 = param_1[0xd];\n          piVar4[0x15] = param_1[0xf];\n          piVar4[0x14] = 0;\n          piVar4[0x19] = param_1[0xd];\n          piVar4[0x18] = *param_1;\n          piVar4[0x1a] = param_1[3];\n          piVar4[6] = 0;\n          if (iVar3 != 0) {\n            piVar4[9] = 0;\n            piVar4[10] = 0;\n            piVar4[0xb] = 0;\n            iVar3 = FUN_00005777(piVar4 + 1);\n            if (iVar3 == 0) {\n              piVar4[0x10] = 1;\n            }\n          }\n          piVar4[0x16] = param_1[0x10];\n          piVar4[0x17] = param_1[0x11];\n          *(byte *)(piVar4 + 0x1b) = *(byte *)(param_1 + 0xc) & 1;\n          if (((uint)param_1[0xc] >> 3 & 1) == 0) {\n            uVar2 = (undefined1)((uint)param_1[0xf] >> 0x18);\n          }\n          else {\n            uVar2 = (undefined1)((uint)param_1[0xe] >> 8);\n          }\n          *(undefined1 *)(piVar4 + 0x20) = uVar2;\n          piVar4[0x1d] = 0x23456789;\n          piVar4[0x1f] = -(uint)((char)piVar4[0x1b] != '\\0') & 0xc;\n          piVar4[0x1c] = 0x12345678;\n          piVar4[0x1e] = 0x34567890;\n          param_1 = (int *)param_2;\n          if (param_2 != (char *)0x0) {\n            do {\n              if (*(char *)param_1 == '\\0') break;\n              FUN_00005535(piVar4 + 0x1c,CONCAT31((int3)((uint)param_1 >> 8),*(char *)param_1));\n              param_1 = (int *)((int)param_1 + 1);\n            } while (param_1 != (int *)0x0);\n          }\n          iVar3 = piVar1[0x1e];\n          piVar4[2] = 0;\n          piVar4[0xf] = iVar3 + 0x1e + local_10;\n          piVar1[0x1f] = (int)piVar4;\n          return 0;\n        }\n        (*pcRam00408174)(piVar4);\n      }\n      uVar5 = 0xffffff98;\n    }\n    else {\n      uVar5 = 0xffffff99;\n    }\n  }\n  return uVar5;\n}\n\n",
    "0000182c": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  do {\n    iVar1 = (*pcRam0040f894)(param_1 + 4,0,-(uint)(iVar2 != 0) & 0x40f08c,0x18,0xf0000000);\n    if (iVar1 != 0) {\n      return 1;\n    }\n    iVar2 = iVar2 + 1;\n  } while (iVar2 < 2);\n  return 0;\n}\n\n",
    "00006b02": "\nvoid [MASK](uint param_1)\n\n{\n  __allmul(param_1 + 0xb6109100,((int)param_1 >> 0x1f) + 2 + (uint)(0x49ef6eff < param_1),10000000,0\n          );\n  return;\n}\n\n",
    "00003a77": "\nvoid [MASK](int param_1,void *param_2,int param_3,uint param_4,uint param_5)\n\n{\n  uint uVar1;\n  bool bVar2;\n  undefined1 local_10 [12];\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n  }\n  if (param_4 != 0) {\n    uVar1 = *(uint *)(param_1 + 0x3cc);\n    if ((int)((ulonglong)param_4 % (ulonglong)uVar1) == 0) {\n      if (param_5 == 1) {\n        param_5 = 0;\n        if ((int)(((ulonglong)param_4 % (ulonglong)uVar1 << 0x20 | (ulonglong)param_4) /\n                 (ulonglong)uVar1) != 0) {\n          do {\n            FUN_00003797(param_2,param_3);\n            FUN_00003a28(param_3,param_1 + 0x3f0);\n            memcpy((void *)(param_1 + 0x3f0),param_2,*(size_t *)(param_1 + 0x3cc));\n            uVar1 = *(uint *)(param_1 + 0x3cc);\n            param_2 = (void *)((int)param_2 + uVar1);\n            param_3 = param_3 + uVar1;\n            param_5 = param_5 + 1;\n          } while (param_5 < param_4 / uVar1);\n        }\n      }\n      else {\n        bVar2 = param_5 == 2;\n        param_5 = 0;\n        if (bVar2) {\n          if (param_4 / uVar1 != 0) {\n            do {\n              FUN_0000350f(param_1 + 0x3f0,param_3);\n              FUN_00003a28(param_3,param_2);\n              memcpy((void *)(param_1 + 0x3f0),param_2,*(size_t *)(param_1 + 0x3cc));\n              uVar1 = *(uint *)(param_1 + 0x3cc);\n              param_2 = (void *)((int)param_2 + uVar1);\n              param_3 = param_3 + uVar1;\n              param_5 = param_5 + 1;\n            } while (param_5 < param_4 / uVar1);\n          }\n        }\n        else if (param_4 / uVar1 != 0) {\n          do {\n            FUN_00003797(param_2,param_3);\n            uVar1 = *(uint *)(param_1 + 0x3cc);\n            param_2 = (void *)((int)param_2 + uVar1);\n            param_3 = param_3 + uVar1;\n            param_5 = param_5 + 1;\n          } while (param_5 < param_4 / uVar1);\n        }\n      }\n      return;\n    }\n  }\n  (*pcRam00408184)(0x40f574);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n}\n\n",
    "00001af6": "\nundefined4 [MASK](undefined4 param_1,undefined4 param_2,int param_3)\n\n{\n  code *pcVar1;\n  code *pcVar2;\n  int iVar3;\n  uint uVar4;\n  \n  pcVar2 = pcRam0040805c;\n  (*pcRam0040805c)(param_1,0);\n  pcVar1 = pcRam00408058;\n  iVar3 = (*pcRam00408058)(param_1);\n  if (iVar3 != 0) {\n    (*pcVar2)(param_2,0);\n    iVar3 = (*pcVar1)(param_2);\n    if (iVar3 != 0) {\n      uVar4 = (*pcRam0040802c)(param_2);\n      (*pcRam00408054)(param_2,uVar4 | 6);\n      if (param_3 != 0) {\n        (*pcRam00408154)(param_3,0x40eb88,param_1,param_2);\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
    "000056dd": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  (*pcRam0040818c)(param_2,param_3);\n  return;\n}\n\n",
    "00001b5f": "\nbool [MASK](undefined4 param_1)\n\n{\n  code *pcVar1;\n  undefined2 *puVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined2 local_4dc;\n  undefined4 local_4da;\n  undefined2 local_2d4;\n  undefined4 local_2d2 [129];\n  undefined2 local_cc;\n  undefined4 local_ca [49];\n  \n  local_4dc = uRam0040f874;\n  puVar4 = &local_4da;\n  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  local_2d4 = uRam0040f874;\n  puVar4 = local_2d2;\n  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  local_cc = uRam0040f874;\n  puVar4 = local_ca;\n  for (iVar3 = 0x31; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  (*pcRam00408078)(0,0,0x40f8ac,0xffffffff,&local_cc,99);\n  (*pcRam00408064)(&local_4dc,0x104);\n  pcVar1 = pcRam00408154;\n  local_4da._2_2_ = 0;\n  (*pcRam00408154)(&local_2d4,0x40f40c,&local_4dc);\n  iVar3 = (*pcRam0040802c)(&local_2d4);\n  if ((iVar3 == -1) || (iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1), iVar3 == 0)) {\n    (*pcVar1)(&local_2d4,0x40f3f8,&local_4dc);\n    iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1);\n    if ((iVar3 == 0) && (iVar3 = FUN_00001af6(&local_4dc,&local_cc,param_1), iVar3 == 0)) {\n      (*pcRam00408060)(0x104,&local_2d4);\n      pcVar1 = pcRam00408150;\n      iVar3 = (*pcRam00408150)(&local_2d4,0x5c);\n      if (iVar3 != 0) {\n        puVar2 = (undefined2 *)(*pcVar1)(&local_2d4,0x5c);\n        *puVar2 = 0;\n      }\n      iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1);\n      return iVar3 != 0;\n    }\n  }\n  return true;\n}\n\n",
    "00007700": "\nvoid * [MASK](uint param_1)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007700. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam00408158)();\n  return pvVar1;\n}\n\n",
    "00001f5d": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined1 local_20c;\n  undefined4 local_20b;\n  \n  local_20c = uRam0040f910;\n  puVar2 = &local_20b;\n  for (iVar1 = 0x81; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  *(undefined2 *)puVar2 = 0;\n  *(undefined1 *)((int)puVar2 + 2) = 0;\n  (*pcRam00408084)(0x40f4d8,0x208,&local_20c,0);\n  iVar1 = FUN_00001ce8(&local_20c);\n  if ((iVar1 != 0) && (iVar1 = FUN_00001eff(0x3c), iVar1 != 0)) {\n    return 1;\n  }\n  iVar1 = FUN_00001064(&local_20c,0,0);\n  if ((iVar1 != 0) && (iVar1 = FUN_00001eff(0x3c), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
    "00007706": "\nvoid * [MASK](void *_Dst,void *_Src,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007706. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam0040815c)();\n  return pvVar1;\n}\n\n",
    "000029cc": "\nvoid [MASK](int *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  if (param_1 != (int *)0x0) {\n    if (param_1[4] != 0) {\n      (*(code *)(*(int *)(*param_1 + 0x28) + param_1[1]))(param_1[1],0,0);\n    }\n    if (param_1[2] != 0) {\n      iVar3 = 0;\n      if (0 < param_1[3]) {\n        do {\n          iVar1 = *(int *)(param_1[2] + iVar3 * 4);\n          if (iVar1 != 0) {\n            (*(code *)param_1[0xb])(iVar1,param_1[0xc]);\n          }\n          iVar3 = iVar3 + 1;\n        } while (iVar3 < param_1[3]);\n      }\n      (*pcRam00408174)(param_1[2]);\n    }\n    if (param_1[1] != 0) {\n      (*(code *)param_1[8])(param_1[1],0,0x8000,param_1[0xc]);\n    }\n    uVar2 = (*pcRam004080a0)(0,param_1);\n    (*pcRam004080b4)(uVar2);\n  }\n  return;\n}\n\n",
    "00005fe2": "\n/* WARNING: Type propagation algorithm not settling */\n\nint * [MASK](int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  int *piVar5;\n  int *piVar6;\n  int local_94 [2];\n  undefined1 local_8c [4];\n  int local_88;\n  int local_78;\n  int local_74;\n  int local_70 [22];\n  undefined4 local_18;\n  undefined1 local_14 [4];\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  iVar4 = param_1;\n  if (param_1 == 0) {\n    return (int *)0x0;\n  }\n  if (cRam0040d454 == ' ') {\n    param_1 = 0;\n    iVar1 = FUN_00005edf(iVar4);\n    if (iVar1 == -1) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005d0e(iVar4,iVar1,0);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e6b(iVar4,local_14);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_8);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_10);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,local_94 + 1);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_c);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    if (((local_c != local_94[1]) || (local_10 != 0)) || (local_8 != 0)) {\n      param_1 = -0x67;\n    }\n    iVar2 = FUN_00005e6b(iVar4,&local_74);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e6b(iVar4,local_70);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,local_8c);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    if ((uint)(*(int *)(iVar4 + 0xc) + iVar1) < (uint)(local_74 + local_70[0])) {\n      if (param_1 != 0) goto LAB_00006112;\n      param_1 = -0x67;\n    }\n    if (param_1 == 0) {\n      local_94[0] = iVar4;\n      local_18 = 0;\n      local_88 = ((*(int *)(iVar4 + 0xc) - local_74) - local_70[0]) + iVar1;\n      *(undefined4 *)(iVar4 + 0xc) = 0;\n      local_78 = iVar1;\n      piVar3 = (int *)(*pcRam00408178)(0x80);\n      piVar5 = local_94;\n      piVar6 = piVar3;\n      for (iVar4 = 0x20; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar6 = *piVar5;\n        piVar5 = piVar5 + 1;\n        piVar6 = piVar6 + 1;\n      }\n      FUN_000064e2(piVar3);\n      return piVar3;\n    }\n  }\nLAB_00006112:\n  FUN_00005c9f(iVar4);\n  return (int *)0x0;\n}\n\n",
    "00007950": "\nvoid [MASK](void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
    "000077b4": "\nchar * [MASK](char *_Dest,char *_Source)\n\n{\n  char *pcVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000077b4. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pcVar1 = (char *)(*pcRam00408190)();\n  return pcVar1;\n}\n\n",
    "000021e9": "\nint * [MASK](short *param_1,undefined4 param_2,code *param_3,code *param_4,int param_5,\n                  code *param_6,int param_7,int param_8)\n\n{\n  uint uVar1;\n  int iVar2;\n  code *pcVar3;\n  int *piVar4;\n  int iVar5;\n  void *_Dst;\n  uint uVar6;\n  int *piVar7;\n  undefined4 uVar8;\n  undefined1 local_2c [4];\n  int local_28;\n  uint local_8;\n  \n  local_8 = 0;\n  iVar2 = FUN_00002457(param_2,0x40);\n  if (iVar2 == 0) {\n    return (int *)0x0;\n  }\n  if (*param_1 == 0x5a4d) {\n    iVar2 = FUN_00002457(param_2,*(int *)(param_1 + 0x1e) + 0xf8);\n    if (iVar2 == 0) {\n      return (int *)0x0;\n    }\n    piVar7 = (int *)(*(int *)(param_1 + 0x1e) + (int)param_1);\n    if (((*piVar7 == 0x4550) && ((short)piVar7[1] == 0x14c)) && ((piVar7[0xe] & 1U) == 0)) {\n      uVar6 = (uint)*(ushort *)((int)piVar7 + 6);\n      if (uVar6 != 0) {\n        piVar4 = (int *)((int)piVar7 + *(ushort *)(piVar7 + 5) + 0x24);\n        do {\n          uVar1 = piVar4[1];\n          if (uVar1 == 0) {\n            uVar1 = piVar7[0xe];\n          }\n          if (local_8 < *piVar4 + uVar1) {\n            local_8 = *piVar4 + uVar1;\n          }\n          piVar4 = piVar4 + 10;\n          uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n      }\n      iVar2 = (*pcRam004080a4)(0x40ebe8);\n      if (iVar2 == 0) {\n        return (int *)0x0;\n      }\n      pcVar3 = (code *)(*param_6)(iVar2,0x40f55c,0);\n      if (pcVar3 == (code *)0x0) {\n        return (int *)0x0;\n      }\n      (*pcVar3)(local_2c);\n      uVar6 = piVar7[0x14] + -1 + local_28 & ~(local_28 - 1U);\n      if (uVar6 == (local_28 + -1 + local_8 & ~(local_28 - 1U))) {\n        iVar2 = (*param_3)(piVar7[0xd],uVar6,0x3000,4,param_8);\n        if ((iVar2 != 0) || (iVar2 = (*param_3)(0,uVar6,0x3000,4,param_8), iVar2 != 0)) {\n          uVar8 = (*pcRam004080a0)(8,0x3c);\n          piVar4 = (int *)(*pcRam0040809c)(uVar8);\n          if (piVar4 != (int *)0x0) {\n            piVar4[1] = iVar2;\n            piVar4[5] = (*(ushort *)((int)piVar7 + 0x16) & 0x2000) >> 0xd;\n            piVar4[7] = (int)param_3;\n            piVar4[8] = (int)param_4;\n            piVar4[9] = param_5;\n            piVar4[10] = (int)param_6;\n            piVar4[0xb] = param_7;\n            piVar4[0xc] = param_8;\n            piVar4[0xe] = local_28;\n            iVar5 = FUN_00002457(param_2,piVar7[0x15]);\n            if (iVar5 != 0) {\n              _Dst = (void *)(*param_3)(iVar2,piVar7[0x15],0x1000,4,param_8);\n              memcpy(_Dst,param_1,piVar7[0x15]);\n              iVar5 = *(int *)(param_1 + 0x1e);\n              *piVar4 = iVar5 + (int)_Dst;\n              *(int *)(iVar5 + (int)_Dst + 0x34) = iVar2;\n              iVar5 = FUN_00002470(param_1,param_2,piVar7,piVar4);\n              if (iVar5 != 0) {\n                iVar5 = *(int *)(*piVar4 + 0x34) - piVar7[0xd];\n                if (iVar5 == 0) {\n                  piVar4[6] = 1;\n                }\n                else {\n                  iVar5 = FUN_00002758(piVar4,iVar5);\n                  piVar4[6] = iVar5;\n                }\n                iVar5 = FUN_000027df(piVar4);\n                if (((iVar5 != 0) && (iVar5 = FUN_0000254b(piVar4), iVar5 != 0)) &&\n                   (iVar5 = FUN_0000271d(piVar4), iVar5 != 0)) {\n                  iVar5 = *(int *)(*piVar4 + 0x28);\n                  if (iVar5 == 0) {\n                    piVar4[0xd] = 0;\n                    return piVar4;\n                  }\n                  if (piVar4[5] == 0) {\n                    piVar4[0xd] = iVar5 + iVar2;\n                    return piVar4;\n                  }\n                  iVar2 = (*(code *)(iVar5 + iVar2))(iVar2,1,0);\n                  if (iVar2 != 0) {\n                    piVar4[4] = 1;\n                    return piVar4;\n                  }\n                  (*pcRam004080a8)(0x45a);\n                }\n              }\n            }\n            FUN_000029cc(piVar4);\n            return (int *)0x0;\n          }\n          (*param_4)(iVar2,0,0x8000,param_8);\n        }\n        uVar8 = 0xe;\n        goto LAB_00002219;\n      }\n    }\n  }\n  uVar8 = 0xc1;\nLAB_00002219:\n  (*pcRam004080a8)(uVar8);\n  return (int *)0x0;\n}\n\n",
    "000018f9": "\nundefined4 [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 local_20 [3];\n  undefined4 local_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x4081f0;\n  uStack_10 = 0x4076f4;\n  local_14 = puRamffdff000;\n  uVar4 = 0;\n  local_20[0] = 0;\n  local_8 = 0;\n  puRamffdff000 = &local_14;\n  iVar1 = (*pcRam00408034)(param_3,0x80000000,1,0,3,0,0);\n  if (iVar1 != -1) {\n    uVar2 = (*pcRam00408044)(iVar1,0);\n    if ((uVar2 != 0xffffffff) && (uVar2 < 0x19001)) {\n      iVar3 = (*pcRam004080dc)(0,uVar2);\n      if (iVar3 != 0) {\n        iVar1 = (*pcRam00408040)(iVar1,iVar3,uVar2,local_20,0);\n        if (iVar1 != 0) {\n          iVar1 = (*pcRam0040f898)(param_1,iVar3,local_20[0],0,0,param_2);\n          if (iVar1 != 0) {\n            uVar4 = 1;\n          }\n        }\n      }\n    }\n  }\n  local_unwind2(&local_14,0xffffffff);\n  puRamffdff000 = (undefined4 *)local_14;\n  return uVar4;\n}\n\n",
    "0000264f": "\nint [MASK](int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_2 + 0x10);\n  if (iVar1 == 0) {\n    if ((*(uint *)(param_2 + 0x24) & 0x40) != 0) {\n      return *(int *)(*param_1 + 0x20);\n    }\n    if ((*(uint *)(param_2 + 0x24) & 0x80) != 0) {\n      iVar1 = *(int *)(*param_1 + 0x24);\n    }\n  }\n  return iVar1;\n}\n\n",
    "0000793f": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n"
}