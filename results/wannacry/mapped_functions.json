{
    "0000657a": {
        "decomp_code": "\nint FUN_0000657a(undefined4 *param_1,int *param_2,int *param_3,int *param_4)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  int *piVar3;\n  int iVar4;\n  int iVar5;\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  piVar3 = param_2;\n  puVar2 = param_1;\n  iVar5 = 0;\n  *param_2 = 0;\n  *param_3 = 0;\n  *param_4 = 0;\n  iVar4 = FUN_00005d0e(*param_1,param_1[3] + param_1[0x1e],0);\n  if (iVar4 == 0) {\n    iVar4 = FUN_00005e6b(*puVar2,&local_c);\n    if (iVar4 == 0) {\n      if (local_c != 0x4034b50) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_2);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_1);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if ((iVar5 == 0) &&\n         ((piVar1 = (int *)puVar2[0xd], param_2 != piVar1 ||\n          ((piVar1 != (int *)0x0 && ((word *)piVar1 != &IMAGE_DOS_HEADER_00000000.e_cparhdr)))))) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0xf])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x10])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e6b(*puVar2,&param_2);\n    if (iVar4 == 0) {\n      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x11])) && (((uint)param_1 & 8) == 0)) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    iVar4 = FUN_00005e27(*puVar2,&local_8);\n    if (iVar4 == 0) {\n      if ((iVar5 == 0) && (local_8 != puVar2[0x12])) {\n        iVar5 = -0x67;\n      }\n    }\n    else {\n      iVar5 = -1;\n    }\n    *piVar3 = *piVar3 + local_8;\n    iVar4 = FUN_00005e27(*puVar2,&local_10);\n    if (iVar4 != 0) {\n      iVar5 = -1;\n    }\n    *param_3 = puVar2[0x1e] + 0x1e + local_8;\n    *param_4 = local_10;\n    *piVar3 = *piVar3 + local_10;\n  }\n  else {\n    iVar5 = -1;\n  }\n  return iVar5;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xc",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "PUSH EBX",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "XOR EDI,EDI",
            "MOV dword ptr [EBX],EDI",
            "MOV dword ptr [EAX],EDI",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "PUSH EDI",
            "MOV dword ptr [EAX],EDI",
            "MOV EAX,dword ptr [ESI + 0xc]",
            "ADD EAX,dword ptr [ESI + 0x78]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x000065b5",
            "OR EAX,0xffffffff",
            "JMP 0x00006718",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000065cb",
            "OR EDI,0xffffffff",
            "JMP 0x000065d7",
            "CMP dword ptr [EBP + -0x8],0x4034b50",
            "JZ 0x000065d7",
            "PUSH -0x67",
            "POP EDI",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000065eb",
            "OR EDI,0xffffffff",
            "LEA EAX,[EBP + 0x8]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000065ff",
            "OR EDI,0xffffffff",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006615",
            "OR EDI,0xffffffff",
            "JMP 0x0000662d",
            "TEST EDI,EDI",
            "JNZ 0x0000662d",
            "MOV EAX,dword ptr [ESI + 0x34]",
            "CMP dword ptr [EBP + 0xc],EAX",
            "JNZ 0x0000662a",
            "TEST EAX,EAX",
            "JZ 0x0000662d",
            "CMP EAX,0x8",
            "JZ 0x0000662d",
            "PUSH -0x67",
            "POP EDI",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006641",
            "OR EDI,0xffffffff",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006657",
            "OR EDI,0xffffffff",
            "JMP 0x0000666c",
            "TEST EDI,EDI",
            "JNZ 0x0000666c",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CMP EAX,dword ptr [ESI + 0x3c]",
            "JZ 0x0000666c",
            "TEST byte ptr [EBP + 0x8],0x8",
            "JNZ 0x0000666c",
            "PUSH -0x67",
            "POP EDI",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006682",
            "OR EDI,0xffffffff",
            "JMP 0x00006697",
            "TEST EDI,EDI",
            "JNZ 0x00006697",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CMP EAX,dword ptr [ESI + 0x40]",
            "JZ 0x00006697",
            "TEST byte ptr [EBP + 0x8],0x8",
            "JNZ 0x00006697",
            "PUSH -0x67",
            "POP EDI",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000066ad",
            "OR EDI,0xffffffff",
            "JMP 0x000066c2",
            "TEST EDI,EDI",
            "JNZ 0x000066c2",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CMP EAX,dword ptr [ESI + 0x44]",
            "JZ 0x000066c2",
            "TEST byte ptr [EBP + 0x8],0x8",
            "JNZ 0x000066c2",
            "PUSH -0x67",
            "POP EDI",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "POP ECX",
            "JZ 0x000066db",
            "OR EDI,0xffffffff",
            "JMP 0x000066e7",
            "TEST EDI,EDI",
            "JNZ 0x000066e7",
            "CMP EAX,dword ptr [ESI + 0x48]",
            "JZ 0x000066e7",
            "PUSH -0x67",
            "POP EDI",
            "ADD dword ptr [EBX],EAX",
            "LEA EAX,[EBP + -0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000066fd",
            "OR EDI,0xffffffff",
            "MOV EAX,dword ptr [ESI + 0x78]",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "LEA EAX,[EAX + ECX*0x1 + 0x1e]",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "MOV dword ptr [ECX],EAX",
            "MOV ECX,dword ptr [EBP + 0x14]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "MOV dword ptr [ECX],EAX",
            "ADD dword ptr [EBX],EAX",
            "MOV EAX,EDI",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "0000657a",
            "end": "0000671c"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000065b5",
                    "000065cb"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000066c2",
                    "000066d0",
                    "00006700"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000066e9",
                    "0000670f"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000657a",
        "original_name": "FUN_0000657a",
        "predicted_name": "FUN_00005e6b.",
        "prediction_full_response": "The predicted function name is FUN_00005e6b.</s>"
    },
    "000013ce": {
        "decomp_code": "\nundefined4 __fastcall FUN_000013ce(int param_1)\n\n{\n  code *pcVar1;\n  undefined1 *puVar2;\n  int iVar3;\n  int iVar4;\n  \n  FUN_000018b9();\n  FUN_000018b9();\n  pcVar1 = pcRam004080e8;\n  puVar2 = *(undefined1 **)(param_1 + 0x4c8);\n  iVar4 = 0x100000;\n  if (puVar2 != (undefined1 *)0x0) {\n    iVar3 = 0x100000;\n    do {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n      iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    (*pcVar1)(*(undefined4 *)(param_1 + 0x4c8));\n    *(undefined4 *)(param_1 + 0x4c8) = 0;\n  }\n  puVar2 = *(undefined1 **)(param_1 + 0x4cc);\n  if (puVar2 != (undefined1 *)0x0) {\n    do {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n      iVar4 = iVar4 + -1;\n    } while (iVar4 != 0);\n    (*pcVar1)(*(undefined4 *)(param_1 + 0x4cc));\n    *(undefined4 *)(param_1 + 0x4cc) = 0;\n  }\n  return 1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "LEA ECX,[ESI + 0x4]",
            "CALL 0x000018b9",
            "LEA ECX,[ESI + 0x2c]",
            "CALL 0x000018b9",
            "MOV EAX,dword ptr [ESI + 0x4c8]",
            "MOV EBX,dword ptr [0x004080e8]",
            "TEST EAX,EAX",
            "MOV EDI,0x100000",
            "JZ 0x00001410",
            "MOV ECX,EDI",
            "MOV byte ptr [EAX],0x0",
            "INC EAX",
            "DEC ECX",
            "JNZ 0x000013fa",
            "PUSH dword ptr [ESI + 0x4c8]",
            "CALL EBX",
            "AND dword ptr [ESI + 0x4c8],0x0",
            "MOV EAX,dword ptr [ESI + 0x4cc]",
            "TEST EAX,EAX",
            "JZ 0x00001430",
            "MOV byte ptr [EAX],0x0",
            "INC EAX",
            "DEC EDI",
            "JNZ 0x0000141a",
            "PUSH dword ptr [ESI + 0x4cc]",
            "CALL EBX",
            "AND dword ptr [ESI + 0x4cc],0x0",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "000013ce",
            "end": "00001436"
        },
        "variable_metadata": {},
        "func_name": "FUN_000013ce",
        "original_name": "FUN_000013ce",
        "predicted_name": "FUN_000018b9.",
        "prediction_full_response": "The predicted function name is FUN_000018b9.</s>"
    },
    "00005535": {
        "decomp_code": "\nvoid FUN_00005535(uint *param_1,byte param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)((*param_1 & 0xff ^ (uint)param_2) * 4 + 0x40d054) ^ *param_1 >> 8;\n  *param_1 = uVar1;\n  uVar1 = ((uVar1 & 0xff) + param_1[1]) * 0x8088405 + 1;\n  param_1[1] = uVar1;\n  param_1[2] = *(uint *)((uVar1 >> 0x18 ^ param_1[2] & 0xff) * 4 + 0x40d054) ^ param_1[2] >> 8;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [ESP + 0x4]",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDX,0xff",
            "MOV ESI,dword ptr [ECX]",
            "MOVZX EDI,byte ptr [ESP + 0x10]",
            "MOV EAX,ESI",
            "AND EAX,EDX",
            "XOR EAX,EDI",
            "SHR ESI,0x8",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40d054]",
            "XOR EAX,ESI",
            "MOV ESI,dword ptr [ECX + 0x8]",
            "MOV dword ptr [ECX],EAX",
            "AND EAX,EDX",
            "ADD EAX,dword ptr [ECX + 0x4]",
            "MOV EDI,ESI",
            "AND EDI,EDX",
            "IMUL EAX,EAX,0x8088405",
            "INC EAX",
            "MOV dword ptr [ECX + 0x4],EAX",
            "SHR EAX,0x18",
            "XOR EAX,EDI",
            "POP EDI",
            "SHR ESI,0x8",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40d054]",
            "XOR EAX,ESI",
            "POP ESI",
            "MOV dword ptr [ECX + 0x8],EAX",
            "RET"
        ],
        "function_address": {
            "start": "00005535",
            "end": "00005587"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005535",
        "original_name": "FUN_00005535",
        "predicted_name": "mix_bytes.",
        "prediction_full_response": "The predicted function name is mix_bytes.</s>"
    },
    "00005777": {
        "decomp_code": "\n/* WARNING: Removing unreachable block (ram,0x00005836) */\n\nundefined4 FUN_00005777(int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (param_1 == 0) {\n    uVar2 = 0xfffffffe;\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x18) = 0;\n    if (*(int *)(param_1 + 0x20) == 0) {\n      *(undefined4 *)(param_1 + 0x20) = 0x4056dd;\n      *(undefined4 *)(param_1 + 0x28) = 0;\n    }\n    if (*(int *)(param_1 + 0x24) == 0) {\n      *(undefined4 *)(param_1 + 0x24) = 0x4056ee;\n    }\n    iVar1 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x18);\n    *(int *)(param_1 + 0x1c) = iVar1;\n    if (iVar1 != 0) {\n      *(undefined4 *)(iVar1 + 0x14) = 0;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 0;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 1;\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x10) = 0xf;\n      uVar2 = FUN_0000432b(param_1,~-(uint)(*(int *)(*(int *)(param_1 + 0x1c) + 0xc) != 0) &\n                                   0x4055c4,0x8000);\n      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14) = uVar2;\n      if (*(int *)(*(int *)(param_1 + 0x1c) + 0x14) != 0) {\n        FUN_000056fa(param_1);\n        return 0;\n      }\n      FUN_00005739();\n    }\n    uVar2 = 0xfffffffc;\n  }\n  return uVar2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,0x40f7b0",
            "PUSH ESI",
            "TEST EAX,EAX",
            "PUSH EDI",
            "JZ 0x00005836",
            "MOV AL,[0x0040f7b0]",
            "CMP AL,AL",
            "JNZ 0x00005836",
            "MOV ESI,dword ptr [ESP + 0xc]",
            "XOR EDI,EDI",
            "CMP ESI,EDI",
            "JNZ 0x000057a4",
            "PUSH -0x2",
            "JMP 0x00005838",
            "CMP dword ptr [ESI + 0x20],EDI",
            "MOV dword ptr [ESI + 0x18],EDI",
            "JNZ 0x000057b6",
            "MOV dword ptr [ESI + 0x20],0x4056dd",
            "MOV dword ptr [ESI + 0x28],EDI",
            "CMP dword ptr [ESI + 0x24],EDI",
            "JNZ 0x000057c2",
            "MOV dword ptr [ESI + 0x24],0x4056ee",
            "PUSH 0x18",
            "PUSH 0x1",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0xc",
            "CMP EAX,EDI",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "JZ 0x00005828",
            "MOV dword ptr [EAX + 0x14],EDI",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "PUSH 0x8000",
            "MOV dword ptr [EAX + 0xc],EDI",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX + 0xc],0x1",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX + 0x10],0xf",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EAX,dword ptr [EAX + 0xc]",
            "NEG EAX",
            "SBB EAX,EAX",
            "NOT EAX",
            "AND EAX,0x4055c4",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x0000432b",
            "MOV ECX,dword ptr [ESI + 0x1c]",
            "ADD ESP,0xc",
            "MOV dword ptr [ECX + 0x14],EAX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "PUSH ESI",
            "CMP dword ptr [EAX + 0x14],EDI",
            "JNZ 0x0000582c",
            "CALL 0x00005739",
            "POP ECX",
            "PUSH -0x4",
            "JMP 0x00005838",
            "CALL 0x000056fa",
            "POP ECX",
            "XOR EAX,EAX",
            "JMP 0x00005839",
            "PUSH -0x6",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00005777",
            "end": "0000583b"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005777",
        "original_name": "FUN_00005777",
        "predicted_name": "FUN_00005739.]",
        "prediction_full_response": "[/INST: The predicted function name is FUN_00005739.]</s>"
    },
    "0000350f": {
        "decomp_code": "\nvoid __thiscall FUN_0000350f(int param_1,byte *param_2,byte *param_3)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  byte *pbVar6;\n  undefined1 local_38 [12];\n  uint local_2c;\n  int local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  uint *local_c;\n  uint *local_8;\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_38,(ThrowInfo *)0x40d570);\n  }\n  if (*(int *)(param_1 + 0x3cc) == 0x10) {\n    FUN_00002e7e(param_2,param_3);\n  }\n  else {\n    iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;\n    local_1c = *(int *)(iVar4 + 0x40bc24);\n    local_18 = *(int *)(iVar4 + 0x40bc2c);\n    local_20 = *(int *)(iVar4 + 0x40bc34);\n    if (0 < iVar3) {\n      puVar5 = (uint *)(param_1 + 0x454);\n      local_10 = iVar3;\n      local_8 = (uint *)(param_1 + 8);\n      do {\n        *puVar5 = (uint)*param_2 << 0x18;\n        *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n        *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n        *puVar5 = *puVar5 | (uint)param_2[3];\n        puVar1 = local_8 + 1;\n        param_2 = param_2 + 4;\n        *puVar5 = *puVar5 ^ *local_8;\n        local_10 = local_10 + -1;\n        puVar5 = puVar5 + 1;\n        local_8 = puVar1;\n      } while (local_10 != 0);\n    }\n    local_10 = 1;\n    if (1 < *(int *)(param_1 + 0x410)) {\n      local_c = (uint *)(param_1 + 0x28);\n      do {\n        if (0 < iVar3) {\n          local_8 = local_c;\n          local_24 = local_18 - local_1c;\n          param_2 = (byte *)local_1c;\n          local_28 = local_20 - local_1c;\n          puVar5 = (uint *)(param_1 + 0x434);\n          local_14 = iVar3;\n          do {\n            local_2c = (uint)*(byte *)(param_1 + 0x455 + ((local_24 + (int)param_2) % iVar3) * 4);\n            puVar1 = local_8 + 1;\n            *puVar5 = *(uint *)(local_2c * 4 + 0x4093fc) ^\n                      *(uint *)((*(uint *)(param_1 + 0x454 + ((local_28 + (int)param_2) % iVar3) * 4\n                                          ) & 0xff) * 4 + 0x4097fc) ^\n                      *(uint *)((uint)*(byte *)(param_1 + 0x456 + ((int)param_2 % iVar3) * 4) * 4 +\n                               0x408ffc) ^\n                      *(uint *)((uint)*(byte *)((int)puVar5 + 0x23) * 4 + 0x408bfc) ^ *local_8;\n            puVar5 = puVar5 + 1;\n            param_2 = (byte *)((int)param_2 + 1);\n            local_14 = local_14 + -1;\n            local_8 = puVar1;\n          } while (local_14 != 0);\n        }\n        memcpy((void *)(param_1 + 0x454),(void *)(param_1 + 0x434),iVar3 << 2);\n        local_c = local_c + 8;\n        local_10 = local_10 + 1;\n      } while (local_10 < *(int *)(param_1 + 0x410));\n    }\n    local_8 = (uint *)0x0;\n    if (0 < iVar3) {\n      local_1c = local_1c - local_18;\n      local_20 = local_20 - local_18;\n      pbVar6 = param_3;\n      param_3 = (byte *)(param_1 + 0x454);\n      do {\n        uVar2 = *(undefined4 *)(param_1 + 8 + ((int)local_8 + *(int *)(param_1 + 0x410) * 8) * 4);\n        *pbVar6 = *(byte *)(*(byte *)((int)param_3 + 3) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n        pbVar6[1] = *(byte *)(*(byte *)(param_1 + 0x456 + ((local_1c + local_18) % iVar3) * 4) +\n                             0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n        pbVar6[2] = *(byte *)(*(byte *)(param_1 + 0x455 + (local_18 % iVar3) * 4) + 0x4089fc) ^\n                    (byte)((uint)uVar2 >> 8);\n        param_2._0_1_ = (byte)uVar2;\n        pbVar6[3] = *(byte *)((*(uint *)(param_1 + 0x454 + ((local_20 + local_18) % iVar3) * 4) &\n                              0xff) + 0x4089fc) ^ (byte)param_2;\n        pbVar6 = pbVar6 + 4;\n        local_8 = (uint *)((int)local_8 + 1);\n        local_18 = local_18 + 1;\n        param_3 = (byte *)((int)param_3 + 4);\n      } while ((int)local_8 < iVar3);\n    }\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x34",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "CMP byte ptr [ESI + 0x4],0x0",
            "JNZ 0x0000353c",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0x34]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x34]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [ESI + 0x3cc]",
            "CMP EAX,0x10",
            "JNZ 0x00003559",
            "PUSH dword ptr [EBP + 0xc]",
            "MOV ECX,ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00002e7e",
            "JMP 0x00003790",
            "PUSH 0x4",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "MOV EDI,EAX",
            "SUB EAX,ECX",
            "XOR ECX,ECX",
            "CMP EDI,0x6",
            "SETNZ CL",
            "INC ECX",
            "NEG EAX",
            "SBB EAX,EAX",
            "AND EAX,ECX",
            "SHL EAX,0x5",
            "TEST EDI,EDI",
            "MOV ECX,dword ptr [EAX + 0x40bc24]",
            "MOV dword ptr [EBP + -0x18],ECX",
            "MOV ECX,dword ptr [EAX + 0x40bc2c]",
            "MOV EAX,dword ptr [EAX + 0x40bc34]",
            "MOV dword ptr [EBP + -0x14],ECX",
            "MOV dword ptr [EBP + -0x1c],EAX",
            "LEA EAX,[ESI + 0x454]",
            "JLE 0x000035da",
            "LEA ECX,[ESI + 0x8]",
            "MOV dword ptr [EBP + -0xc],EDI",
            "MOV dword ptr [EBP + -0x4],ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOVZX EDX,byte ptr [ECX]",
            "SHL EDX,0x18",
            "INC ECX",
            "MOV dword ptr [EAX],EDX",
            "MOVZX EDX,byte ptr [ECX]",
            "SHL EDX,0x10",
            "OR dword ptr [EAX],EDX",
            "INC ECX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [ECX]",
            "OR dword ptr [EAX],EDX",
            "INC ECX",
            "MOV EDX,EAX",
            "MOVZX EBX,byte ptr [ECX]",
            "OR dword ptr [EAX],EBX",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + -0x4],0x4",
            "INC ECX",
            "MOV EBX,dword ptr [EBX]",
            "ADD EAX,0x4",
            "XOR dword ptr [EDX],EBX",
            "DEC dword ptr [EBP + -0xc]",
            "JNZ 0x000035a6",
            "PUSH 0x1",
            "POP EAX",
            "CMP dword ptr [ESI + 0x410],EAX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "JLE 0x000036c7",
            "LEA EAX,[ESI + 0x28]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "TEST EDI,EDI",
            "JLE 0x00003695",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV EDX,dword ptr [EBP + -0x18]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "MOV dword ptr [EBP + -0x20],EAX",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "SUB EAX,EDX",
            "LEA ECX,[ESI + 0x434]",
            "MOV dword ptr [EBP + -0x24],EAX",
            "MOV dword ptr [EBP + -0x10],EDI",
            "MOV EAX,dword ptr [EBP + -0x20]",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "ADD EAX,EBX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,EDX",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [ESI + EAX*0x4 + 0x455]",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "ADD EAX,EBX",
            "MOV dword ptr [EBP + -0x28],EDX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,dword ptr [ESI + EDX*0x4 + 0x454]",
            "MOV EDX,dword ptr [EBP + -0x28]",
            "AND EAX,0xff",
            "MOV EBX,dword ptr [EDX*0x4 + 0x4093fc]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x4097fc]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x456]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x408ffc]",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ECX + 0x23]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x408bfc]",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + -0x4],0x4",
            "XOR EBX,dword ptr [EAX]",
            "MOV dword ptr [ECX],EBX",
            "ADD ECX,0x4",
            "INC dword ptr [EBP + 0x8]",
            "DEC dword ptr [EBP + -0x10]",
            "JNZ 0x0000361f",
            "MOV EAX,EDI",
            "SHL EAX,0x2",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x434]",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x454]",
            "PUSH EAX",
            "CALL 0x00007706",
            "ADD dword ptr [EBP + -0x8],0x20",
            "ADD ESP,0xc",
            "INC dword ptr [EBP + -0xc]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "CMP EAX,dword ptr [ESI + 0x410]",
            "JL 0x000035f2",
            "AND dword ptr [EBP + -0x4],0x0",
            "TEST EDI,EDI",
            "JLE 0x00003790",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV EBX,dword ptr [EBP + -0x14]",
            "LEA EAX,[ESI + 0x454]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "SUB EAX,EBX",
            "MOV dword ptr [EBP + -0x28],EAX",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "SUB EAX,EBX",
            "MOV dword ptr [EBP + -0x24],EAX",
            "MOV EAX,dword ptr [ESI + 0x410]",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV EDX,dword ptr [EBP + 0xc]",
            "ADD dword ptr [EBP + 0xc],0x4",
            "MOV EAX,dword ptr [ESI + EAX*0x4 + 0x8]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EDX + 0x3]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x18",
            "MOV AL,byte ptr [EAX + 0x4089fc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,dword ptr [EBP + -0x28]",
            "ADD EAX,EBX",
            "INC ECX",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x456]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x10",
            "MOV AL,byte ptr [EAX + 0x4089fc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,EBX",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "INC ECX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x455]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x8",
            "MOV AL,byte ptr [EAX + 0x4089fc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "ADD EAX,EBX",
            "INC ECX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,dword ptr [ESI + EDX*0x4 + 0x454]",
            "AND EAX,0xff",
            "MOV AL,byte ptr [EAX + 0x4089fc]",
            "XOR AL,byte ptr [EBP + 0x8]",
            "MOV byte ptr [ECX],AL",
            "INC ECX",
            "INC dword ptr [EBP + -0x4]",
            "INC EBX",
            "CMP dword ptr [EBP + -0x4],EDI",
            "JL 0x000036f2",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "0000350f",
            "end": "00003796"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000035ef",
                    "000035fa",
                    "000036ae"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000357d",
                    "000035fd",
                    "000036e2"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000363a",
                    "00003647",
                    "000036e7",
                    "00003721"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000035a0",
                    "000035c6",
                    "000035c9",
                    "00003600",
                    "0000367f",
                    "00003682",
                    "000036c7",
                    "000036f8",
                    "00003783",
                    "00003787"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000358c",
                    "00003603",
                    "000036d6"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003619",
                    "00003635",
                    "000036ef",
                    "00003762"
                ],
                "type": "undefined4"
            },
            "local_38": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003525",
                    "0000352e"
                ],
                "type": "undefined"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000359d",
                    "000035d5",
                    "000035e3",
                    "000036b5",
                    "000036b8"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000358f",
                    "0000360e",
                    "000036ea"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000361c",
                    "00003690"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000360b",
                    "0000361f"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000350f",
        "original_name": "FUN_0000350f",
        "predicted_name": "FUN_00002e7e.",
        "prediction_full_response": "The predicted function name is FUN_00002e7e.</s>"
    },
    "00006b8e": {
        "decomp_code": "\nint * __thiscall FUN_00006b8e(int *param_1,undefined4 param_2,undefined4 param_3,int param_4)\n\n{\n  int *_Str;\n  char cVar1;\n  size_t sVar2;\n  int iVar3;\n  int *local_8;\n  \n  if ((*param_1 == 0) && (param_1[1] == -1)) {\n    _Str = param_1 + 0x50;\n    local_8 = param_1;\n    (*pcRam004080d4)(0x104,_Str);\n    sVar2 = strlen((char *)_Str);\n    cVar1 = *(char *)(sVar2 + 0x13f + (int)param_1);\n    if ((cVar1 != '\\\\') && (cVar1 != '/')) {\n      strcat((char *)_Str,(char *)0x40f818);\n    }\n    if ((param_4 == 1) && (iVar3 = (*pcRam004080c8)(param_2,0,0,1), iVar3 == -1)) {\n      local_8 = (int *)0x2000000;\n    }\n    else {\n      iVar3 = FUN_00005bae(param_2,param_3,param_4,&local_8);\n      if (iVar3 != 0) {\n        iVar3 = FUN_00005fe2(iVar3);\n        *param_1 = iVar3;\n        local_8 = (int *)((-(uint)(iVar3 != 0) & 0xfffffe00) + 0x200);\n      }\n    }\n  }\n  else {\n    local_8 = (int *)0x1000000;\n  }\n  return local_8;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "CMP dword ptr [ESI],0x0",
            "JNZ 0x00006c36",
            "CMP dword ptr [ESI + 0x4],-0x1",
            "JNZ 0x00006c36",
            "PUSH EDI",
            "LEA EDI,[ESI + 0x140]",
            "PUSH EDI",
            "PUSH 0x104",
            "CALL dword ptr [0x004080d4]",
            "PUSH EDI",
            "CALL 0x000076b4",
            "MOV AL,byte ptr [EAX + ESI*0x1 + 0x13f]",
            "POP ECX",
            "CMP AL,0x5c",
            "JZ 0x00006bde",
            "CMP AL,0x2f",
            "JZ 0x00006bde",
            "PUSH 0x40f818",
            "PUSH EDI",
            "CALL 0x000077b4",
            "POP ECX",
            "POP ECX",
            "CMP dword ptr [EBP + 0x10],0x1",
            "POP EDI",
            "JNZ 0x00006c00",
            "PUSH 0x1",
            "PUSH 0x0",
            "PUSH 0x0",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x004080c8]",
            "CMP EAX,-0x1",
            "JNZ 0x00006c00",
            "MOV EAX,0x2000000",
            "JMP 0x00006c3b",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005bae",
            "ADD ESP,0x10",
            "TEST EAX,EAX",
            "JNZ 0x00006c1e",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "JMP 0x00006c3b",
            "PUSH EAX",
            "CALL 0x00005fe2",
            "MOV dword ptr [ESI],EAX",
            "POP ECX",
            "NEG EAX",
            "SBB EAX,EAX",
            "AND AX,0xfe00",
            "ADD EAX,0x200",
            "JMP 0x00006c3b",
            "MOV EAX,0x1000000",
            "POP ESI",
            "LEAVE",
            "RET 0xc"
        ],
        "function_address": {
            "start": "00006b8e",
            "end": "00006c3f"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006c00",
                    "00006c19"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00006b8e",
        "original_name": "FUN_00006b8e",
        "predicted_name": "FUN_00005bae.",
        "prediction_full_response": "The predicted function name is FUN_00005bae.</s>"
    },
    "000056fa": {
        "decomp_code": "\nundefined4 FUN_000056fa(int param_1)\n\n{\n  uint *puVar1;\n  \n  if ((param_1 != 0) && (puVar1 = *(uint **)(param_1 + 0x1c), puVar1 != (uint *)0x0)) {\n    *(undefined4 *)(param_1 + 0x14) = 0;\n    *(undefined4 *)(param_1 + 8) = 0;\n    *(undefined4 *)(param_1 + 0x18) = 0;\n    *puVar1 = -(uint)(puVar1[3] != 0) & 7;\n    FUN_000042c0(*(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14),param_1,0);\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "XOR EDX,EDX",
            "CMP EAX,EDX",
            "JZ 0x00005735",
            "MOV ECX,dword ptr [EAX + 0x1c]",
            "CMP ECX,EDX",
            "JZ 0x00005735",
            "PUSH ESI",
            "MOV dword ptr [EAX + 0x14],EDX",
            "MOV dword ptr [EAX + 0x8],EDX",
            "MOV dword ptr [EAX + 0x18],EDX",
            "MOV ESI,dword ptr [ECX + 0xc]",
            "PUSH EDX",
            "NEG ESI",
            "SBB ESI,ESI",
            "PUSH EAX",
            "AND ESI,0x7",
            "MOV dword ptr [ECX],ESI",
            "MOV EAX,dword ptr [EAX + 0x1c]",
            "PUSH dword ptr [EAX + 0x14]",
            "CALL 0x000042c0",
            "ADD ESP,0xc",
            "XOR EAX,EAX",
            "POP ESI",
            "RET",
            "PUSH -0x2",
            "POP EAX",
            "RET"
        ],
        "function_address": {
            "start": "000056fa",
            "end": "00005738"
        },
        "variable_metadata": {},
        "func_name": "FUN_000056fa",
        "original_name": "FUN_000056fa",
        "predicted_name": "FUN_000042c0.",
        "prediction_full_response": "The predicted function name is FUN_000042c0.</s>"
    },
    "000077ba": {
        "decomp_code": "\nvoid entry(void)\n\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  byte *pbVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined1 local_74 [4];\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined1 local_68 [4];\n  undefined1 local_64 [4];\n  undefined1 local_60 [44];\n  uint local_34;\n  undefined2 local_30;\n  undefined1 *local_1c;\n  undefined4 uStack_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x40d488;\n  uStack_10 = 0x4076f4;\n  uStack_14 = puRamffdff000;\n  local_1c = &stack0xffffff78;\n  local_8 = 0;\n  puRamffdff000 = &uStack_14;\n  (*pcRam004081c4)(2);\n  uRam0040f94c = 0xffffffff;\n  uRam0040f950 = 0xffffffff;\n  puVar1 = (undefined4 *)(*pcRam004081c0)();\n  *puVar1 = uRam0040f948;\n  puVar1 = (undefined4 *)(*pcRam004081bc)();\n  *puVar1 = uRam0040f944;\n  uRam0040f954 = *puRam004081b8;\n  FUN_0000793f();\n  if (iRam0040f870 == 0) {\n    (*pcRam004081b4)(0x40793c);\n  }\n  FUN_0000792a();\n  initterm(0x40e008,0x40e00c);\n  local_70 = uRam0040f940;\n  (*pcRam004081ac)(local_64,local_74,local_68,uRam0040f93c,&local_70);\n  initterm(0x40e000,0x40e004);\n  pbVar3 = (byte *)*puRam004081a8;\n  if (*pbVar3 != 0x22) {\n    do {\n      if (*pbVar3 < 0x21) goto LAB_000078ad;\n      pbVar3 = pbVar3 + 1;\n    } while( true );\n  }\n  do {\n    pbVar3 = pbVar3 + 1;\n    if (*pbVar3 == 0) break;\n  } while (*pbVar3 != 0x22);\n  if (*pbVar3 != 0x22) goto LAB_000078ad;\n  do {\n    pbVar3 = pbVar3 + 1;\nLAB_000078ad:\n  } while ((*pbVar3 != 0) && (*pbVar3 < 0x21));\n  local_34 = 0;\n  (*pcRam004080c4)(local_60);\n  if ((local_34 & 1) == 0) {\n    local_30 = 10;\n  }\n  uVar5 = 0;\n  uVar4 = 0;\n  uVar2 = (*pcRam004080a4)(0,0,pbVar3,local_30);\n  local_6c = FUN_00001fe7(uVar2,uVar4,uVar5,pbVar3);\n  (*pcRam004081a4)(local_6c);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH -0x1",
            "PUSH 0x40d488",
            "PUSH 0x4076f4",
            "MOV EAX,FS:[0x0]",
            "PUSH EAX",
            "MOV dword ptr FS:[0x0],ESP",
            "SUB ESP,0x68",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV dword ptr [EBP + -0x18],ESP",
            "XOR EBX,EBX",
            "MOV dword ptr [EBP + -0x4],EBX",
            "PUSH 0x2",
            "CALL dword ptr [0x004081c4]",
            "POP ECX",
            "OR dword ptr [0x0040f94c],0xffffffff",
            "OR dword ptr [0x0040f950],0xffffffff",
            "CALL dword ptr [0x004081c0]",
            "MOV ECX,dword ptr [0x0040f948]",
            "MOV dword ptr [EAX],ECX",
            "CALL dword ptr [0x004081bc]",
            "MOV ECX,dword ptr [0x0040f944]",
            "MOV dword ptr [EAX],ECX",
            "MOV EAX,[0x004081b8]",
            "MOV EAX,dword ptr [EAX]",
            "MOV [0x0040f954],EAX",
            "CALL 0x0000793f",
            "CMP dword ptr [0x0040f870],EBX",
            "JNZ 0x0000783d",
            "PUSH 0x40793c",
            "CALL dword ptr [0x004081b4]",
            "POP ECX",
            "CALL 0x0000792a",
            "PUSH 0x40e00c",
            "PUSH 0x40e008",
            "CALL 0x00007924",
            "MOV EAX,[0x0040f940]",
            "MOV dword ptr [EBP + -0x6c],EAX",
            "LEA EAX,[EBP + -0x6c]",
            "PUSH EAX",
            "PUSH dword ptr [0x0040f93c]",
            "LEA EAX,[EBP + -0x64]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x70]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x60]",
            "PUSH EAX",
            "CALL dword ptr [0x004081ac]",
            "PUSH 0x40e004",
            "PUSH 0x40e000",
            "CALL 0x00007924",
            "ADD ESP,0x24",
            "MOV EAX,[0x004081a8]",
            "MOV ESI,dword ptr [EAX]",
            "MOV dword ptr [EBP + -0x74],ESI",
            "CMP byte ptr [ESI],0x22",
            "JNZ 0x000078d0",
            "INC ESI",
            "MOV dword ptr [EBP + -0x74],ESI",
            "MOV AL,byte ptr [ESI]",
            "CMP AL,BL",
            "JZ 0x000078a4",
            "CMP AL,0x22",
            "JNZ 0x00007896",
            "CMP byte ptr [ESI],0x22",
            "JNZ 0x000078ad",
            "INC ESI",
            "MOV dword ptr [EBP + -0x74],ESI",
            "MOV AL,byte ptr [ESI]",
            "CMP AL,BL",
            "JZ 0x000078b7",
            "CMP AL,0x20",
            "JBE 0x000078a9",
            "MOV dword ptr [EBP + -0x30],EBX",
            "LEA EAX,[EBP + -0x5c]",
            "PUSH EAX",
            "CALL dword ptr [0x004080c4]",
            "TEST byte ptr [EBP + -0x30],0x1",
            "JZ 0x000078db",
            "MOVZX EAX,word ptr [EBP + -0x2c]",
            "JMP 0x000078de",
            "CMP byte ptr [ESI],0x20",
            "JBE 0x000078ad",
            "INC ESI",
            "MOV dword ptr [EBP + -0x74],ESI",
            "JMP 0x000078d0",
            "PUSH 0xa",
            "POP EAX",
            "PUSH EAX",
            "PUSH ESI",
            "PUSH EBX",
            "PUSH EBX",
            "CALL dword ptr [0x004080a4]",
            "PUSH EAX",
            "CALL 0x00001fe7",
            "MOV dword ptr [EBP + -0x68],EAX",
            "PUSH EAX",
            "CALL dword ptr [0x004081a4]"
        ],
        "function_address": {
            "start": "000077ba",
            "end": "000078f7"
        },
        "variable_metadata": {
            "local_60": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000078ba"
                ],
                "type": "undefined"
            },
            "local_70": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00007856",
                    "00007859"
                ],
                "type": "undefined4"
            },
            "local_6c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000078ee"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000077dd"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000077e2"
                ],
                "type": "undefined4"
            },
            "local_64": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000786b"
                ],
                "type": "undefined"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000078ca"
                ],
                "type": "undefined2"
            },
            "local_74": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00007867"
                ],
                "type": "undefined"
            },
            "local_68": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00007863"
                ],
                "type": "undefined"
            },
            "local_34": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000078b7",
                    "000078c4"
                ],
                "type": "undefined4"
            },
            "local_78": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000788e",
                    "00007897",
                    "000078aa",
                    "000078d6"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "entry",
        "original_name": "entry",
        "predicted_name": "in the decompiled code",
        "prediction_full_response": "[PYTHON]\n\ndef get_predicted_function_name(decompiled_code):\n    # Check if the predicted function name is in the decompiled code\n    predicted_function_name = \"FUN_0000792a\"\n    if predicted_function_name in decompiled_code:\n        return predicted_function_name\n    else:\n        return None\n\n[/PYTHON]\n</s>"
    },
    "000031bc": {
        "decomp_code": "\nvoid __thiscall FUN_000031bc(int param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint uVar7;\n  undefined1 local_30 [16];\n  int local_20;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  int local_8;\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    uVar4 = ((uint)*param_2 << 0x18 | (uint)param_2[1] << 0x10 | (uint)param_2[2] << 8 |\n            (uint)param_2[3]) ^ *(uint *)(param_1 + 0x1e8);\n    local_14 = ((uint)param_2[4] << 0x18 | (uint)param_2[5] << 0x10 | (uint)param_2[6] << 8 |\n               (uint)param_2[7]) ^ *(uint *)(param_1 + 0x1ec);\n    local_10 = ((uint)param_2[8] << 0x18 | (uint)param_2[9] << 0x10 | (uint)param_2[10] << 8 |\n               (uint)param_2[0xb]) ^ *(uint *)(param_1 + 0x1f0);\n    iVar1 = *(int *)(param_1 + 0x410);\n    local_c = ((uint)CONCAT11(param_2[0xe],param_2[0xf]) |\n              (uint)param_2[0xc] << 0x18 | (uint)param_2[0xd] << 0x10) ^ *(uint *)(param_1 + 500);\n    if (1 < iVar1) {\n      puVar5 = (uint *)(param_1 + 0x210);\n      local_8 = iVar1 + -1;\n      do {\n        uVar7 = *(uint *)((local_c >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((local_14 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((uVar4 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_10 & 0xff) * 4 + 0x40a7fc) ^ puVar5[-1];\n        uVar3 = *(uint *)((local_10 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_14 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((uVar4 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((local_c & 0xff) * 4 + 0x40a7fc) ^ *puVar5;\n        uVar6 = *(uint *)((local_c >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_10 >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_14 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((uVar4 & 0xff) * 4 + 0x40a7fc) ^ puVar5[1];\n        uVar4 = *(uint *)((local_c >> 0x10 & 0xff) * 4 + 0x409ffc) ^\n                *(uint *)((local_10 >> 8 & 0xff) * 4 + 0x40a3fc) ^\n                *(uint *)((uVar4 >> 0x18) * 4 + 0x409bfc) ^\n                *(uint *)((local_14 & 0xff) * 4 + 0x40a7fc) ^ puVar5[-2];\n        puVar5 = puVar5 + 8;\n        local_8 = local_8 + -1;\n        local_14 = uVar7;\n        local_10 = uVar3;\n        local_c = uVar6;\n      } while (local_8 != 0);\n    }\n    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 0x1e8 + param_1);\n    param_1 = iVar1 * 0x20 + 0x1e8 + param_1;\n    *param_3 = *(byte *)((uVar4 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[1] = *(byte *)((local_c >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[2] = *(byte *)((local_10 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[3] = *(byte *)((local_14 & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 4);\n    param_3[4] = *(byte *)((local_14 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[5] = *(byte *)((uVar4 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[6] = *(byte *)((local_c >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[7] = *(byte *)((local_10 & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 8);\n    param_3[8] = *(byte *)((local_10 >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[9] = *(byte *)((local_14 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[10] = *(byte *)((uVar4 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xb] = *(byte *)((local_c & 0xff) + 0x408afc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 0xc);\n    param_3[0xc] = *(byte *)((local_c >> 0x18) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[0xd] = *(byte *)((local_10 >> 0x10 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[0xe] = *(byte *)((local_14 >> 8 & 0xff) + 0x408afc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xf] = *(byte *)((uVar4 & 0xff) + 0x408afc) ^ (byte)local_8;\n    return;\n  }\n  local_20 = param_1;\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_30,(ThrowInfo *)0x40d570);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x2c",
            "PUSH EDI",
            "MOV EDI,ECX",
            "MOV dword ptr [EBP + -0x1c],EDI",
            "CMP byte ptr [EDI + 0x4],0x0",
            "JNZ 0x000031ea",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0x2c]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x2c]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH EBX",
            "PUSH ESI",
            "MOVZX ECX,byte ptr [EAX]",
            "MOVZX EDX,byte ptr [EAX + 0x1]",
            "SHL ECX,0x18",
            "INC EAX",
            "SHL EDX,0x10",
            "OR ECX,EDX",
            "INC EAX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [EAX]",
            "OR ECX,EDX",
            "INC EAX",
            "MOVZX EDX,byte ptr [EAX]",
            "MOVZX ESI,byte ptr [EAX + 0x1]",
            "OR ECX,EDX",
            "INC EAX",
            "XOR ECX,dword ptr [EDI + 0x1e8]",
            "MOVZX EDX,byte ptr [EAX + 0x1]",
            "SHL ESI,0x18",
            "INC EAX",
            "MOV dword ptr [EBP + -0x14],ECX",
            "SHL EDX,0x10",
            "OR ESI,EDX",
            "INC EAX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [EAX]",
            "OR ESI,EDX",
            "INC EAX",
            "MOVZX EDX,byte ptr [EAX]",
            "OR ESI,EDX",
            "INC EAX",
            "XOR ESI,dword ptr [EDI + 0x1ec]",
            "MOVZX EDX,byte ptr [EAX + 0x1]",
            "MOV dword ptr [EBP + -0x10],ESI",
            "MOVZX ESI,byte ptr [EAX]",
            "SHL ESI,0x18",
            "INC EAX",
            "SHL EDX,0x10",
            "OR ESI,EDX",
            "INC EAX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [EAX]",
            "OR ESI,EDX",
            "INC EAX",
            "MOVZX EDX,byte ptr [EAX]",
            "OR ESI,EDX",
            "INC EAX",
            "XOR ESI,dword ptr [EDI + 0x1f0]",
            "MOVZX EDX,byte ptr [EAX + 0x1]",
            "MOV dword ptr [EBP + -0xc],ESI",
            "MOVZX ESI,byte ptr [EAX]",
            "SHL ESI,0x18",
            "INC EAX",
            "SHL EDX,0x10",
            "OR ESI,EDX",
            "INC EAX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [EAX]",
            "MOV DL,byte ptr [EAX + 0x1]",
            "MOV EAX,dword ptr [EDI + 0x410]",
            "OR EDX,ESI",
            "MOV dword ptr [EBP + -0x20],EAX",
            "XOR EDX,dword ptr [EDI + 0x1f4]",
            "CMP EAX,0x1",
            "MOV ESI,0xff",
            "MOV dword ptr [EBP + -0x8],EDX",
            "JLE 0x000033a3",
            "LEA EDX,[EDI + 0x210]",
            "DEC EAX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "MOV dword ptr [EBP + -0x4],EAX",
            "XOR EAX,EAX",
            "XOR EBX,EBX",
            "MOV AL,byte ptr [EBP + -0x7]",
            "MOV BL,byte ptr [EBP + -0xd]",
            "MOV EDI,dword ptr [EAX*0x4 + 0x40a3fc]",
            "XOR EAX,EAX",
            "XOR EDI,dword ptr [EBX*0x4 + 0x409bfc]",
            "MOV AL,byte ptr [EBP + -0x12]",
            "XOR EBX,EBX",
            "XOR EDI,dword ptr [EAX*0x4 + 0x409ffc]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "AND EAX,ESI",
            "MOV BL,byte ptr [EBP + -0xe]",
            "XOR EDI,dword ptr [EAX*0x4 + 0x40a7fc]",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EBP + -0x9]",
            "XOR EDI,dword ptr [EDX + -0x4]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x409bfc]",
            "XOR EAX,dword ptr [EBX*0x4 + 0x409ffc]",
            "XOR EBX,EBX",
            "MOV BL,CH",
            "AND ECX,ESI",
            "XOR EAX,dword ptr [EBX*0x4 + 0x40a3fc]",
            "MOV EBX,dword ptr [EBP + -0x8]",
            "AND EBX,ESI",
            "XOR EAX,dword ptr [EBX*0x4 + 0x40a7fc]",
            "XOR EBX,EBX",
            "MOV BL,byte ptr [EBP + -0xa]",
            "XOR EAX,dword ptr [EDX]",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x5]",
            "MOV EDX,dword ptr [EDX*0x4 + 0x409bfc]",
            "XOR EDX,dword ptr [EBX*0x4 + 0x409ffc]",
            "XOR EBX,EBX",
            "MOV BL,byte ptr [EBP + -0xf]",
            "MOV dword ptr [EBP + -0x18],EDX",
            "XOR EDX,dword ptr [EBX*0x4 + 0x40a3fc]",
            "XOR EDX,dword ptr [ECX*0x4 + 0x40a7fc]",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "XOR EDX,dword ptr [ECX + 0x4]",
            "XOR ECX,ECX",
            "MOV CL,byte ptr [EBP + -0x6]",
            "MOV dword ptr [EBP + -0x18],EDX",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xb]",
            "MOV ECX,dword ptr [ECX*0x4 + 0x409ffc]",
            "MOV dword ptr [EBP + -0xc],EAX",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "XOR ECX,dword ptr [EDX*0x4 + 0x40a3fc]",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x11]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "XOR ECX,dword ptr [EDX*0x4 + 0x409bfc]",
            "MOV EDX,dword ptr [EBP + -0x10]",
            "AND EDX,ESI",
            "MOV dword ptr [EBP + -0x10],EDI",
            "XOR ECX,dword ptr [EDX*0x4 + 0x40a7fc]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "XOR ECX,dword ptr [EDX + -0x8]",
            "ADD EDX,0x20",
            "DEC dword ptr [EBP + -0x4]",
            "MOV dword ptr [EBP + 0x8],EDX",
            "MOV dword ptr [EBP + -0x14],ECX",
            "JNZ 0x000032ac",
            "MOV EDI,dword ptr [EBP + -0x1c]",
            "MOV EAX,dword ptr [EBP + -0x20]",
            "SHL EAX,0x5",
            "MOV EDX,dword ptr [EAX + EDI*0x1 + 0x1e8]",
            "LEA EDI,[EAX + EDI*0x1 + 0x1e8]",
            "XOR EAX,EAX",
            "MOV EBX,EDX",
            "MOV AL,byte ptr [EBP + -0x11]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EBX,0x18",
            "MOV AL,byte ptr [EAX + 0x408afc]",
            "XOR AL,BL",
            "MOV BL,AL",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV byte ptr [EAX],BL",
            "XOR EBX,EBX",
            "MOV BL,byte ptr [EBP + -0x6]",
            "SAR EDX,0x10",
            "MOV BL,byte ptr [EBX + 0x408afc]",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xb]",
            "MOV byte ptr [EAX + 0x1],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "SAR EBX,0x8",
            "XOR DL,BL",
            "XOR EBX,EBX",
            "MOV byte ptr [EAX + 0x2],DL",
            "MOV EDX,dword ptr [EBP + -0x10]",
            "AND EDX,ESI",
            "MOV BL,byte ptr [EBP + -0xd]",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x3],DL",
            "MOV EDX,dword ptr [EDI + 0x4]",
            "MOV BL,byte ptr [EBX + 0x408afc]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EDX,0x18",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x12]",
            "MOV byte ptr [EAX + 0x4],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "SAR EBX,0x10",
            "XOR DL,BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x5],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x7]",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,BL",
            "XOR EBX,EBX",
            "MOV byte ptr [EAX + 0x6],DL",
            "MOV EDX,dword ptr [EBP + -0xc]",
            "AND EDX,ESI",
            "MOV BL,byte ptr [EBP + -0x9]",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x7],DL",
            "MOV EDX,dword ptr [EDI + 0x8]",
            "MOV BL,byte ptr [EBX + 0x408afc]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EDX,0x18",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xe]",
            "MOV byte ptr [EAX + 0x8],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "SAR EBX,0x10",
            "XOR DL,BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x9],DL",
            "XOR EDX,EDX",
            "MOV DL,CH",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,BL",
            "MOV byte ptr [EAX + 0xa],DL",
            "MOV EDX,dword ptr [EBP + -0x8]",
            "AND ECX,ESI",
            "AND EDX,ESI",
            "POP ESI",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0xb],DL",
            "MOV EDI,dword ptr [EDI + 0xc]",
            "XOR EDX,EDX",
            "MOV EBX,EDI",
            "MOV DL,byte ptr [EBP + -0x5]",
            "MOV dword ptr [EBP + -0x4],EDI",
            "SAR EBX,0x18",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,BL",
            "MOV EBX,EDI",
            "MOV byte ptr [EAX + 0xc],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xa]",
            "SAR EBX,0x10",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,BL",
            "MOV EBX,EDI",
            "MOV byte ptr [EAX + 0xd],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xf]",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x408afc]",
            "XOR DL,BL",
            "POP EBX",
            "MOV byte ptr [EAX + 0xe],DL",
            "MOV CL,byte ptr [ECX + 0x408afc]",
            "XOR CL,byte ptr [EBP + -0x4]",
            "POP EDI",
            "MOV byte ptr [EAX + 0xf],CL",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "000031bc",
            "end": "0000350e"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003296",
                    "00003304",
                    "0000336c",
                    "000034a4",
                    "000032b0",
                    "0000343e",
                    "00003348",
                    "000033d2",
                    "00003319",
                    "000034bf"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000332f",
                    "0000334b",
                    "0000335d"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000032a9",
                    "0000338e",
                    "000033bb",
                    "000033e8",
                    "00003409",
                    "00003418",
                    "00003428",
                    "00003436",
                    "0000345f",
                    "0000346e",
                    "0000347e",
                    "0000348c",
                    "000034b2",
                    "000034c2",
                    "00003504"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000321f",
                    "00003394",
                    "000032c6",
                    "00003422",
                    "00003369",
                    "000033b8"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003266",
                    "000032d2",
                    "0000335a",
                    "00003451",
                    "00003350",
                    "000033e2",
                    "00003312",
                    "000034d7",
                    "000032e3",
                    "00003456"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000031c5",
                    "0000339d"
                ],
                "type": "undefined4"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000031d3",
                    "000031dc"
                ],
                "type": "undefined"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000323f",
                    "00003376",
                    "0000337b",
                    "000033fb",
                    "0000332c",
                    "000034ec",
                    "000032d7",
                    "00003478",
                    "000032b3",
                    "00003400"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003285",
                    "000033a0"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000031bc",
        "original_name": "FUN_000031bc",
        "predicted_name": "decrypt_block.",
        "prediction_full_response": "The predicted function name is decrypt_block.</s>"
    },
    "00001064": {
        "decomp_code": "\nundefined4 FUN_00001064(undefined4 param_1,int param_2,int param_3)\n\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 local_58;\n  undefined4 local_54 [10];\n  undefined4 local_2c;\n  undefined2 local_28;\n  undefined4 local_14;\n  undefined4 local_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  \n  local_58 = 0x44;\n  puVar4 = local_54;\n  for (iVar3 = 0x10; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  local_14 = 0;\n  local_10 = 0;\n  uStack_c = 0;\n  uStack_8 = 0;\n  uVar2 = 1;\n  local_28 = 0;\n  local_2c = 1;\n  iVar3 = (*pcRam004080ec)(0,param_1,0,0,0,0x8000000,0,0,&local_58,&local_14);\n  if (iVar3 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    if (param_2 != 0) {\n      iVar3 = (*pcRam004080f4)(local_14,param_2);\n      if (iVar3 != 0) {\n        (*pcRam004080f8)(local_14,0xffffffff);\n      }\n      if (param_3 != 0) {\n        (*pcRam004080fc)(local_14,param_3);\n      }\n    }\n    pcVar1 = pcRam004080f0;\n    (*pcRam004080f0)(local_14);\n    (*pcVar1)(local_10);\n  }\n  return uVar2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x54",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH 0x10",
            "XOR EAX,EAX",
            "POP ECX",
            "LEA EDI,[EBP + -0x50]",
            "MOV dword ptr [EBP + -0x54],0x44",
            "XOR ESI,ESI",
            "STOSD.REP ES:EDI",
            "LEA EDI,[EBP + -0xc]",
            "MOV dword ptr [EBP + -0x10],ESI",
            "STOSD ES:EDI",
            "STOSD ES:EDI",
            "STOSD ES:EDI",
            "PUSH 0x1",
            "LEA EAX,[EBP + -0x10]",
            "POP EDI",
            "MOV word ptr [EBP + -0x24],SI",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x54]",
            "PUSH EAX",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH 0x8000000",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH ESI",
            "MOV dword ptr [EBP + -0x28],EDI",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH ESI",
            "CALL dword ptr [0x004080ec]",
            "TEST EAX,EAX",
            "JZ 0x000010f7",
            "CMP dword ptr [EBP + 0xc],ESI",
            "JZ 0x000010e3",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + -0x10]",
            "CALL dword ptr [0x004080f4]",
            "TEST EAX,EAX",
            "JZ 0x000010d2",
            "PUSH -0x1",
            "PUSH dword ptr [EBP + -0x10]",
            "CALL dword ptr [0x004080f8]",
            "CMP dword ptr [EBP + 0x10],ESI",
            "JZ 0x000010e3",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EBP + -0x10]",
            "CALL dword ptr [0x004080fc]",
            "PUSH dword ptr [EBP + -0x10]",
            "MOV ESI,dword ptr [0x004080f0]",
            "CALL ESI",
            "PUSH dword ptr [EBP + -0xc]",
            "CALL ESI",
            "MOV EAX,EDI",
            "JMP 0x000010f9",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001064",
            "end": "000010fc"
        },
        "variable_metadata": {
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000010a1"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000108e"
                ],
                "type": "undefined2"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000107f",
                    "000010ee"
                ],
                "type": "undefined4"
            },
            "local_54": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001071"
                ],
                "type": "undefined"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001082",
                    "0000108a",
                    "000010ba",
                    "000010c9",
                    "000010da",
                    "000010e3"
                ],
                "type": "undefined4"
            },
            "local_58": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001074",
                    "00001093"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00001064",
        "original_name": "FUN_00001064",
        "predicted_name": "\"sys_mmap\".",
        "prediction_full_response": "The predicted function name is \"sys_mmap\".</s>"
    },
    "000010fd": {
        "decomp_code": "\nundefined4 FUN_000010fd(int param_1)\n\n{\n  size_t sVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  bool bVar5;\n  undefined4 uVar6;\n  char local_2e0;\n  undefined4 local_2df;\n  undefined4 local_d8 [5];\n  undefined4 local_c4 [45];\n  undefined4 local_10;\n  int local_c;\n  int local_8;\n  \n  puVar3 = (undefined4 *)0x40e04c;\n  puVar4 = local_d8;\n  for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar4 = *puVar3;\n    puVar3 = puVar3 + 1;\n    puVar4 = puVar4 + 1;\n  }\n  local_2e0 = '\\0';\n  local_8 = 0;\n  puVar3 = local_c4;\n  for (iVar2 = 0x2d; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puVar3 = &local_2df;\n  for (iVar2 = 0x81; iVar2 != 0; iVar2 = iVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  *(undefined2 *)puVar3 = 0;\n  *(undefined1 *)((int)puVar3 + 2) = 0;\n  (*pcRam00408134)(local_d8,0x40e034);\n  local_c = 0;\n  do {\n    if (local_c == 0) {\n      uVar6 = 0x80000002;\n    }\n    else {\n      uVar6 = 0x80000001;\n    }\n    (*pcRam00408014)(uVar6,local_d8,&local_8);\n    if (local_8 != 0) {\n      if (param_1 == 0) {\n        local_10 = 0x207;\n        iVar2 = (*pcRam0040801c)(local_8,0x40e030,0,0,&local_2e0,&local_10);\n        bVar5 = iVar2 == 0;\n        if (bVar5) {\n          (*pcRam004080d8)(&local_2e0);\n        }\n      }\n      else {\n        (*pcRam004080d4)(0x207,&local_2e0);\n        sVar1 = strlen(&local_2e0);\n        iVar2 = (*pcRam00408018)(local_8,0x40e030,0,1,&local_2e0,sVar1 + 1);\n        bVar5 = iVar2 == 0;\n      }\n      (*pcRam00408020)(local_8);\n      if (bVar5) {\n        return 1;\n      }\n    }\n    local_c = local_c + 1;\n    if (1 < local_c) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x2dc",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH 0x5",
            "MOV ESI,0x40e04c",
            "POP ECX",
            "LEA EDI,[EBP + 0xffffff2c]",
            "MOVSD.REP ES:EDI,ESI",
            "PUSH 0x2d",
            "XOR EAX,EAX",
            "AND byte ptr [EBP + 0xfffffd24],AL",
            "POP ECX",
            "LEA EDI,[EBP + 0xffffff40]",
            "AND dword ptr [EBP + -0x4],0x0",
            "STOSD.REP ES:EDI",
            "MOV ECX,0x81",
            "LEA EDI,[EBP + 0xfffffd25]",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "STOSB ES:EDI",
            "LEA EAX,[EBP + 0xffffff2c]",
            "PUSH 0x40e034",
            "PUSH EAX",
            "CALL dword ptr [0x00408134]",
            "AND dword ptr [EBP + -0x8],0x0",
            "POP ECX",
            "POP ECX",
            "MOV EDI,0x40e030",
            "LEA EAX,[EBP + -0x4]",
            "XOR ESI,ESI",
            "CMP dword ptr [EBP + -0x8],ESI",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xffffff2c]",
            "PUSH EAX",
            "JNZ 0x00001175",
            "PUSH 0x80000002",
            "JMP 0x0000117a",
            "PUSH 0x80000001",
            "CALL dword ptr [0x00408014]",
            "CMP dword ptr [EBP + -0x4],ESI",
            "JZ 0x0000120d",
            "CMP dword ptr [EBP + 0x8],ESI",
            "JZ 0x000011cc",
            "LEA EAX,[EBP + 0xfffffd24]",
            "PUSH EAX",
            "PUSH 0x207",
            "CALL dword ptr [0x004080d4]",
            "LEA EAX,[EBP + 0xfffffd24]",
            "PUSH EAX",
            "CALL 0x000076b4",
            "POP ECX",
            "INC EAX",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd24]",
            "PUSH EAX",
            "PUSH 0x1",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [0x00408018]",
            "MOV ESI,EAX",
            "NEG ESI",
            "SBB ESI,ESI",
            "INC ESI",
            "JMP 0x00001200",
            "LEA EAX,[EBP + -0xc]",
            "MOV dword ptr [EBP + -0xc],0x207",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd24]",
            "PUSH EAX",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [0x0040801c]",
            "MOV ESI,EAX",
            "NEG ESI",
            "SBB ESI,ESI",
            "INC ESI",
            "JZ 0x00001200",
            "LEA EAX,[EBP + 0xfffffd24]",
            "PUSH EAX",
            "CALL dword ptr [0x004080d8]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [0x00408020]",
            "TEST ESI,ESI",
            "JNZ 0x00001220",
            "INC dword ptr [EBP + -0x8]",
            "CMP dword ptr [EBP + -0x8],0x2",
            "JL 0x0000115c",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x0000121c"
        ],
        "function_address": {
            "start": "000010fd",
            "end": "00001224"
        },
        "variable_metadata": {
            "local_d8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001110",
                    "0000113f",
                    "00001165"
                ],
                "type": "undefined"
            },
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001151",
                    "00001161",
                    "0000120d",
                    "00001210"
                ],
                "type": "undefined4"
            },
            "local_2e0": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000111c",
                    "0000118e",
                    "000011a0",
                    "000011af",
                    "000011d7",
                    "000011f3"
                ],
                "type": "undefined1"
            },
            "local_c4": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001123"
                ],
                "type": "undefined"
            },
            "local_2df": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001134"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001129",
                    "0000115c",
                    "00001180",
                    "000011ba",
                    "000011e1",
                    "00001200"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000011cc",
                    "000011cf"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000010fd",
        "original_name": "FUN_000010fd",
        "predicted_name": "\"get_device_info\".",
        "prediction_full_response": "The predicted function name is \"get_device_info\".</s>"
    },
    "00006191": {
        "decomp_code": "\nvoid FUN_00006191(uint param_1,int *param_2)\n\n{\n  param_2[3] = param_1 >> 0x10 & 0x1f;\n  param_2[5] = (param_1 >> 0x19) + 0x7bc;\n  param_2[2] = param_1 >> 0xb & 0x1f;\n  param_2[4] = (param_1 >> 0x15 & 0xf) - 1;\n  param_2[1] = param_1 >> 5 & 0x3f;\n  *param_2 = (param_1 & 0x1f) << 1;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EDX,dword ptr [ESP + 0x4]",
            "MOV ECX,dword ptr [ESP + 0x8]",
            "MOV EAX,EDX",
            "PUSH ESI",
            "SHR EAX,0x10",
            "MOV ESI,EAX",
            "AND ESI,0x1f",
            "MOV dword ptr [ECX + 0xc],ESI",
            "MOV ESI,EAX",
            "SHR EAX,0x9",
            "AND EAX,0x7f",
            "ADD EAX,0x7bc",
            "MOV dword ptr [ECX + 0x14],EAX",
            "MOV EAX,EDX",
            "SHR EAX,0xb",
            "AND EAX,0x1f",
            "SHR ESI,0x5",
            "MOV dword ptr [ECX + 0x8],EAX",
            "MOV EAX,EDX",
            "AND ESI,0xf",
            "AND EDX,0x1f",
            "SHR EAX,0x5",
            "DEC ESI",
            "AND EAX,0x3f",
            "SHL EDX,0x1",
            "MOV dword ptr [ECX + 0x10],ESI",
            "MOV dword ptr [ECX + 0x4],EAX",
            "MOV dword ptr [ECX],EDX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00006191",
            "end": "000061df"
        },
        "variable_metadata": {},
        "func_name": "FUN_00006191",
        "original_name": "FUN_00006191",
        "predicted_name": "decode_time",
        "prediction_full_response": "The predicted function name is decode_time</s>"
    },
    "00001eff": {
        "decomp_code": "\nundefined4 FUN_00001eff(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined1 local_68 [100];\n  \n  (*pcRam0040811c)(local_68,0x40f4ac,0x40f4b4,0);\n  iVar2 = 0;\n  if (0 < param_1) {\n    do {\n      iVar1 = (*pcRam00408080)(0x100000,1,local_68);\n      if (iVar1 != 0) {\n        (*pcRam004080f0)(iVar1);\n        return 1;\n      }\n      (*pcRam0040807c)(1000);\n      iVar2 = iVar2 + 1;\n    } while (iVar2 < param_1);\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x64",
            "PUSH ESI",
            "PUSH 0x0",
            "PUSH 0x40f4b4",
            "LEA EAX,[EBP + -0x64]",
            "PUSH 0x40f4ac",
            "PUSH EAX",
            "CALL dword ptr [0x0040811c]",
            "XOR ESI,ESI",
            "ADD ESP,0x10",
            "CMP dword ptr [EBP + 0x8],ESI",
            "JLE 0x00001f4c",
            "LEA EAX,[EBP + -0x64]",
            "PUSH EAX",
            "PUSH 0x1",
            "PUSH 0x100000",
            "CALL dword ptr [0x00408080]",
            "TEST EAX,EAX",
            "JNZ 0x00001f51",
            "PUSH 0x3e8",
            "CALL dword ptr [0x0040807c]",
            "INC ESI",
            "CMP ESI,dword ptr [EBP + 0x8]",
            "JL 0x00001f26",
            "XOR EAX,EAX",
            "POP ESI",
            "LEAVE",
            "RET",
            "PUSH EAX",
            "CALL dword ptr [0x004080f0]",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x00001f4e"
        ],
        "function_address": {
            "start": "00001eff",
            "end": "00001f5c"
        },
        "variable_metadata": {
            "local_68": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001f0d",
                    "00001f26"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00001eff",
        "original_name": "FUN_00001eff",
        "predicted_name": "delay_ms.",
        "prediction_full_response": "The predicted function name is delay_ms.</s>"
    },
    "000076a8": {
        "decomp_code": "\nchar * __cdecl strcpy(char *_Dest,char *_Source)\n\n{\n  char *pcVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076a8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pcVar1 = (char *)(*pcRam00408128)();\n  return pcVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408128]"
        ],
        "function_address": {
            "start": "000076a8",
            "end": "000076ad"
        },
        "variable_metadata": {
            "_Dest": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            },
            "_Source": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            }
        },
        "func_name": "strcpy",
        "original_name": "strcpy",
        "predicted_name": "strcpy",
        "prediction_full_response": "The predicted function name is strcpy</s>"
    },
    "00004c19": {
        "decomp_code": "\nundefined4\nFUN_00004c19(int *param_1,uint param_2,uint param_3,int param_4,int param_5,int *param_6,\n            uint *param_7,int param_8,uint *param_9,uint *param_10)\n\n{\n  undefined4 uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint *puVar6;\n  int *piVar7;\n  int iVar8;\n  uint uVar9;\n  undefined4 *puVar10;\n  byte bVar11;\n  int iVar12;\n  uint uVar13;\n  uint *puVar14;\n  int local_f4 [15];\n  uint local_b8 [16];\n  uint local_78 [19];\n  undefined4 local_2c;\n  uint local_28;\n  uint *local_24;\n  int local_20;\n  uint local_1c;\n  uint local_18;\n  uint *local_14;\n  uint local_10;\n  int local_c;\n  uint local_8;\n  \n  puVar6 = param_7;\n  local_78[0] = 0;\n  local_78[1] = 0;\n  local_78[2] = 0;\n  local_78[3] = 0;\n  local_78[4] = 0;\n  local_78[5] = 0;\n  local_78[6] = 0;\n  local_78[7] = 0;\n  local_78[8] = 0;\n  local_78[9] = 0;\n  local_78[10] = 0;\n  local_78[0xb] = 0;\n  local_78[0xc] = 0;\n  local_78[0xd] = 0;\n  local_78[0xe] = 0;\n  local_78[0xf] = 0;\n  piVar7 = param_1;\n  uVar13 = param_2;\n  do {\n    iVar12 = *piVar7;\n    piVar7 = piVar7 + 1;\n    local_78[iVar12] = local_78[iVar12] + 1;\n    uVar13 = uVar13 - 1;\n  } while (uVar13 != 0);\n  if (local_78[0] == param_2) {\n    *param_6 = 0;\n    *param_7 = 0;\n  }\n  else {\n    uVar13 = 1;\n    puVar14 = local_78;\n    param_7 = (uint *)*param_7;\n    do {\n      puVar14 = puVar14 + 1;\n      if (*puVar14 != 0) break;\n      uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x10);\n    local_8 = uVar13;\n    if (param_7 < uVar13) {\n      param_7 = (uint *)uVar13;\n    }\n    puVar14 = local_78 + 0xf;\n    uVar2 = 0xf;\n    do {\n      if (*puVar14 != 0) break;\n      uVar2 = uVar2 - 1;\n      puVar14 = puVar14 + -1;\n    } while (uVar2 != 0);\n    local_1c = uVar2;\n    if (uVar2 < param_7) {\n      param_7 = (uint *)uVar2;\n    }\n    iVar12 = 1 << ((byte)uVar13 & 0x1f);\n    *puVar6 = (uint)param_7;\n    if (uVar13 < uVar2) {\n      puVar6 = local_78 + uVar13;\n      do {\n        uVar3 = *puVar6;\n        if ((int)(iVar12 - uVar3) < 0) {\n          return 0xfffffffd;\n        }\n        uVar13 = uVar13 + 1;\n        puVar6 = puVar6 + 1;\n        iVar12 = (iVar12 - uVar3) * 2;\n      } while (uVar13 < uVar2);\n    }\n    local_78[0x11] = iVar12 - local_78[uVar2];\n    if ((int)local_78[0x11] < 0) {\n      return 0xfffffffd;\n    }\n    local_b8[1] = 0;\n    local_78[uVar2] = local_78[uVar2] + local_78[0x11];\n    iVar8 = 0;\n    iVar12 = uVar2 - 1;\n    if (iVar12 != 0) {\n      iVar4 = 0;\n      do {\n        iVar8 = iVar8 + *(int *)((int)local_78 + iVar4 + 4);\n        iVar12 = iVar12 + -1;\n        *(int *)((int)local_b8 + iVar4 + 8) = iVar8;\n        iVar4 = iVar4 + 4;\n      } while (iVar12 != 0);\n    }\n    uVar13 = 0;\n    do {\n      iVar12 = *param_1;\n      param_1 = param_1 + 1;\n      if (iVar12 != 0) {\n        uVar3 = local_b8[iVar12];\n        param_10[uVar3] = uVar13;\n        local_b8[iVar12] = uVar3 + 1;\n      }\n      uVar13 = uVar13 + 1;\n    } while (uVar13 < param_2);\n    uVar13 = local_b8[uVar2];\n    local_c = -1;\n    local_10 = 0;\n    local_14 = param_10;\n    iVar12 = -(int)param_7;\n    local_b8[0] = 0;\n    local_f4[0] = 0;\n    local_20 = 0;\n    param_1 = (int *)0x0;\n    if ((int)local_8 <= (int)local_1c) {\n      local_78[0x12] = local_8 - 1;\n      local_24 = local_78 + local_8;\n      uVar2 = local_28;\n      do {\n        uVar3 = *local_24;\n        local_18 = uVar3 - 1;\n        uVar1 = local_2c;\n        while (uVar3 != 0) {\n          local_2c._2_2_ = (undefined2)((uint)uVar1 >> 0x10);\n          local_78[0x10] = (int)param_7 + iVar12;\n          if ((int)local_78[0x10] < (int)local_8) {\n            do {\n              local_2c = uVar1;\n              iVar8 = local_c;\n              local_c = local_c + 1;\n              iVar12 = iVar12 + (int)param_7;\n              local_78[0x10] = local_78[0x10] + (int)param_7;\n              param_1 = (int *)(local_1c - iVar12);\n              if (param_7 < param_1) {\n                param_1 = (int *)param_7;\n              }\n              uVar9 = local_8 - iVar12;\n              uVar3 = 1 << ((byte)uVar9 & 0x1f);\n              if ((local_18 + 1 < uVar3) &&\n                 (iVar4 = uVar3 + (-1 - local_18), puVar6 = local_24, uVar9 < param_1)) {\n                while (uVar9 = uVar9 + 1, uVar9 < param_1) {\n                  uVar3 = puVar6[1];\n                  puVar6 = puVar6 + 1;\n                  uVar5 = iVar4 * 2;\n                  if (uVar5 < uVar3 || uVar5 - uVar3 == 0) break;\n                  iVar4 = uVar5 - uVar3;\n                }\n              }\n              param_1 = (int *)(1 << ((byte)uVar9 & 0x1f));\n              uVar3 = *param_9 + (int)param_1;\n              if (0x5a0 < uVar3) {\n                return 0xfffffffd;\n              }\n              local_20 = param_8 + *param_9 * 8;\n              local_f4[local_c] = local_20;\n              uVar5 = local_10;\n              iVar4 = local_20;\n              *param_9 = uVar3;\n              if (local_c == 0) {\n                *param_6 = local_20;\n              }\n              else {\n                local_b8[local_c] = local_10;\n                local_2c._0_2_ = CONCAT11((char)param_7,(byte)uVar9);\n                uVar5 = uVar5 >> ((char)iVar12 - (char)param_7 & 0x1fU);\n                iVar8 = local_f4[iVar8];\n                uVar2 = (iVar4 - iVar8 >> 3) - uVar5;\n                *(undefined4 *)(iVar8 + uVar5 * 8) = local_2c;\n                *(uint *)(iVar8 + 4 + uVar5 * 8) = uVar2;\n              }\n              uVar1 = local_2c;\n            } while ((int)local_78[0x10] < (int)local_8);\n          }\n          uVar3 = local_18;\n          bVar11 = (byte)iVar12;\n          if (local_14 < param_10 + uVar13) {\n            uVar2 = *local_14;\n            if (uVar2 < param_3) {\n              local_2c._0_1_ = (-(uVar2 < 0x100) & 0xa0U) + 0x60;\n            }\n            else {\n              iVar8 = (uVar2 - param_3) * 4;\n              local_2c._0_1_ = *(char *)(iVar8 + param_5) + 'P';\n              uVar2 = *(uint *)(iVar8 + param_4);\n            }\n            local_14 = local_14 + 1;\n          }\n          else {\n            local_2c._0_1_ = -0x40;\n          }\n          local_2c = CONCAT31(CONCAT21(local_2c._2_2_,(char)local_8 - bVar11),(char)local_2c);\n          iVar8 = 1 << ((char)local_8 - bVar11 & 0x1f);\n          uVar9 = local_10 >> (bVar11 & 0x1f);\n          if (uVar9 < param_1) {\n            puVar10 = (undefined4 *)(local_20 + uVar9 * 8);\n            do {\n              uVar9 = uVar9 + iVar8;\n              *puVar10 = local_2c;\n              puVar10[1] = uVar2;\n              puVar10 = puVar10 + iVar8 * 2;\n            } while (uVar9 < param_1);\n          }\n          uVar9 = 1 << ((byte)local_78[0x12] & 0x1f);\n          while ((local_10 & uVar9) != 0) {\n            local_10 = local_10 ^ uVar9;\n            uVar9 = uVar9 >> 1;\n          }\n          local_10 = local_10 ^ uVar9;\n          for (puVar6 = local_b8 + local_c;\n              ((1 << ((byte)iVar12 & 0x1f)) - 1U & local_10) != *puVar6; puVar6 = puVar6 + -1) {\n            local_c = local_c + -1;\n            iVar12 = iVar12 - (int)param_7;\n          }\n          local_18 = local_18 - 1;\n          uVar1 = local_2c;\n        }\n        local_8 = local_8 + 1;\n        local_24 = local_24 + 1;\n        local_78[0x12] = local_78[0x12] + 1;\n        local_2c = uVar1;\n      } while ((int)local_8 <= (int)local_1c);\n    }\n    if ((local_78[0x11] != 0) && (local_1c != 1)) {\n      return 0xfffffffb;\n    }\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xf0",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "XOR EDX,EDX",
            "MOV dword ptr [EBP + -0x74],EDX",
            "MOV dword ptr [EBP + -0x70],EDX",
            "MOV dword ptr [EBP + -0x6c],EDX",
            "MOV dword ptr [EBP + -0x68],EDX",
            "MOV dword ptr [EBP + -0x64],EDX",
            "MOV dword ptr [EBP + -0x60],EDX",
            "MOV dword ptr [EBP + -0x5c],EDX",
            "MOV dword ptr [EBP + -0x58],EDX",
            "MOV dword ptr [EBP + -0x54],EDX",
            "MOV dword ptr [EBP + -0x50],EDX",
            "MOV dword ptr [EBP + -0x4c],EDX",
            "MOV dword ptr [EBP + -0x48],EDX",
            "MOV dword ptr [EBP + -0x44],EDX",
            "MOV dword ptr [EBP + -0x40],EDX",
            "MOV dword ptr [EBP + -0x3c],EDX",
            "MOV dword ptr [EBP + -0x38],EDX",
            "MOV ESI,EDI",
            "MOV EAX,dword ptr [ECX]",
            "ADD ECX,0x4",
            "INC dword ptr [EBP + EAX*0x4 + -0x74]",
            "LEA EAX,[EBP + EAX*0x4 + -0x74]",
            "DEC ESI",
            "JNZ 0x00004c5f",
            "CMP dword ptr [EBP + -0x74],EDI",
            "JNZ 0x00004c85",
            "MOV EAX,dword ptr [EBP + 0x1c]",
            "MOV dword ptr [EAX],EDX",
            "MOV EAX,dword ptr [EBP + 0x20]",
            "MOV dword ptr [EAX],EDX",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET",
            "MOV EDI,dword ptr [EBP + 0x20]",
            "PUSH 0x1",
            "POP EBX",
            "LEA EAX,[EBP + -0x70]",
            "MOV ESI,dword ptr [EDI]",
            "MOV ECX,EBX",
            "MOV dword ptr [EBP + 0x20],ESI",
            "CMP dword ptr [EAX],EDX",
            "JNZ 0x00004ca2",
            "INC ECX",
            "ADD EAX,0x4",
            "CMP ECX,0xf",
            "JBE 0x00004c95",
            "CMP ESI,ECX",
            "MOV dword ptr [EBP + -0x4],ECX",
            "JNC 0x00004cac",
            "MOV dword ptr [EBP + 0x20],ECX",
            "PUSH 0xf",
            "LEA ESI,[EBP + -0x38]",
            "POP EAX",
            "CMP dword ptr [ESI],EDX",
            "JNZ 0x00004cbe",
            "DEC EAX",
            "SUB ESI,0x4",
            "CMP EAX,EDX",
            "JNZ 0x00004cb2",
            "CMP dword ptr [EBP + 0x20],EAX",
            "MOV dword ptr [EBP + -0x18],EAX",
            "JBE 0x00004cc9",
            "MOV dword ptr [EBP + 0x20],EAX",
            "MOV ESI,dword ptr [EBP + 0x20]",
            "SHL EBX,CL",
            "CMP ECX,EAX",
            "MOV dword ptr [EDI],ESI",
            "JNC 0x00004cea",
            "LEA ESI,[EBP + ECX*0x4 + -0x74]",
            "SUB EBX,dword ptr [ESI]",
            "JS 0x00004e10",
            "INC ECX",
            "ADD ESI,0x4",
            "SHL EBX,0x1",
            "CMP ECX,EAX",
            "JC 0x00004cd8",
            "MOV ESI,EAX",
            "SHL ESI,0x2",
            "MOV EDI,dword ptr [EBP + ESI*0x1 + -0x74]",
            "LEA ECX,[EBP + ESI*0x1 + -0x74]",
            "SUB EBX,EDI",
            "MOV dword ptr [EBP + -0x30],EBX",
            "JS 0x00004e10",
            "ADD EDI,EBX",
            "MOV dword ptr [EBP + 0xffffff50],EDX",
            "MOV dword ptr [ECX],EDI",
            "XOR ECX,ECX",
            "DEC EAX",
            "JZ 0x00004d24",
            "XOR EDI,EDI",
            "ADD ECX,dword ptr [EBP + EDI*0x1 + -0x70]",
            "ADD EDI,0x4",
            "DEC EAX",
            "MOV dword ptr [EBP + EDI*0x1 + 0xffffff50],ECX",
            "JNZ 0x00004d13",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "XOR EDI,EDI",
            "MOV EAX,dword ptr [EBX]",
            "ADD EBX,0x4",
            "CMP EAX,EDX",
            "JZ 0x00004d4b",
            "MOV ECX,dword ptr [EBP + EAX*0x4 + 0xffffff4c]",
            "MOV EDX,dword ptr [EBP + 0x2c]",
            "LEA EAX,[EBP + EAX*0x4 + 0xffffff4c]",
            "MOV dword ptr [EDX + ECX*0x4],EDI",
            "INC ECX",
            "MOV dword ptr [EAX],ECX",
            "XOR EDX,EDX",
            "INC EDI",
            "CMP EDI,dword ptr [EBP + 0xc]",
            "JC 0x00004d29",
            "MOV EAX,dword ptr [EBP + ESI*0x1 + 0xffffff4c]",
            "MOV EBX,dword ptr [EBP + 0x20]",
            "OR dword ptr [EBP + -0x8],0xffffffff",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [EBP + 0x2c]",
            "MOV dword ptr [EBP + -0xc],EDX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "NEG EBX",
            "CMP EAX,dword ptr [EBP + -0x18]",
            "MOV dword ptr [EBP + 0xffffff4c],EDX",
            "MOV dword ptr [EBP + 0xffffff10],EDX",
            "MOV dword ptr [EBP + -0x1c],EDX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "JG 0x00004f85",
            "MOV EDI,dword ptr [EBP + -0x24]",
            "LEA ECX,[EAX + -0x1]",
            "LEA EAX,[EBP + EAX*0x4 + -0x74]",
            "MOV dword ptr [EBP + -0x2c],ECX",
            "MOV dword ptr [EBP + -0x20],EAX",
            "MOV EAX,dword ptr [EBP + -0x20]",
            "MOV EAX,dword ptr [EAX]",
            "MOV ECX,EAX",
            "DEC EAX",
            "TEST ECX,ECX",
            "MOV dword ptr [EBP + -0x14],EAX",
            "JZ 0x00004f6f",
            "MOV EAX,dword ptr [EBP + 0x20]",
            "ADD EAX,EBX",
            "CMP dword ptr [EBP + -0x4],EAX",
            "JLE 0x00004e9a",
            "MOV ECX,dword ptr [EBP + 0x20]",
            "INC dword ptr [EBP + -0x8]",
            "ADD EAX,ECX",
            "ADD EBX,ECX",
            "MOV dword ptr [EBP + -0x34],EAX",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "SUB EAX,EBX",
            "CMP EAX,ECX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JBE 0x00004dd8",
            "MOV dword ptr [EBP + 0x8],ECX",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV EDX,dword ptr [EBP + -0x14]",
            "PUSH 0x1",
            "SUB ECX,EBX",
            "POP EAX",
            "SHL EAX,CL",
            "INC EDX",
            "CMP EAX,EDX",
            "JBE 0x00004e17",
            "MOV ESI,dword ptr [EBP + -0x20]",
            "OR EDX,0xffffffff",
            "SUB EDX,dword ptr [EBP + -0x14]",
            "ADD EAX,EDX",
            "CMP ECX,dword ptr [EBP + 0x8]",
            "JNC 0x00004e17",
            "INC ECX",
            "CMP ECX,dword ptr [EBP + 0x8]",
            "JNC 0x00004e17",
            "MOV EDX,dword ptr [ESI + 0x4]",
            "ADD ESI,0x4",
            "SHL EAX,0x1",
            "CMP EAX,EDX",
            "JBE 0x00004e17",
            "SUB EAX,EDX",
            "JMP 0x00004dfa",
            "PUSH -0x3",
            "JMP 0x00004f9a",
            "MOV EAX,dword ptr [EBP + 0x28]",
            "PUSH 0x1",
            "POP EDX",
            "MOV EAX,dword ptr [EAX]",
            "SHL EDX,CL",
            "MOV dword ptr [EBP + 0x8],EDX",
            "LEA ESI,[EAX + EDX*0x1]",
            "CMP ESI,0x5a0",
            "JA 0x00004e10",
            "MOV EDX,dword ptr [EBP + 0x24]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV EDX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [EBP + -0x1c],EAX",
            "LEA EDX,[EBP + EDX*0x4 + 0xffffff10]",
            "MOV dword ptr [EDX],EAX",
            "MOV EAX,dword ptr [EBP + 0x28]",
            "MOV dword ptr [EAX],ESI",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "TEST EAX,EAX",
            "JZ 0x00004e84",
            "MOV ESI,dword ptr [EBP + -0xc]",
            "MOV EDI,dword ptr [EBP + -0x1c]",
            "MOV dword ptr [EBP + EAX*0x4 + 0xffffff4c],ESI",
            "MOV EAX,dword ptr [EBP + 0x20]",
            "MOV byte ptr [EBP + -0x28],CL",
            "MOV ECX,EBX",
            "MOV byte ptr [EBP + -0x27],AL",
            "SUB ECX,EAX",
            "MOV EAX,ESI",
            "SHR EAX,CL",
            "MOV ECX,dword ptr [EDX + -0x4]",
            "MOV EDX,dword ptr [EBP + -0x28]",
            "SUB EDI,ECX",
            "SAR EDI,0x3",
            "SUB EDI,EAX",
            "MOV dword ptr [ECX + EAX*0x8],EDX",
            "MOV dword ptr [ECX + EAX*0x8 + 0x4],EDI",
            "JMP 0x00004e8c",
            "MOV EAX,dword ptr [EBP + 0x1c]",
            "MOV ECX,dword ptr [EBP + -0x1c]",
            "MOV dword ptr [EAX],ECX",
            "MOV EAX,dword ptr [EBP + -0x34]",
            "CMP dword ptr [EBP + -0x4],EAX",
            "JG 0x00004dbc",
            "XOR EDX,EDX",
            "MOV AL,byte ptr [EBP + -0x4]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "SUB AL,BL",
            "MOV byte ptr [EBP + -0x27],AL",
            "MOV EAX,dword ptr [EBP + 0x2c]",
            "LEA ECX,[EAX + ECX*0x4]",
            "MOV EAX,dword ptr [EBP + -0x10]",
            "CMP EAX,ECX",
            "JC 0x00004eb8",
            "MOV byte ptr [EBP + -0x28],0xc0",
            "JMP 0x00004eef",
            "MOV EAX,dword ptr [EAX]",
            "CMP EAX,dword ptr [EBP + 0x10]",
            "JNC 0x00004ed3",
            "CMP EAX,0x100",
            "MOV EDI,EAX",
            "SBB CL,CL",
            "AND CL,0xa0",
            "ADD CL,0x60",
            "MOV byte ptr [EBP + -0x28],CL",
            "JMP 0x00004eeb",
            "SUB EAX,dword ptr [EBP + 0x10]",
            "MOV ECX,dword ptr [EBP + 0x18]",
            "SHL EAX,0x2",
            "MOV CL,byte ptr [EAX + ECX*0x1]",
            "ADD CL,0x50",
            "MOV byte ptr [EBP + -0x28],CL",
            "MOV ECX,dword ptr [EBP + 0x14]",
            "MOV EDI,dword ptr [EAX + ECX*0x1]",
            "ADD dword ptr [EBP + -0x10],0x4",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "PUSH 0x1",
            "SUB ECX,EBX",
            "POP ESI",
            "SHL ESI,CL",
            "MOV ECX,EBX",
            "SHR EAX,CL",
            "CMP EAX,dword ptr [EBP + 0x8]",
            "JNC 0x00004f23",
            "MOV ECX,dword ptr [EBP + -0x1c]",
            "LEA ECX,[ECX + EAX*0x8]",
            "MOV EDX,dword ptr [EBP + -0x28]",
            "ADD EAX,ESI",
            "MOV dword ptr [ECX],EDX",
            "MOV EDX,ESI",
            "SHL EDX,0x3",
            "MOV dword ptr [ECX + 0x4],EDI",
            "ADD ECX,EDX",
            "CMP EAX,dword ptr [EBP + 0x8]",
            "JC 0x00004f0b",
            "XOR EDX,EDX",
            "MOV ECX,dword ptr [EBP + -0x2c]",
            "PUSH 0x1",
            "POP EAX",
            "SHL EAX,CL",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "TEST ECX,EAX",
            "JZ 0x00004f38",
            "XOR ECX,EAX",
            "SHR EAX,0x1",
            "JMP 0x00004f2e",
            "XOR ECX,EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [EBP + -0xc],ECX",
            "LEA EAX,[EBP + EAX*0x4 + 0xffffff4c]",
            "PUSH 0x1",
            "MOV ECX,EBX",
            "POP ESI",
            "SHL ESI,CL",
            "DEC ESI",
            "AND ESI,dword ptr [EBP + -0xc]",
            "CMP ESI,dword ptr [EAX]",
            "JZ 0x00004f61",
            "DEC dword ptr [EBP + -0x8]",
            "SUB EAX,0x4",
            "SUB EBX,dword ptr [EBP + 0x20]",
            "JMP 0x00004f47",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "DEC dword ptr [EBP + -0x14]",
            "TEST EAX,EAX",
            "JNZ 0x00004dae",
            "INC dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + -0x20],0x4",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "INC dword ptr [EBP + -0x2c]",
            "CMP EAX,dword ptr [EBP + -0x18]",
            "JLE 0x00004d9b",
            "CMP dword ptr [EBP + -0x30],EDX",
            "JZ 0x00004c7e",
            "CMP dword ptr [EBP + -0x18],0x1",
            "JZ 0x00004c7e",
            "PUSH -0x5",
            "POP EAX",
            "JMP 0x00004c80"
        ],
        "function_address": {
            "start": "00004c19",
            "end": "00004f9f"
        },
        "variable_metadata": {
            "local_60": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c3f"
                ],
                "type": "undefined4"
            },
            "local_4c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c4e"
                ],
                "type": "undefined4"
            },
            "local_6c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c36",
                    "00004cd4",
                    "00004cd8",
                    "00004d91",
                    "00004d9e"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004e60",
                    "00004e71",
                    "00004eb2",
                    "00004ece",
                    "00004ee2",
                    "00004f0b",
                    "00004e65",
                    "00004ea2"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004ca4",
                    "00004d6b",
                    "00004db3",
                    "00004dd8",
                    "00004e8f",
                    "00004e9a",
                    "00004eef",
                    "00004f6f",
                    "00004f76"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d8b"
                ],
                "type": "undefined4"
            },
            "local_48": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c51"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d7f",
                    "00004e38",
                    "00004e53",
                    "00004e87",
                    "00004f05"
                ],
                "type": "undefined4"
            },
            "local_64": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c3c"
                ],
                "type": "undefined4"
            },
            "local_40": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c57"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d98",
                    "00004d9b",
                    "00004dea",
                    "00004f72"
                ],
                "type": "undefined4"
            },
            "local_68": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c39",
                    "00004e00"
                ],
                "type": "undefined4"
            },
            "local_44": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c54",
                    "00004cf3",
                    "00004d0a"
                ],
                "type": "undefined4"
            },
            "local_b8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d73"
                ],
                "type": "undefined4"
            },
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d5b",
                    "00004dbf",
                    "00004e35",
                    "00004e49",
                    "00004f3a",
                    "00004f56"
                ],
                "type": "undefined4"
            },
            "local_50": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c4b"
                ],
                "type": "undefined4"
            },
            "local_70": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c33"
                ],
                "type": "undefined4"
            },
            "local_5c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c42"
                ],
                "type": "undefined4"
            },
            "local_f4": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d79"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004cc1",
                    "00004d70",
                    "00004dc9",
                    "00004f7c",
                    "00004f8e"
                ],
                "type": "undefined4"
            },
            "local_b4": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d04"
                ],
                "type": "undefined4"
            },
            "local_3c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c5a",
                    "00004cae",
                    "00004cb2"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004da5",
                    "00004ddb",
                    "00004df0",
                    "00004f61",
                    "00004f64"
                ],
                "type": "undefined4"
            },
            "local_38": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004dc6",
                    "00004e8c"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d65",
                    "00004e50",
                    "00004ef2",
                    "00004f2b",
                    "00004f3d",
                    "00004f4f"
                ],
                "type": "undefined4"
            },
            "local_54": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c48"
                ],
                "type": "undefined4"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d95",
                    "00004f23",
                    "00004f79"
                ],
                "type": "undefined4"
            },
            "local_74": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c30",
                    "00004c8b",
                    "00004c95"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004d68",
                    "00004eab",
                    "00004eeb"
                ],
                "type": "undefined4"
            },
            "local_58": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c45"
                ],
                "type": "undefined4"
            },
            "local_34": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004cf9",
                    "00004f85"
                ],
                "type": "undefined4"
            },
            "local_78": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004c2d",
                    "00004c6f"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00004c19",
        "original_name": "FUN_00004c19",
        "predicted_name": "\"inflate_table\".",
        "prediction_full_response": "The predicted function name is \"inflate_table\".</s>"
    },
    "00005e27": {
        "decomp_code": "\nvoid FUN_00005e27(undefined4 param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int local_8;\n  \n  iVar2 = FUN_00005def(param_1,&local_8);\n  iVar1 = local_8;\n  if ((iVar2 == 0) && (iVar2 = FUN_00005def(param_1,&local_8), iVar2 == 0)) {\n    *param_2 = local_8 * 0x100 + iVar1;\n    return;\n  }\n  *param_2 = 0;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "LEA EAX,[EBP + -0x4]",
            "PUSH ESI",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005def",
            "MOV ESI,dword ptr [EBP + -0x4]",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00005e62",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005def",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00005e62",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV EDX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x8",
            "ADD ECX,ESI",
            "MOV dword ptr [EDX],ECX",
            "JMP 0x00005e68",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "AND dword ptr [ECX],0x0",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00005e27",
            "end": "00005e6a"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005e2b",
                    "00005e38",
                    "00005e41",
                    "00005e53"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00005e27",
        "original_name": "FUN_00005e27",
        "predicted_name": "get_version_number.",
        "prediction_full_response": "The predicted function name is get_version_number.</s>"
    },
    "000017dd": {
        "decomp_code": "\nundefined4 * __fastcall FUN_000017dd(undefined4 *param_1)\n\n{\n  param_1[1] = 0;\n  param_1[2] = 0;\n  param_1[3] = 0;\n  *param_1 = 0x4081ec;\n  (*pcRam00408038)(param_1 + 4);\n  return param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "XOR EAX,EAX",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV dword ptr [ESI + 0x8],EAX",
            "MOV dword ptr [ESI + 0xc],EAX",
            "LEA EAX,[ESI + 0x10]",
            "PUSH EAX",
            "MOV dword ptr [ESI],0x4081ec",
            "CALL dword ptr [0x00408038]",
            "MOV EAX,ESI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "000017dd",
            "end": "000017fe"
        },
        "variable_metadata": {},
        "func_name": "FUN_000017dd",
        "original_name": "FUN_000017dd",
        "predicted_name": "init_ram_code",
        "prediction_full_response": "The predicted function name is init_ram_code</s>"
    },
    "00001225": {
        "decomp_code": "\nvoid FUN_00001225(int param_1)\n\n{\n  code *pcVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  undefined4 *puVar6;\n  ushort *puVar7;\n  int iVar8;\n  ushort local_19c;\n  undefined4 local_19a [99];\n  undefined4 local_c;\n  uint local_8;\n  \n  local_19c = uRam0040f874;\n  local_c = 399;\n  puVar6 = local_19a;\n  for (iVar5 = 99; iVar5 != 0; iVar5 = iVar5 + -1) {\n    *puVar6 = 0;\n    puVar6 = puVar6 + 1;\n  }\n  *(undefined2 *)puVar6 = 0;\n  (*pcRam004080d0)(&local_19c,&local_c);\n  pcVar1 = pcRam00408138;\n  local_8 = 0;\n  iVar5 = 1;\n  iVar2 = (*pcRam00408138)(&local_19c);\n  if (iVar2 != 0) {\n    puVar7 = &local_19c;\n    do {\n      iVar5 = iVar5 * (uint)*puVar7;\n      local_8 = local_8 + 1;\n      puVar7 = puVar7 + 1;\n      uVar3 = (*pcVar1)(&local_19c);\n    } while (local_8 < uVar3);\n  }\n  (*pcRam00408124)(iVar5);\n  pcVar1 = pcRam00408120;\n  iVar5 = (*pcRam00408120)();\n  iVar8 = 0;\n  iVar2 = iVar5 % 8 + 8;\n  if (0 < iVar2) {\n    do {\n      iVar4 = (*pcVar1)();\n      *(char *)(iVar8 + param_1) = (char)(iVar4 % 0x1a) + 'a';\n      iVar8 = iVar8 + 1;\n    } while (iVar8 < iVar2);\n  }\n  for (; iVar8 < iVar5 % 8 + 0xb; iVar8 = iVar8 + 1) {\n    iVar2 = (*pcVar1)();\n    *(char *)(iVar8 + param_1) = (char)(iVar2 % 10) + '0';\n  }\n  *(undefined1 *)(iVar8 + param_1) = 0;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x198",
            "MOV AX,[0x0040f874]",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH 0x63",
            "MOV word ptr [EBP + 0xfffffe68],AX",
            "POP ECX",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffe6a]",
            "MOV dword ptr [EBP + -0x8],0x18f",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffe68]",
            "PUSH EAX",
            "CALL dword ptr [0x004080d0]",
            "MOV ESI,dword ptr [0x00408138]",
            "AND dword ptr [EBP + -0x4],0x0",
            "PUSH 0x1",
            "LEA EAX,[EBP + 0xfffffe68]",
            "POP EBX",
            "PUSH EAX",
            "CALL ESI",
            "TEST EAX,EAX",
            "POP ECX",
            "JBE 0x000012a0",
            "LEA EDI,[EBP + 0xfffffe68]",
            "MOVZX EAX,word ptr [EDI]",
            "IMUL EBX,EAX",
            "INC dword ptr [EBP + -0x4]",
            "LEA EAX,[EBP + 0xfffffe68]",
            "INC EDI",
            "PUSH EAX",
            "INC EDI",
            "CALL ESI",
            "CMP dword ptr [EBP + -0x4],EAX",
            "POP ECX",
            "JC 0x00001286",
            "PUSH EBX",
            "CALL dword ptr [0x00408124]",
            "MOV EBX,dword ptr [0x00408120]",
            "POP ECX",
            "CALL EBX",
            "PUSH 0x8",
            "XOR EDI,EDI",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "MOV ESI,EDX",
            "ADD ESI,ECX",
            "TEST ESI,ESI",
            "JLE 0x000012d6",
            "CALL EBX",
            "PUSH 0x1a",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "ADD DL,0x61",
            "MOV byte ptr [EDI + EAX*0x1],DL",
            "INC EDI",
            "CMP EDI,ESI",
            "JL 0x000012c0",
            "ADD ESI,0x3",
            "CMP EDI,ESI",
            "JGE 0x000012f1",
            "CALL EBX",
            "PUSH 0xa",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "ADD DL,0x30",
            "MOV byte ptr [EDI + EAX*0x1],DL",
            "INC EDI",
            "JMP 0x000012d9",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "AND byte ptr [EDI + EAX*0x1],0x0",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001225",
            "end": "000012fc"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001249",
                    "00001254"
                ],
                "type": "undefined4"
            },
            "local_19c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001239",
                    "00001258",
                    "00001271",
                    "00001280",
                    "00001286",
                    "0000128f"
                ],
                "type": "undefined2"
            },
            "local_19a": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001243"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000126b",
                    "0000128c",
                    "0000129a"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00001225",
        "original_name": "FUN_00001225",
        "predicted_name": "gen_random_string.",
        "prediction_full_response": "[CLOSE]  \nThe predicted function name is gen_random_string.</s>"
    },
    "000042c0": {
        "decomp_code": "\nvoid FUN_000042c0(int *param_1,int param_2,int *param_3)\n\n{\n  int iVar1;\n  \n  if (param_3 != (int *)0x0) {\n    *param_3 = param_1[0xf];\n  }\n  if ((*param_1 == 4) || (*param_1 == 5)) {\n    (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1[3]);\n  }\n  if (*param_1 == 6) {\n    FUN_000042af(param_1[1],param_2);\n  }\n  *param_1 = 0;\n  param_1[0xd] = param_1[10];\n  param_1[0xc] = param_1[10];\n  param_1[7] = 0;\n  param_1[8] = 0;\n  if ((code *)param_1[0xe] != (code *)0x0) {\n    iVar1 = (*(code *)param_1[0xe])(0,0,0);\n    param_1[0xf] = iVar1;\n    *(int *)(param_2 + 0x30) = iVar1;\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0xc]",
            "PUSH EBX",
            "XOR EBX,EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0xc]",
            "CMP EAX,EBX",
            "PUSH EDI",
            "JZ 0x000042d6",
            "MOV ECX,dword ptr [ESI + 0x3c]",
            "MOV dword ptr [EAX],ECX",
            "MOV EAX,dword ptr [ESI]",
            "MOV EDI,dword ptr [ESP + 0x14]",
            "CMP EAX,0x4",
            "JZ 0x000042e6",
            "CMP EAX,0x5",
            "JNZ 0x000042f1",
            "PUSH dword ptr [ESI + 0xc]",
            "PUSH dword ptr [EDI + 0x28]",
            "CALL dword ptr [EDI + 0x24]",
            "POP ECX",
            "POP ECX",
            "CMP dword ptr [ESI],0x6",
            "JNZ 0x00004301",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL 0x000042af",
            "POP ECX",
            "POP ECX",
            "MOV EAX,dword ptr [ESI + 0x28]",
            "MOV dword ptr [ESI],EBX",
            "MOV dword ptr [ESI + 0x34],EAX",
            "MOV dword ptr [ESI + 0x30],EAX",
            "MOV EAX,dword ptr [ESI + 0x38]",
            "MOV dword ptr [ESI + 0x1c],EBX",
            "CMP EAX,EBX",
            "MOV dword ptr [ESI + 0x20],EBX",
            "JZ 0x00004327",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH EBX",
            "CALL EAX",
            "MOV dword ptr [ESI + 0x3c],EAX",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI + 0x30],EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "000042c0",
            "end": "0000432a"
        },
        "variable_metadata": {},
        "func_name": "FUN_000042c0",
        "original_name": "FUN_000042c0",
        "predicted_name": "FUN_00004300.",
        "prediction_full_response": "The predicted function name is FUN_00004300.</s>"
    },
    "00006c40": {
        "decomp_code": "\nundefined4 __thiscall FUN_00006c40(int *param_1,int param_2,undefined4 *param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  code *pcVar3;\n  undefined4 *_Src;\n  int *piVar4;\n  void *pvVar5;\n  byte bVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  byte bVar10;\n  byte bVar11;\n  char *_Source;\n  undefined8 uVar12;\n  char local_284 [260];\n  char local_180 [260];\n  uint local_7c [4];\n  uint local_6c;\n  undefined4 local_64;\n  undefined4 local_60;\n  uint local_48;\n  undefined1 local_2c [4];\n  undefined8 local_28;\n  undefined4 local_20;\n  undefined4 local_1c;\n  int *local_18;\n  undefined4 local_14;\n  uint local_10;\n  undefined4 local_c;\n  byte local_5;\n  \n  _Src = param_3;\n  if ((param_2 < -1) || (*(int *)(*param_1 + 4) <= param_2)) {\n    return 0x10000;\n  }\n  local_18 = param_1;\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  param_1[1] = -1;\n  if (param_2 == param_1[0x4d]) {\n    if (param_2 != -1) {\n      memcpy(param_3,param_1 + 2,300);\n      return 0;\n    }\n  }\n  else if (param_2 != -1) {\n    if (param_2 < *(int *)(*param_1 + 0x10)) {\n      FUN_000064e2(*param_1);\n    }\n    while (*(int *)(*param_1 + 0x10) < param_2) {\n      FUN_00006520(*param_1);\n    }\n    FUN_000064bb(*param_1,local_7c,local_180,0x104,0,0,0,0);\n    iVar7 = FUN_0000657a(*param_1,local_2c,&local_14,&local_10);\n    if (iVar7 != 0) {\n      return 0x700;\n    }\n    iVar7 = FUN_00005d0e(*(undefined4 *)*param_1,local_14,0);\n    if (iVar7 == 0) {\n      local_c = operator_new(local_10);\n      uVar8 = FUN_00005d8a(local_c,1,local_10,*(undefined4 *)*param_1);\n      if (uVar8 == local_10) {\n        *param_3 = *(undefined4 *)(*param_1 + 0x10);\n        strcpy(local_284,local_180);\n        pcVar3 = pcRam00408194;\n        _Source = local_284;\n        while( true ) {\n          while( true ) {\n            for (; (cVar2 = *_Source, cVar2 != '\\0' && (_Source[1] == ':')); _Source = _Source + 2)\n            {\n            }\n            if ((cVar2 != '\\\\') && (cVar2 != '/')) break;\n            _Source = _Source + 1;\n          }\n          iVar7 = (*pcVar3)(_Source,0x40f838);\n          if ((iVar7 == 0) &&\n             (((iVar7 = (*pcVar3)(_Source,0x40f830), iVar7 == 0 &&\n               (iVar7 = (*pcVar3)(_Source,0x40f828), iVar7 == 0)) &&\n              (iVar7 = (*pcVar3)(_Source,0x40f820), iVar7 == 0)))) break;\n          _Source = (char *)(iVar7 + 4);\n        }\n        strcpy((char *)(param_3 + 1),_Source);\n        param_3._3_1_ = 0;\n        local_5 = 0;\n        bVar10 = ~(byte)(local_48 >> 0x17);\n        bVar6 = (byte)(local_48 >> 0x1e);\n        local_7c[0] = local_7c[0] >> 8;\n        bVar11 = 1;\n        if ((((local_7c[0] == 0) || (local_7c[0] == 7)) || (local_7c[0] == 0xb)) ||\n           (local_7c[0] == 0xe)) {\n          bVar10 = (byte)local_48;\n          param_3._3_1_ = (byte)(local_48 >> 1) & 1;\n          local_5 = (byte)(local_48 >> 2) & 1;\n          bVar6 = (byte)(local_48 >> 4);\n          bVar11 = (byte)(local_48 >> 5) & 1;\n        }\n        iVar7 = 0;\n        _Src[0x42] = 0;\n        if ((bVar6 & 1) != 0) {\n          _Src[0x42] = 0x10;\n        }\n        if (bVar11 != 0) {\n          _Src[0x42] = _Src[0x42] | 0x20;\n        }\n        if (param_3._3_1_ != 0) {\n          _Src[0x42] = _Src[0x42] | 2;\n        }\n        if ((bVar10 & 1) != 0) {\n          _Src[0x42] = _Src[0x42] | 1;\n        }\n        if (local_5 != 0) {\n          _Src[0x42] = _Src[0x42] | 4;\n        }\n        _Src[0x49] = local_64;\n        _Src[0x4a] = local_60;\n        local_28 = FUN_00006b23(local_6c >> 0x10,local_6c);\n        (*pcRam004080bc)(&local_28,&local_20);\n        pvVar5 = local_c;\n        _Src[0x43] = local_20;\n        _Src[0x45] = local_20;\n        _Src[0x47] = local_20;\n        _Src[0x44] = local_1c;\n        _Src[0x46] = local_1c;\n        _Src[0x48] = local_1c;\n        if (4 < local_10) {\n          do {\n            uVar8 = (uint)local_c >> 0x10;\n            local_c._0_2_ =\n                 CONCAT11(*(undefined1 *)((int)pvVar5 + iVar7 + 1),\n                          *(undefined1 *)(iVar7 + (int)pvVar5));\n            local_c = (void *)(CONCAT22((short)uVar8,(undefined2)local_c) & 0xff00ffff);\n            bVar10 = *(byte *)((int)pvVar5 + iVar7 + 2);\n            iVar9 = strcmp((char *)&local_c,(char *)0x40f81c);\n            if (iVar9 == 0) {\n              bVar10 = *(byte *)(iVar7 + 4 + (int)pvVar5);\n              local_5 = bVar10 >> 2 & 1;\n              iVar9 = iVar7 + 5;\n              if ((bVar10 & 1) != 0) {\n                puVar1 = (undefined1 *)(iVar9 + (int)pvVar5);\n                iVar9 = iVar7 + 9;\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),\n                                                        *(undefined1 *)(iVar7 + 6 + (int)pvVar5)),\n                                               *puVar1));\n                *(undefined8 *)(_Src + 0x47) = uVar12;\n              }\n              if ((bVar10 >> 1 & 1) != 0) {\n                iVar7 = iVar9 + 1;\n                puVar1 = (undefined1 *)(iVar9 + (int)pvVar5);\n                iVar9 = iVar9 + 4;\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),\n                                                        *(undefined1 *)(iVar7 + (int)pvVar5)),\n                                               *puVar1));\n                *(undefined8 *)(_Src + 0x43) = uVar12;\n              }\n              if (local_5 != 0) {\n                uVar12 = FUN_00006b02(CONCAT31(CONCAT21(*(undefined2 *)\n                                                         ((undefined1 *)(iVar9 + (int)pvVar5) + 2),\n                                                        *(undefined1 *)(iVar9 + 1 + (int)pvVar5)),\n                                               *(undefined1 *)(iVar9 + (int)pvVar5)));\n                *(undefined8 *)(_Src + 0x45) = uVar12;\n              }\n              break;\n            }\n            iVar7 = iVar7 + 4 + (uint)bVar10;\n          } while (iVar7 + 4U < local_10);\n        }\n        if (pvVar5 != (void *)0x0) {\n          operator_delete(pvVar5);\n        }\n        piVar4 = local_18;\n        memcpy(local_18 + 2,_Src,300);\n        piVar4[0x4d] = param_2;\n        return 0;\n      }\n      operator_delete(local_c);\n    }\n    return 0x800;\n  }\n  *param_3 = *(undefined4 *)(*param_1 + 4);\n  *(undefined1 *)(param_3 + 1) = 0;\n  param_3[0x42] = 0;\n  param_3[0x43] = 0;\n  param_3[0x44] = 0;\n  param_3[0x45] = 0;\n  param_3[0x46] = 0;\n  param_3[0x47] = 0;\n  param_3[0x48] = 0;\n  param_3[0x49] = 0;\n  param_3[0x4a] = 0;\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x280",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "OR EBX,0xffffffff",
            "MOV ESI,ECX",
            "CMP EDI,EBX",
            "MOV dword ptr [EBP + -0x14],ESI",
            "JL 0x00007064",
            "MOV EAX,dword ptr [ESI]",
            "CMP EDI,dword ptr [EAX + 0x4]",
            "JGE 0x00007064",
            "CMP dword ptr [ESI + 0x4],EBX",
            "JZ 0x00006c76",
            "PUSH EAX",
            "CALL 0x00006a97",
            "POP ECX",
            "CMP EDI,dword ptr [ESI + 0x134]",
            "MOV dword ptr [ESI + 0x4],EBX",
            "JNZ 0x00006c9e",
            "CMP EDI,EBX",
            "JZ 0x00006ca2",
            "ADD ESI,0x8",
            "PUSH 0x12c",
            "PUSH ESI",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00007706",
            "ADD ESP,0xc",
            "JMP 0x00007060",
            "CMP EDI,EBX",
            "JNZ 0x00006cec",
            "MOV EAX,dword ptr [ESI]",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EAX],ECX",
            "XOR ECX,ECX",
            "MOV byte ptr [EAX + 0x4],CL",
            "MOV dword ptr [EAX + 0x108],ECX",
            "MOV dword ptr [EAX + 0x10c],ECX",
            "MOV dword ptr [EAX + 0x110],ECX",
            "MOV dword ptr [EAX + 0x114],ECX",
            "MOV dword ptr [EAX + 0x118],ECX",
            "MOV dword ptr [EAX + 0x11c],ECX",
            "MOV dword ptr [EAX + 0x120],ECX",
            "MOV dword ptr [EAX + 0x124],ECX",
            "MOV dword ptr [EAX + 0x128],ECX",
            "JMP 0x00007060",
            "MOV EAX,dword ptr [ESI]",
            "CMP EDI,dword ptr [EAX + 0x10]",
            "JGE 0x00006cfa",
            "PUSH EAX",
            "CALL 0x000064e2",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "CMP dword ptr [EAX + 0x10],EDI",
            "JGE 0x00006d09",
            "PUSH EAX",
            "CALL 0x00006520",
            "JMP 0x00006cf9",
            "XOR EDI,EDI",
            "LEA EAX,[EBP + 0xfffffe84]",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH 0x104",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x78]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x000064bb",
            "LEA EAX,[EBP + -0xc]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x10]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x28]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x0000657a",
            "ADD ESP,0x30",
            "TEST EAX,EAX",
            "JZ 0x00006d4a",
            "MOV EAX,0x700",
            "JMP 0x00007069",
            "MOV EAX,dword ptr [ESI]",
            "PUSH EDI",
            "PUSH dword ptr [EBP + -0x10]",
            "PUSH dword ptr [EAX]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00006d89",
            "PUSH dword ptr [EBP + -0xc]",
            "CALL 0x00007700",
            "MOV ECX,dword ptr [ESI]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "PUSH dword ptr [ECX]",
            "PUSH dword ptr [EBP + -0xc]",
            "PUSH 0x1",
            "PUSH EAX",
            "CALL 0x00005d8a",
            "ADD ESP,0x14",
            "CMP EAX,dword ptr [EBP + -0xc]",
            "JZ 0x00006d93",
            "PUSH dword ptr [EBP + -0x8]",
            "CALL 0x000076e8",
            "POP ECX",
            "MOV EAX,0x800",
            "JMP 0x00007069",
            "MOV EAX,dword ptr [ESI]",
            "MOV ESI,dword ptr [EBP + 0xc]",
            "MOV EAX,dword ptr [EAX + 0x10]",
            "MOV dword ptr [ESI],EAX",
            "LEA EAX,[EBP + 0xfffffe84]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd80]",
            "PUSH EAX",
            "CALL 0x000076a8",
            "MOV EBX,dword ptr [0x00408194]",
            "POP ECX",
            "POP ECX",
            "LEA EDI,[EBP + 0xfffffd80]",
            "MOV AL,byte ptr [EDI]",
            "TEST AL,AL",
            "JZ 0x00006dce",
            "CMP byte ptr [EDI + 0x1],0x3a",
            "JNZ 0x00006dce",
            "INC EDI",
            "INC EDI",
            "JMP 0x00006dbe",
            "CMP AL,0x5c",
            "JZ 0x00006dd6",
            "CMP AL,0x2f",
            "JNZ 0x00006dd9",
            "INC EDI",
            "JMP 0x00006dbe",
            "PUSH 0x40f838",
            "PUSH EDI",
            "CALL EBX",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00006e11",
            "PUSH 0x40f830",
            "PUSH EDI",
            "CALL EBX",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00006e11",
            "PUSH 0x40f828",
            "PUSH EDI",
            "CALL EBX",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00006e11",
            "PUSH 0x40f820",
            "PUSH EDI",
            "CALL EBX",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006e16",
            "LEA EDI,[EAX + 0x4]",
            "JMP 0x00006dbe",
            "LEA EAX,[ESI + 0x4]",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x000076a8",
            "MOV EDX,dword ptr [EBP + -0x44]",
            "POP ECX",
            "MOV EDI,dword ptr [EBP + -0x78]",
            "POP ECX",
            "AND byte ptr [EBP + 0xf],0x0",
            "AND byte ptr [EBP + -0x1],0x0",
            "MOV ECX,EDX",
            "MOV EAX,EDX",
            "SHR ECX,0x17",
            "SHR EAX,0x1e",
            "NOT CL",
            "AND AL,0x1",
            "AND CL,0x1",
            "SHR EDI,0x8",
            "MOV BL,0x1",
            "JZ 0x00006e57",
            "CMP EDI,0x7",
            "JZ 0x00006e57",
            "CMP EDI,0xb",
            "JZ 0x00006e57",
            "CMP EDI,0xe",
            "JNZ 0x00006e7e",
            "MOV EAX,EDX",
            "MOV BL,0x1",
            "SHR EAX,0x1",
            "AND AL,BL",
            "MOV CL,DL",
            "MOV byte ptr [EBP + 0xf],AL",
            "MOV EAX,EDX",
            "SHR EAX,0x2",
            "AND AL,BL",
            "AND CL,BL",
            "MOV byte ptr [EBP + -0x1],AL",
            "MOV EAX,EDX",
            "SHR EAX,0x4",
            "SHR EDX,0x5",
            "AND AL,BL",
            "AND DL,BL",
            "MOV BL,DL",
            "XOR EDI,EDI",
            "TEST AL,AL",
            "MOV dword ptr [ESI + 0x108],EDI",
            "JZ 0x00006e94",
            "MOV dword ptr [ESI + 0x108],0x10",
            "TEST BL,BL",
            "JZ 0x00006e9f",
            "OR dword ptr [ESI + 0x108],0x20",
            "CMP byte ptr [EBP + 0xf],0x0",
            "JZ 0x00006eac",
            "OR dword ptr [ESI + 0x108],0x2",
            "TEST CL,CL",
            "JZ 0x00006eb7",
            "OR dword ptr [ESI + 0x108],0x1",
            "CMP byte ptr [EBP + -0x1],0x0",
            "JZ 0x00006ec4",
            "OR dword ptr [ESI + 0x108],0x4",
            "MOV EAX,dword ptr [EBP + -0x60]",
            "PUSH dword ptr [EBP + -0x68]",
            "MOV dword ptr [ESI + 0x124],EAX",
            "MOV EAX,dword ptr [EBP + -0x5c]",
            "MOV dword ptr [ESI + 0x128],EAX",
            "MOV EAX,dword ptr [EBP + -0x68]",
            "SHR EAX,0x10",
            "PUSH EAX",
            "CALL 0x00006b23",
            "POP ECX",
            "MOV dword ptr [EBP + -0x24],EAX",
            "POP ECX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x24]",
            "PUSH EAX",
            "MOV dword ptr [EBP + -0x20],EDX",
            "CALL dword ptr [0x004080bc]",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "MOV ECX,dword ptr [EBP + -0x18]",
            "CMP dword ptr [EBP + -0xc],0x4",
            "MOV EBX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x10c],EAX",
            "MOV dword ptr [ESI + 0x114],EAX",
            "MOV dword ptr [ESI + 0x11c],EAX",
            "MOV dword ptr [ESI + 0x110],ECX",
            "MOV dword ptr [ESI + 0x118],ECX",
            "MOV dword ptr [ESI + 0x120],ECX",
            "JBE 0x00007037",
            "MOV AL,byte ptr [EDI + EBX*0x1]",
            "PUSH 0x40f81c",
            "MOV byte ptr [EBP + -0x8],AL",
            "MOV AL,byte ptr [EBX + EDI*0x1 + 0x1]",
            "AND byte ptr [EBP + -0x6],0x0",
            "MOV byte ptr [EBP + -0x7],AL",
            "MOVZX EAX,byte ptr [EBX + EDI*0x1 + 0x2]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "CALL 0x00007740",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006f73",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "LEA EDI,[EDI + EAX*0x1 + 0x4]",
            "LEA EAX,[EDI + 0x4]",
            "CMP EAX,dword ptr [EBP + -0xc]",
            "JC 0x00006f32",
            "JMP 0x00007037",
            "MOVZX ECX,byte ptr [EDI + EBX*0x1 + 0x4]",
            "MOV EAX,ECX",
            "MOV EDX,ECX",
            "SHR EAX,0x1",
            "SHR EDX,0x2",
            "AND AL,0x1",
            "AND DL,0x1",
            "ADD EDI,0x5",
            "MOV byte ptr [EBP + 0xf],AL",
            "TEST CL,0x1",
            "MOV byte ptr [EBP + -0x1],DL",
            "JZ 0x00006fca",
            "MOVZX EDX,byte ptr [EDI + EBX*0x1 + 0x1]",
            "LEA EAX,[EDI + EBX*0x1]",
            "XOR ECX,ECX",
            "ADD EDI,0x4",
            "MOV CH,byte ptr [EAX + 0x3]",
            "MOV CL,byte ptr [EAX + 0x2]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL ECX,0x8",
            "OR ECX,EDX",
            "SHL ECX,0x8",
            "OR EAX,ECX",
            "PUSH EAX",
            "CALL 0x00006b02",
            "MOV dword ptr [ESI + 0x11c],EAX",
            "MOV AL,byte ptr [EBP + 0xf]",
            "POP ECX",
            "MOV dword ptr [ESI + 0x120],EDX",
            "TEST AL,AL",
            "JZ 0x00007001",
            "MOVZX EDX,byte ptr [EDI + EBX*0x1 + 0x1]",
            "LEA EAX,[EDI + EBX*0x1]",
            "XOR ECX,ECX",
            "ADD EDI,0x4",
            "MOV CH,byte ptr [EAX + 0x3]",
            "MOV CL,byte ptr [EAX + 0x2]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL ECX,0x8",
            "OR ECX,EDX",
            "SHL ECX,0x8",
            "OR EAX,ECX",
            "PUSH EAX",
            "CALL 0x00006b02",
            "MOV dword ptr [ESI + 0x10c],EAX",
            "POP ECX",
            "MOV dword ptr [ESI + 0x110],EDX",
            "CMP byte ptr [EBP + -0x1],0x0",
            "JZ 0x00007037",
            "MOVZX EDX,byte ptr [EDI + EBX*0x1 + 0x1]",
            "LEA EAX,[EDI + EBX*0x1]",
            "XOR ECX,ECX",
            "MOV CH,byte ptr [EAX + 0x3]",
            "MOV CL,byte ptr [EAX + 0x2]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL ECX,0x8",
            "OR ECX,EDX",
            "SHL ECX,0x8",
            "OR EAX,ECX",
            "PUSH EAX",
            "CALL 0x00006b02",
            "MOV dword ptr [ESI + 0x114],EAX",
            "POP ECX",
            "MOV dword ptr [ESI + 0x118],EDX",
            "TEST EBX,EBX",
            "JZ 0x00007042",
            "PUSH EBX",
            "CALL 0x000076e8",
            "POP ECX",
            "PUSH 0x12c",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + -0x14]",
            "LEA EAX,[ESI + 0x8]",
            "PUSH EAX",
            "CALL 0x00007706",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "ADD ESP,0xc",
            "MOV dword ptr [ESI + 0x134],EAX",
            "XOR EAX,EAX",
            "JMP 0x00007069",
            "MOV EAX,0x10000",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "00006c40",
            "end": "0000706f"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d68",
                    "00006d80",
                    "00006f05",
                    "00006f3a",
                    "00006f50",
                    "00006f45",
                    "00006f41"
                ],
                "type": "undefined4"
            },
            "local_60": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006ed0"
                ],
                "type": "undefined4"
            },
            "local_5": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006e2c",
                    "00006e6d",
                    "00006eb7",
                    "00006f8f",
                    "00007001"
                ],
                "type": "undefined1"
            },
            "local_6c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006ec7",
                    "00006ed9"
                ],
                "type": "undefined4"
            },
            "local_7c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d1b",
                    "00006e24"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006efe"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d2e"
                ],
                "type": "undefined"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006c56",
                    "00007048"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006ee6",
                    "00006eee"
                ],
                "type": "undefined4"
            },
            "local_48": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006e20"
                ],
                "type": "undefined4"
            },
            "local_284": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006da4",
                    "00006db8",
                    "00006dbe"
                ],
                "type": "undefined"
            },
            "local_283": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006dc4"
                ],
                "type": "undefined1"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d26",
                    "00006d5e",
                    "00006d6d",
                    "00006d7b",
                    "00006f01",
                    "00006f69"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006eea",
                    "00006efb"
                ],
                "type": "undefined4"
            },
            "local_64": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006ec4"
                ],
                "type": "undefined4"
            },
            "local_180": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d0b",
                    "00006d9d"
                ],
                "type": "undefined"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006d2a",
                    "00006d4d"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006ef2"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00006c40",
        "original_name": "FUN_00006c40",
        "predicted_name": "The function you provided is not a valid C function. It appears to be a decompiled code, and it is not complete.",
        "prediction_full_response": "The function you provided is not a valid C function. It appears to be a decompiled code, and it is not complete.\n\nHowever, from the code you provided, it appears to be a function that is responsible for setting the properties of a software component. The function takes in several parameters, including a pointer to a structure that contains the properties of the component, and it returns an integer that represents the status of the operation.\n\nThe function appears to be a complex one, and it is not possible to provide a complete description of its functionality based on the limited code provided. However, from the code you provided, it appears to be a function that is responsible for setting the properties of a software component, and it takes in several parameters, including a pointer to a structure that contains the properties of the component, and it returns an integer that represents the status of the operation.</s>"
    },
    "00001861": {
        "decomp_code": "\nundefined4 __thiscall FUN_00001861(int param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_0000182c();\n  if (iVar1 != 0) {\n    if (param_2 == 0) {\n      iVar1 = (*pcRam0040f898)(*(undefined4 *)(param_1 + 4),0x40ebf8,0x494,0,0,param_1 + 8);\n    }\n    else {\n      iVar1 = FUN_000018f9(*(undefined4 *)(param_1 + 4),param_1 + 8,param_2);\n    }\n    if (iVar1 != 0) {\n      return 1;\n    }\n  }\n  FUN_000018b9();\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "CALL 0x0000182c",
            "TEST EAX,EAX",
            "JZ 0x000018a7",
            "XOR EAX,EAX",
            "CMP dword ptr [ESP + 0x8],EAX",
            "JNZ 0x00001890",
            "LEA ECX,[ESI + 0x8]",
            "PUSH ECX",
            "PUSH EAX",
            "PUSH EAX",
            "PUSH 0x494",
            "PUSH 0x40ebf8",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL dword ptr [0x0040f898]",
            "JMP 0x000018a3",
            "PUSH dword ptr [ESP + 0x8]",
            "LEA EAX,[ESI + 0x8]",
            "PUSH EAX",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL 0x000018f9",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x000018b2",
            "MOV ECX,ESI",
            "CALL 0x000018b9",
            "XOR EAX,EAX",
            "JMP 0x000018b5",
            "PUSH 0x1",
            "POP EAX",
            "POP ESI",
            "RET 0x4"
        ],
        "function_address": {
            "start": "00001861",
            "end": "000018b8"
        },
        "variable_metadata": {},
        "func_name": "FUN_00001861",
        "original_name": "FUN_00001861",
        "predicted_name": "FUN_0000182c.",
        "prediction_full_response": "The predicted function name is FUN_0000182c.</s>"
    },
    "0000795b": {
        "decomp_code": "\nvoid Unwind_0040795b(void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [EBP + -0x10]",
            "ADD ECX,0x2c",
            "JMP 0x0000181b"
        ],
        "function_address": {
            "start": "0000795b",
            "end": "00007965"
        },
        "variable_metadata": {},
        "func_name": "Unwind@0040795b",
        "original_name": "Unwind@0040795b",
        "predicted_name": "FUN_0000181b",
        "prediction_full_response": "The predicted function name is FUN_0000181b</s>"
    },
    "0000432b": {
        "decomp_code": "\nundefined4 * FUN_0000432b(int param_1,undefined4 param_2,int param_3)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  puVar1 = (undefined4 *)(**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x40);\n  if (puVar1 != (undefined4 *)0x0) {\n    iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),8,0x5a0);\n    puVar1[9] = iVar2;\n    if (iVar2 == 0) {\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);\n    }\n    else {\n      iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,param_3);\n      puVar1[10] = iVar2;\n      if (iVar2 != 0) {\n        *puVar1 = 0;\n        puVar1[0xb] = iVar2 + param_3;\n        puVar1[0xe] = param_2;\n        FUN_000042c0(puVar1,param_1,0);\n        return puVar1;\n      }\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1[9]);\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);\n    }\n  }\n  return (undefined4 *)0x0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0xc]",
            "PUSH EDI",
            "PUSH 0x40",
            "PUSH 0x1",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "MOV EDI,EAX",
            "ADD ESP,0xc",
            "TEST EDI,EDI",
            "JZ 0x00004391",
            "PUSH 0x5a0",
            "PUSH 0x8",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI + 0x24],EAX",
            "TEST EAX,EAX",
            "JNZ 0x00004367",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "POP ECX",
            "POP ECX",
            "JMP 0x00004391",
            "MOV EBX,dword ptr [ESP + 0x18]",
            "PUSH EBX",
            "PUSH 0x1",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI + 0x28],EAX",
            "TEST EAX,EAX",
            "JNZ 0x00004395",
            "PUSH dword ptr [EDI + 0x24]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "ADD ESP,0x10",
            "XOR EAX,EAX",
            "JMP 0x000043b2",
            "AND dword ptr [EDI],0x0",
            "ADD EAX,EBX",
            "MOV dword ptr [EDI + 0x2c],EAX",
            "MOV EAX,dword ptr [ESP + 0x14]",
            "PUSH 0x0",
            "PUSH ESI",
            "PUSH EDI",
            "MOV dword ptr [EDI + 0x38],EAX",
            "CALL 0x000042c0",
            "ADD ESP,0xc",
            "MOV EAX,EDI",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "0000432b",
            "end": "000043b5"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000432b",
        "original_name": "FUN_0000432b",
        "predicted_name": "FUN_000042c0.",
        "prediction_full_response": "The predicted function name is FUN_000042c0.</s>"
    },
    "00006b23": {
        "decomp_code": "\nundefined8 FUN_00006b23(uint param_1,uint param_2)\n\n{\n  short local_1c;\n  ushort local_1a;\n  ushort local_16;\n  ushort local_14;\n  ushort local_12;\n  undefined2 local_10;\n  undefined2 local_e;\n  undefined8 local_c;\n  \n  local_e = 0;\n  local_1c = ((ushort)param_1 >> 9) + 0x7bc;\n  local_16 = (ushort)param_1 & 0x1f;\n  local_1a = (ushort)(param_1 >> 5) & 0xf;\n  local_14 = (ushort)param_2 >> 0xb;\n  local_10 = (undefined2)((param_2 & 0x1f) << 1);\n  local_12 = (ushort)(param_2 >> 5) & 0x3f;\n  (*pcRam004080b8)(&local_1c,&local_c);\n  return local_c;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x18",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "AND word ptr [EBP + -0xa],0x0",
            "MOV CX,AX",
            "SHR CX,0x9",
            "ADD ECX,0x7bc",
            "MOV word ptr [EBP + -0x18],CX",
            "MOV ECX,EAX",
            "SHR ECX,0x5",
            "AND EAX,0x1f",
            "AND ECX,0xf",
            "MOV word ptr [EBP + -0x12],AX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV word ptr [EBP + -0x16],CX",
            "MOV CX,AX",
            "SHR CX,0xb",
            "MOV word ptr [EBP + -0x10],CX",
            "MOV ECX,EAX",
            "AND EAX,0x1f",
            "SHL EAX,0x1",
            "MOV word ptr [EBP + -0xc],AX",
            "LEA EAX,[EBP + -0x8]",
            "SHR ECX,0x5",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x18]",
            "AND ECX,0x3f",
            "PUSH EAX",
            "MOV word ptr [EBP + -0xe],CX",
            "CALL dword ptr [0x004080b8]",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00006b23",
            "end": "00006b8d"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b6e",
                    "00006b86"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b3e",
                    "00006b75"
                ],
                "type": "undefined2"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b89"
                ],
                "type": "undefined4"
            },
            "local_1a": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b54"
                ],
                "type": "undefined2"
            },
            "local_16": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b4d"
                ],
                "type": "undefined2"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b6a"
                ],
                "type": "undefined2"
            },
            "local_e": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b2c"
                ],
                "type": "undefined2"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b5f"
                ],
                "type": "undefined2"
            },
            "local_12": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006b7c"
                ],
                "type": "undefined2"
            }
        },
        "func_name": "FUN_00006b23",
        "original_name": "FUN_00006b23",
        "predicted_name": "pcRam004080b8",
        "prediction_full_response": "The predicted function name is pcRam004080b8</s>"
    },
    "00003bd6": {
        "decomp_code": "\nint FUN_00003bd6(int param_1,void *param_2,int param_3)\n\n{\n  void *_Src;\n  uint uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  void *pvVar4;\n  uint uVar5;\n  undefined4 local_8;\n  \n  iVar2 = (int)param_2;\n  _Src = *(void **)(param_1 + 0x30);\n  pvVar4 = *(void **)(param_1 + 0x34);\n  local_8 = *(void **)((int)param_2 + 0xc);\n  if (pvVar4 < _Src) {\n    pvVar4 = *(void **)(param_1 + 0x2c);\n  }\n  uVar1 = *(uint *)((int)param_2 + 0x10);\n  uVar5 = (int)pvVar4 - (int)_Src;\n  if (uVar1 < (uint)((int)pvVar4 - (int)_Src)) {\n    uVar5 = uVar1;\n  }\n  if ((uVar5 != 0) && (param_3 == -5)) {\n    param_3 = 0;\n  }\n  *(int *)((int)param_2 + 0x14) = *(int *)((int)param_2 + 0x14) + uVar5;\n  *(uint *)((int)param_2 + 0x10) = uVar1 - uVar5;\n  if (*(code **)(param_1 + 0x38) != (code *)0x0) {\n    uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),_Src,uVar5);\n    *(undefined4 *)(param_1 + 0x3c) = uVar3;\n    *(undefined4 *)((int)param_2 + 0x30) = uVar3;\n  }\n  param_2 = _Src;\n  if (uVar5 != 0) {\n    memcpy(local_8,_Src,uVar5);\n    local_8 = (void *)((int)local_8 + uVar5);\n    param_2 = (void *)((int)_Src + uVar5);\n  }\n  if (param_2 == *(void **)(param_1 + 0x2c)) {\n    param_2 = *(void **)(param_1 + 0x28);\n    if (*(void **)(param_1 + 0x34) == *(void **)(param_1 + 0x2c)) {\n      *(void **)(param_1 + 0x34) = param_2;\n    }\n    uVar1 = *(uint *)(iVar2 + 0x10);\n    uVar5 = *(int *)(param_1 + 0x34) - (int)param_2;\n    if (uVar1 < uVar5) {\n      uVar5 = uVar1;\n    }\n    if ((uVar5 != 0) && (param_3 == -5)) {\n      param_3 = 0;\n    }\n    *(int *)(iVar2 + 0x14) = *(int *)(iVar2 + 0x14) + uVar5;\n    *(uint *)(iVar2 + 0x10) = uVar1 - uVar5;\n    if (*(code **)(param_1 + 0x38) != (code *)0x0) {\n      uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),param_2,uVar5);\n      *(undefined4 *)(param_1 + 0x3c) = uVar3;\n      *(undefined4 *)(iVar2 + 0x30) = uVar3;\n    }\n    if (uVar5 != 0) {\n      memcpy(local_8,param_2,uVar5);\n      local_8 = (void *)((int)local_8 + uVar5);\n      param_2 = (void *)((int)param_2 + uVar5);\n    }\n  }\n  *(void **)(iVar2 + 0xc) = local_8;\n  *(void **)(param_1 + 0x30) = param_2;\n  return param_3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV ECX,dword ptr [ESI + 0x30]",
            "MOV EBX,dword ptr [ESI + 0x34]",
            "MOV EAX,dword ptr [EDI + 0xc]",
            "CMP ECX,EBX",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV dword ptr [EBP + 0xc],ECX",
            "JBE 0x00003bf9",
            "MOV EBX,dword ptr [ESI + 0x2c]",
            "MOV EAX,dword ptr [EDI + 0x10]",
            "SUB EBX,ECX",
            "CMP EBX,EAX",
            "JBE 0x00003c04",
            "MOV EBX,EAX",
            "TEST EBX,EBX",
            "JZ 0x00003c12",
            "CMP dword ptr [EBP + 0x10],-0x5",
            "JNZ 0x00003c12",
            "AND dword ptr [EBP + 0x10],0x0",
            "ADD dword ptr [EDI + 0x14],EBX",
            "SUB EAX,EBX",
            "MOV dword ptr [EDI + 0x10],EAX",
            "MOV EAX,dword ptr [ESI + 0x38]",
            "TEST EAX,EAX",
            "JZ 0x00003c31",
            "PUSH EBX",
            "PUSH ECX",
            "PUSH dword ptr [ESI + 0x3c]",
            "CALL EAX",
            "MOV dword ptr [ESI + 0x3c],EAX",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI + 0x30],EAX",
            "TEST EBX,EBX",
            "JZ 0x00003c4a",
            "PUSH EBX",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL 0x00007706",
            "ADD dword ptr [EBP + -0x4],EBX",
            "ADD ESP,0xc",
            "ADD dword ptr [EBP + 0xc],EBX",
            "MOV EAX,dword ptr [ESI + 0x2c]",
            "CMP dword ptr [EBP + 0xc],EAX",
            "JNZ 0x00003cb4",
            "MOV ECX,dword ptr [ESI + 0x28]",
            "CMP dword ptr [ESI + 0x34],EAX",
            "MOV dword ptr [EBP + 0xc],ECX",
            "JNZ 0x00003c60",
            "MOV dword ptr [ESI + 0x34],ECX",
            "MOV EBX,dword ptr [ESI + 0x34]",
            "MOV EAX,dword ptr [EDI + 0x10]",
            "SUB EBX,ECX",
            "CMP EBX,EAX",
            "JBE 0x00003c6e",
            "MOV EBX,EAX",
            "TEST EBX,EBX",
            "JZ 0x00003c7c",
            "CMP dword ptr [EBP + 0x10],-0x5",
            "JNZ 0x00003c7c",
            "AND dword ptr [EBP + 0x10],0x0",
            "ADD dword ptr [EDI + 0x14],EBX",
            "SUB EAX,EBX",
            "MOV dword ptr [EDI + 0x10],EAX",
            "MOV EAX,dword ptr [ESI + 0x38]",
            "TEST EAX,EAX",
            "JZ 0x00003c9b",
            "PUSH EBX",
            "PUSH ECX",
            "PUSH dword ptr [ESI + 0x3c]",
            "CALL EAX",
            "MOV dword ptr [ESI + 0x3c],EAX",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI + 0x30],EAX",
            "TEST EBX,EBX",
            "JZ 0x00003cb4",
            "PUSH EBX",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL 0x00007706",
            "ADD dword ptr [EBP + -0x4],EBX",
            "ADD ESP,0xc",
            "ADD dword ptr [EBP + 0xc],EBX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0xc],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x30],EAX",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00003bd6",
            "end": "00003cc7"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003bee",
                    "00003c39",
                    "00003c41",
                    "00003ca3",
                    "00003cab",
                    "00003cb4"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00003bd6",
        "original_name": "FUN_00003bd6",
        "predicted_name": "\"inflate_fast\".",
        "prediction_full_response": "The predicted function name is \"inflate_fast\".</s>"
    },
    "00004fa0": {
        "decomp_code": "\nint FUN_00004fa0(undefined4 param_1,int *param_2,undefined4 param_3,undefined4 param_4,int param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 local_8;\n  \n  local_8 = 0;\n  iVar1 = (**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),0x13,4);\n  if (iVar1 == 0) {\n    iVar2 = -4;\n  }\n  else {\n    iVar2 = FUN_00004c19(param_1,0x13,0x13,0,0,param_3,param_2,param_4,&local_8,iVar1);\n    if (iVar2 == -3) {\n      *(undefined4 *)(param_5 + 0x18) = 0x40f6e4;\n    }\n    else if ((iVar2 == -5) || (*param_2 == 0)) {\n      *(undefined4 *)(param_5 + 0x18) = 0x40f6c0;\n      iVar2 = -3;\n    }\n    (**(code **)(param_5 + 0x24))(*(undefined4 *)(param_5 + 0x28),iVar1);\n  }\n  return iVar2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "AND dword ptr [EBP + -0x4],0x0",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x18]",
            "PUSH 0x4",
            "PUSH 0x13",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0xc",
            "MOV dword ptr [EBP + 0x18],EAX",
            "TEST EAX,EAX",
            "JNZ 0x00004fc5",
            "PUSH -0x4",
            "POP EAX",
            "JMP 0x0000501c",
            "PUSH EBX",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x14]",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH 0x0",
            "PUSH 0x0",
            "PUSH 0x13",
            "PUSH 0x13",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00004c19",
            "MOV EBX,EAX",
            "ADD ESP,0x28",
            "CMP EBX,-0x3",
            "JNZ 0x00004ff7",
            "MOV dword ptr [ESI + 0x18],0x40f6e4",
            "JMP 0x0000500e",
            "CMP EBX,-0x5",
            "JZ 0x00005004",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CMP dword ptr [EAX],0x0",
            "JNZ 0x0000500e",
            "PUSH -0x3",
            "MOV dword ptr [ESI + 0x18],0x40f6c0",
            "POP EBX",
            "PUSH dword ptr [EBP + 0x18]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "POP ECX",
            "MOV EAX,EBX",
            "POP ECX",
            "POP EBX",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00004fa0",
            "end": "0000501e"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004fa4",
                    "00004fc7"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00004fa0",
        "original_name": "FUN_00004fa0",
        "predicted_name": "FUN_00004c19.",
        "prediction_full_response": "The predicted function name is FUN_00004c19.</s>"
    },
    "00007603": {
        "decomp_code": "\nvoid FUN_00007603(int *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5)\n\n{\n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else if (*param_1 == 1) {\n    uRam0040f938 = FUN_00007136(param_2,param_3,param_4,param_5);\n  }\n  else {\n    uRam0040f938 = 0x80000;\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "TEST EAX,EAX",
            "JNZ 0x00007614",
            "MOV EAX,0x10000",
            "JMP 0x00007636",
            "CMP dword ptr [EAX],0x1",
            "JZ 0x00007620",
            "MOV EAX,0x80000",
            "JMP 0x00007636",
            "PUSH dword ptr [EBP + 0x18]",
            "MOV EAX,dword ptr [EAX + 0x4]",
            "MOV ECX,EAX",
            "PUSH dword ptr [EBP + 0x14]",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00007136",
            "MOV [0x0040f938],EAX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00007603",
            "end": "0000763c"
        },
        "variable_metadata": {},
        "func_name": "FUN_00007603",
        "original_name": "FUN_00007603",
        "predicted_name": "FUN_00007136.",
        "prediction_full_response": "The predicted function name is FUN_00007136.</s>"
    },
    "000042af": {
        "decomp_code": "\nvoid FUN_000042af(undefined4 param_1,int param_2)\n\n{\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH dword ptr [ESP + 0x4]",
            "MOV EAX,dword ptr [ESP + 0xc]",
            "PUSH dword ptr [EAX + 0x28]",
            "CALL dword ptr [EAX + 0x24]",
            "POP ECX",
            "POP ECX",
            "RET"
        ],
        "function_address": {
            "start": "000042af",
            "end": "000042bf"
        },
        "variable_metadata": {},
        "func_name": "FUN_000042af",
        "original_name": "FUN_000042af",
        "predicted_name": "_mu_stream_write_all",
        "prediction_full_response": "The predicted function name is _mu_stream_write_all</s>"
    },
    "00007970": {
        "decomp_code": "\nvoid Unwind_00407970(void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [EBP + -0x10]",
            "ADD ECX,0x4",
            "JMP 0x0000181b"
        ],
        "function_address": {
            "start": "00007970",
            "end": "0000797a"
        },
        "variable_metadata": {},
        "func_name": "Unwind@00407970",
        "original_name": "Unwind@00407970",
        "predicted_name": "FUN_0000181b",
        "prediction_full_response": "The predicted function name is FUN_0000181b</s>"
    },
    "00005d8a": {
        "decomp_code": "\nuint FUN_00005d8a(void *param_1,uint param_2,int param_3,char *param_4)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  int iVar3;\n  void *_Size;\n  \n  pcVar2 = param_4;\n  _Size = (void *)(param_2 * param_3);\n  if (*param_4 == '\\0') {\n    iVar3 = *(int *)(param_4 + 0x1c);\n    if (*(uint *)(param_4 + 0x18) < (uint)(iVar3 + (int)_Size)) {\n      _Size = (void *)(*(uint *)(param_4 + 0x18) - iVar3);\n    }\n    memcpy(param_1,(void *)(*(int *)(param_4 + 0x14) + iVar3),(size_t)_Size);\n    piVar1 = (int *)(pcVar2 + 0x1c);\n    *piVar1 = *piVar1 + (int)_Size;\n    param_1 = _Size;\n  }\n  else {\n    iVar3 = (*pcRam00408040)(*(undefined4 *)(param_4 + 4),param_1,_Size,&param_1,0);\n    if (iVar3 == 0) {\n      pcVar2[8] = '\\x01';\n    }\n  }\n  return (uint)param_1 / param_2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x14]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "IMUL EDI,dword ptr [EBP + 0x10]",
            "CMP byte ptr [ESI],0x0",
            "JZ 0x00005dbe",
            "LEA EAX,[EBP + 0x8]",
            "PUSH 0x0",
            "PUSH EAX",
            "PUSH EDI",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL dword ptr [0x00408040]",
            "TEST EAX,EAX",
            "JNZ 0x00005db9",
            "MOV byte ptr [ESI + 0x8],0x1",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "JMP 0x00005de6",
            "MOV ECX,dword ptr [ESI + 0x1c]",
            "MOV EAX,dword ptr [ESI + 0x18]",
            "LEA EDX,[ECX + EDI*0x1]",
            "CMP EDX,EAX",
            "JBE 0x00005dcf",
            "SUB EAX,ECX",
            "MOV EDI,EAX",
            "MOV EAX,dword ptr [ESI + 0x14]",
            "PUSH EDI",
            "ADD EAX,ECX",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00007706",
            "ADD ESP,0xc",
            "ADD dword ptr [ESI + 0x1c],EDI",
            "MOV EAX,EDI",
            "XOR EDX,EDX",
            "POP EDI",
            "DIV dword ptr [EBP + 0xc]",
            "POP ESI",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00005d8a",
            "end": "00005dee"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005d8a",
        "original_name": "FUN_00005d8a",
        "predicted_name": "\"xstrxfrm\".",
        "prediction_full_response": "The predicted function name is \"xstrxfrm\".</s>"
    },
    "00006880": {
        "decomp_code": "\nint FUN_00006880(uint param_1,int param_2,uint param_3,undefined1 *param_4)\n\n{\n  int *piVar1;\n  char cVar2;\n  int *piVar3;\n  undefined1 uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  int local_c;\n  int local_8;\n  \n  local_c = 0;\n  local_8 = 0;\n  if (param_4 != (undefined1 *)0x0) {\n    *param_4 = 0;\n  }\n  if ((param_1 == 0) || (piVar3 = *(int **)(param_1 + 0x7c), piVar3 == (int *)0x0)) {\n    local_8 = -0x66;\n  }\n  else if (*piVar3 == 0) {\n    local_8 = -100;\n  }\n  else if (param_3 == 0) {\nLAB_00006a75:\n    local_8 = 0;\n  }\n  else {\n    piVar3[5] = param_3;\n    piVar3[4] = param_2;\n    if ((uint)piVar3[0x17] < param_3) {\n      piVar3[5] = piVar3[0x17];\n    }\n    if (piVar3[5] != 0) {\n      do {\n        if ((piVar3[2] == 0) && (uVar7 = piVar3[0x16], uVar7 != 0)) {\n          uVar6 = 0x4000;\n          if ((uVar7 < 0x4000) && (uVar6 = uVar7, uVar7 == 0)) {\n            if (param_4 != (undefined1 *)0x0) {\n              *param_4 = 1;\n            }\n            goto LAB_00006a75;\n          }\n          iVar5 = FUN_00005d0e(piVar3[0x18],piVar3[0x1a] + piVar3[0xf],0);\n          if ((iVar5 != 0) || (iVar5 = FUN_00005d8a(*piVar3,uVar6,1,piVar3[0x18]), iVar5 != 1)) {\n            return -1;\n          }\n          piVar3[0xf] = piVar3[0xf] + uVar6;\n          piVar3[0x16] = piVar3[0x16] - uVar6;\n          iVar5 = *piVar3;\n          piVar3[1] = iVar5;\n          piVar3[2] = uVar6;\n          if (((char)piVar3[0x1b] != '\\0') && (param_1 = 0, uVar6 != 0)) {\n            do {\n              uVar4 = FUN_000055a3(piVar3 + 0x1c,\n                                   CONCAT31((int3)(param_1 >> 8),*(undefined1 *)(param_1 + iVar5)));\n              uVar7 = param_1 + 1;\n              *(undefined1 *)(param_1 + iVar5) = uVar4;\n              param_1 = uVar7;\n            } while (uVar7 < uVar6);\n          }\n        }\n        uVar7 = piVar3[2];\n        uVar6 = piVar3[0x1f];\n        if (uVar7 < (uint)piVar3[0x1f]) {\n          uVar6 = uVar7;\n        }\n        if (uVar6 != 0) {\n          cVar2 = *(char *)(piVar3[1] + -1 + uVar6);\n          piVar1 = piVar3 + 0x1f;\n          *piVar1 = *piVar1 - uVar6;\n          piVar3[2] = uVar7 - uVar6;\n          piVar3[1] = piVar3[1] + uVar6;\n          if ((*piVar1 == 0) && (cVar2 != (char)piVar3[0x20])) {\n            return -0x6a;\n          }\n        }\n        if (piVar3[0x19] == 0) {\n          uVar7 = piVar3[2];\n          if ((uint)piVar3[5] < (uint)piVar3[2]) {\n            uVar7 = piVar3[5];\n          }\n          uVar6 = 0;\n          if (uVar7 != 0) {\n            do {\n              *(undefined1 *)(piVar3[4] + uVar6) = *(undefined1 *)(piVar3[1] + uVar6);\n              uVar6 = uVar6 + 1;\n            } while (uVar6 < uVar7);\n          }\n          iVar5 = FUN_0000541f(piVar3[0x14],piVar3[4],uVar7);\n          piVar3[0x17] = piVar3[0x17] - uVar7;\n          piVar3[2] = piVar3[2] - uVar7;\n          piVar3[5] = piVar3[5] - uVar7;\n          piVar3[4] = piVar3[4] + uVar7;\n          piVar3[1] = piVar3[1] + uVar7;\n          piVar3[6] = piVar3[6] + uVar7;\n          local_8 = local_8 + uVar7;\n          piVar3[0x14] = iVar5;\n          if ((piVar3[0x17] == 0) && (param_4 != (undefined1 *)0x0)) {\n            *param_4 = 1;\n          }\n        }\n        else {\n          iVar5 = piVar3[4];\n          iVar8 = piVar3[6];\n          local_c = FUN_0000583c(piVar3 + 1,2);\n          iVar8 = piVar3[6] - iVar8;\n          iVar5 = FUN_0000541f(piVar3[0x14],iVar5,iVar8);\n          piVar3[0x17] = piVar3[0x17] - iVar8;\n          local_8 = local_8 + iVar8;\n          piVar3[0x14] = iVar5;\n          if ((local_c == 1) || (piVar3[0x17] == 0)) {\n            if (param_4 == (undefined1 *)0x0) {\n              return local_8;\n            }\n            *param_4 = 1;\n            return local_8;\n          }\n          if (local_c != 0) {\n            return local_c;\n          }\n        }\n      } while (piVar3[5] != 0);\n      if (local_c != 0) {\n        return local_c;\n      }\n    }\n  }\n  return local_8;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "PUSH ECX",
            "PUSH EBX",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "XOR EDX,EDX",
            "PUSH ESI",
            "CMP EBX,EDX",
            "PUSH EDI",
            "MOV dword ptr [EBP + -0x8],EDX",
            "MOV dword ptr [EBP + -0x4],EDX",
            "JZ 0x00006899",
            "AND byte ptr [EBX],DL",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "CMP EAX,EDX",
            "JNZ 0x000068a7",
            "PUSH -0x66",
            "JMP 0x00006a80",
            "MOV ESI,dword ptr [EAX + 0x7c]",
            "CMP ESI,EDX",
            "JZ 0x000068a0",
            "CMP dword ptr [ESI],EDX",
            "JNZ 0x000068b9",
            "PUSH -0x64",
            "JMP 0x00006a80",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "CMP ECX,EDX",
            "JZ 0x00006a75",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x14],ECX",
            "MOV dword ptr [ESI + 0x10],EAX",
            "MOV EAX,dword ptr [ESI + 0x5c]",
            "CMP ECX,EAX",
            "JBE 0x000068d7",
            "MOV dword ptr [ESI + 0x14],EAX",
            "CMP dword ptr [ESI + 0x14],EDX",
            "JBE 0x00006a69",
            "CMP dword ptr [ESI + 0x8],0x0",
            "JNZ 0x0000697c",
            "MOV EAX,dword ptr [ESI + 0x58]",
            "TEST EAX,EAX",
            "JBE 0x0000697c",
            "MOV EDI,0x4000",
            "CMP EAX,EDI",
            "JNC 0x00006908",
            "MOV EDI,EAX",
            "TEST EDI,EDI",
            "JZ 0x00006a6e",
            "MOV EAX,dword ptr [ESI + 0x68]",
            "PUSH 0x0",
            "ADD EAX,dword ptr [ESI + 0x3c]",
            "PUSH EAX",
            "PUSH dword ptr [ESI + 0x60]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00006a79",
            "PUSH dword ptr [ESI + 0x60]",
            "PUSH 0x1",
            "PUSH EDI",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JNZ 0x00006a79",
            "ADD dword ptr [ESI + 0x3c],EDI",
            "SUB dword ptr [ESI + 0x58],EDI",
            "MOV EBX,dword ptr [ESI]",
            "CMP byte ptr [ESI + 0x6c],0x0",
            "MOV dword ptr [ESI + 0x4],EBX",
            "MOV dword ptr [ESI + 0x8],EDI",
            "JZ 0x00006979",
            "AND dword ptr [EBP + 0x8],0x0",
            "TEST EDI,EDI",
            "JBE 0x00006979",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV AL,byte ptr [EAX + EBX*0x1]",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x70]",
            "PUSH EAX",
            "CALL 0x000055a3",
            "POP ECX",
            "POP ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "INC dword ptr [EBP + 0x8]",
            "CMP dword ptr [EBP + 0x8],EDI",
            "MOV byte ptr [ECX + EBX*0x1],AL",
            "JC 0x00006959",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "MOV ECX,dword ptr [ESI + 0x7c]",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "CMP ECX,EAX",
            "JBE 0x00006988",
            "MOV ECX,EAX",
            "TEST ECX,ECX",
            "JBE 0x000069af",
            "MOV EDX,dword ptr [ESI + 0x4]",
            "SUB EAX,ECX",
            "LEA EDI,[EDX + ECX*0x1]",
            "MOV DL,byte ptr [EDX + ECX*0x1 + -0x1]",
            "SUB dword ptr [ESI + 0x7c],ECX",
            "MOV dword ptr [ESI + 0x8],EAX",
            "MOV dword ptr [ESI + 0x4],EDI",
            "JNZ 0x000069af",
            "CMP DL,byte ptr [ESI + 0x80]",
            "JNZ 0x00006a7e",
            "CMP dword ptr [ESI + 0x64],0x0",
            "JNZ 0x00006a0f",
            "MOV EAX,dword ptr [ESI + 0x14]",
            "MOV EDI,dword ptr [ESI + 0x8]",
            "CMP EAX,EDI",
            "JNC 0x000069c1",
            "MOV EDI,EAX",
            "XOR EAX,EAX",
            "TEST EDI,EDI",
            "JBE 0x000069d8",
            "MOV ECX,dword ptr [ESI + 0x4]",
            "MOV EDX,dword ptr [ESI + 0x10]",
            "MOV CL,byte ptr [ECX + EAX*0x1]",
            "MOV byte ptr [EDX + EAX*0x1],CL",
            "INC EAX",
            "CMP EAX,EDI",
            "JC 0x000069c7",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x10]",
            "PUSH dword ptr [ESI + 0x50]",
            "CALL 0x0000541f",
            "SUB dword ptr [ESI + 0x5c],EDI",
            "SUB dword ptr [ESI + 0x8],EDI",
            "SUB dword ptr [ESI + 0x14],EDI",
            "ADD dword ptr [ESI + 0x10],EDI",
            "ADD dword ptr [ESI + 0x4],EDI",
            "ADD dword ptr [ESI + 0x18],EDI",
            "ADD dword ptr [EBP + -0x4],EDI",
            "MOV dword ptr [ESI + 0x50],EAX",
            "MOV EAX,dword ptr [ESI + 0x5c]",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00006a59",
            "TEST EBX,EBX",
            "JZ 0x00006a59",
            "MOV byte ptr [EBX],0x1",
            "JMP 0x00006a59",
            "MOV EAX,dword ptr [ESI + 0x10]",
            "MOV EBX,dword ptr [ESI + 0x18]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "LEA EAX,[ESI + 0x4]",
            "PUSH 0x2",
            "PUSH EAX",
            "CALL 0x0000583c",
            "MOV EDI,dword ptr [ESI + 0x18]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "SUB EDI,EBX",
            "PUSH EDI",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH dword ptr [ESI + 0x50]",
            "CALL 0x0000541f",
            "SUB dword ptr [ESI + 0x5c],EDI",
            "ADD dword ptr [EBP + -0x4],EDI",
            "ADD ESP,0x14",
            "CMP dword ptr [EBP + -0x8],0x1",
            "MOV dword ptr [ESI + 0x50],EAX",
            "MOV EAX,dword ptr [ESI + 0x5c]",
            "JZ 0x00006a83",
            "TEST EAX,EAX",
            "JZ 0x00006a83",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JNZ 0x00006a8f",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "CMP dword ptr [ESI + 0x14],0x0",
            "JA 0x000068e0",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JNZ 0x00006a8f",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "JMP 0x00006a92",
            "TEST EBX,EBX",
            "JZ 0x00006a75",
            "MOV byte ptr [EBX],0x1",
            "XOR EAX,EAX",
            "JMP 0x00006a92",
            "OR EAX,0xffffffff",
            "JMP 0x00006a92",
            "PUSH -0x6a",
            "POP EAX",
            "JMP 0x00006a92",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "TEST EAX,EAX",
            "JZ 0x00006a69",
            "MOV byte ptr [EAX],0x1",
            "JMP 0x00006a69",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00006880",
            "end": "00006a96"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000688f",
                    "00006a26",
                    "00006a40",
                    "00006a50",
                    "00006a63",
                    "00006a8f"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006892",
                    "000069f6",
                    "00006a3a",
                    "00006a69"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00006880",
        "original_name": "FUN_00006880",
        "predicted_name": "FUN_0000583c.",
        "prediction_full_response": "The predicted function name is FUN_0000583c.</s>"
    },
    "00007572": {
        "decomp_code": "\nvoid __fastcall FUN_00007572(int param_1)\n\n{\n  if (*(void **)(param_1 + 0x138) != (void *)0x0) {\n    operator_delete(*(void **)(param_1 + 0x138));\n  }\n  *(undefined4 *)(param_1 + 0x138) = 0;\n  if (*(void **)(param_1 + 0x13c) != (void *)0x0) {\n    operator_delete(*(void **)(param_1 + 0x13c));\n  }\n  *(undefined4 *)(param_1 + 0x13c) = 0;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,ECX",
            "MOV EAX,dword ptr [EDI + 0x138]",
            "LEA ESI,[EDI + 0x138]",
            "TEST EAX,EAX",
            "JZ 0x0000758d",
            "PUSH EAX",
            "CALL 0x000076e8",
            "POP ECX",
            "AND dword ptr [ESI],0x0",
            "MOV EAX,dword ptr [EDI + 0x13c]",
            "LEA ESI,[EDI + 0x13c]",
            "TEST EAX,EAX",
            "JZ 0x000075a7",
            "PUSH EAX",
            "CALL 0x000076e8",
            "POP ECX",
            "AND dword ptr [ESI],0x0",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00007572",
            "end": "000075ac"
        },
        "variable_metadata": {},
        "func_name": "FUN_00007572",
        "original_name": "FUN_00007572",
        "predicted_name": "operator_delete_ptr",
        "prediction_full_response": "The predicted function name is operator_delete_ptr</s>"
    },
    "00006520": {
        "decomp_code": "\nint FUN_00006520(int param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 == 0) {\n    iVar1 = -0x66;\n  }\n  else if ((*(int *)(param_1 + 0x18) == 0) ||\n          (iVar1 = *(int *)(param_1 + 0x10) + 1, iVar1 == *(int *)(param_1 + 4))) {\n    iVar1 = -100;\n  }\n  else {\n    *(int *)(param_1 + 0x10) = iVar1;\n    *(int *)(param_1 + 0x14) =\n         *(int *)(param_1 + 0x14) +\n         *(int *)(param_1 + 0x50) + *(int *)(param_1 + 0x4c) + 0x2e + *(int *)(param_1 + 0x48);\n    iVar1 = FUN_000061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);\n    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);\n  }\n  return iVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "PUSH EDI",
            "XOR EDI,EDI",
            "CMP ESI,EDI",
            "JNZ 0x00006530",
            "PUSH -0x66",
            "JMP 0x00006540",
            "CMP dword ptr [ESI + 0x18],EDI",
            "JZ 0x0000653e",
            "MOV EAX,dword ptr [ESI + 0x10]",
            "INC EAX",
            "CMP EAX,dword ptr [ESI + 0x4]",
            "JNZ 0x00006543",
            "PUSH -0x64",
            "POP EAX",
            "JMP 0x00006577",
            "MOV ECX,dword ptr [ESI + 0x50]",
            "MOV EDX,dword ptr [ESI + 0x48]",
            "ADD ECX,dword ptr [ESI + 0x4c]",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "MOV dword ptr [ESI + 0x10],EAX",
            "PUSH EDI",
            "PUSH EDI",
            "LEA EAX,[ESI + 0x78]",
            "PUSH EDI",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x28]",
            "LEA ECX,[ECX + EDX*0x1 + 0x2e]",
            "ADD dword ptr [ESI + 0x14],ECX",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x000061e0",
            "ADD ESP,0x24",
            "XOR ECX,ECX",
            "CMP EAX,EDI",
            "SETZ CL",
            "MOV dword ptr [ESI + 0x18],ECX",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00006520",
            "end": "00006579"
        },
        "variable_metadata": {},
        "func_name": "FUN_00006520",
        "original_name": "FUN_00006520",
        "predicted_name": "FUN_00006200.",
        "prediction_full_response": "The predicted function name is FUN_00006200.</s>"
    },
    "0000254b": {
        "decomp_code": "\nbool FUN_0000254b(int *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  uint local_20;\n  uint local_1c;\n  int local_18;\n  uint local_14;\n  undefined4 local_10;\n  int local_c;\n  uint local_8;\n  \n  piVar1 = param_1;\n  iVar3 = *(ushort *)(*param_1 + 0x14) + 0x18 + *param_1;\n  local_20 = *(uint *)(iVar3 + 8);\n  local_1c = ~(param_1[0xe] - 1U) & local_20;\n  local_18 = FUN_0000264f(param_1,iVar3);\n  local_14 = *(uint *)(iVar3 + 0x24);\n  local_10 = 0;\n  iVar2 = *param_1;\n  param_1 = (int *)0x1;\n  if (1 < *(ushort *)(iVar2 + 6)) {\n    do {\n      local_8 = *(uint *)(iVar3 + 0x30);\n      uVar4 = ~(piVar1[0xe] - 1U) & local_8;\n      local_c = FUN_0000264f(piVar1,iVar3 + 0x28);\n      if ((local_1c == uVar4) || (uVar4 < local_18 + local_20)) {\n        uVar4 = *(uint *)(iVar3 + 0x4c);\n        if (((uVar4 & 0x2000000) == 0) || ((local_14 & 0x2000000) == 0)) {\n          local_14 = (uVar4 | local_14) & 0xfdffffff;\n        }\n        else {\n          local_14 = local_14 | uVar4;\n        }\n        local_18 = (local_c - local_20) + local_8;\n      }\n      else {\n        iVar2 = FUN_0000267b(piVar1,&local_20);\n        if (iVar2 == 0) {\n          return false;\n        }\n        local_20 = local_8;\n        local_18 = local_c;\n        local_14 = *(uint *)(iVar3 + 0x4c);\n        local_1c = uVar4;\n      }\n      param_1 = (int *)((int)param_1 + 1);\n      iVar3 = iVar3 + 0x28;\n    } while ((int)param_1 < (int)(uint)*(ushort *)(*piVar1 + 6));\n  }\n  local_10 = 1;\n  iVar3 = FUN_0000267b(piVar1,&local_20);\n  return iVar3 != 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x1c",
            "PUSH EBX",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EAX,dword ptr [EBX]",
            "MOVZX ECX,word ptr [EAX + 0x14]",
            "LEA ESI,[ECX + EAX*0x1 + 0x18]",
            "MOV ECX,dword ptr [EBX + 0x38]",
            "DEC ECX",
            "PUSH ESI",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "PUSH EBX",
            "NOT ECX",
            "AND ECX,EAX",
            "MOV dword ptr [EBP + -0x1c],EAX",
            "MOV dword ptr [EBP + -0x18],ECX",
            "CALL 0x0000264f",
            "POP ECX",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOV EAX,dword ptr [ESI + 0x24]",
            "AND dword ptr [EBP + -0xc],0x0",
            "POP ECX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "MOV ECX,dword ptr [EBX]",
            "PUSH 0x1",
            "POP EAX",
            "ADD ESI,0x28",
            "CMP word ptr [ECX + 0x6],AX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JBE 0x00002631",
            "MOV EDI,dword ptr [EBX + 0x38]",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "DEC EDI",
            "PUSH ESI",
            "NOT EDI",
            "PUSH EBX",
            "MOV dword ptr [EBP + -0x4],EAX",
            "AND EDI,EAX",
            "CALL 0x0000264f",
            "CMP dword ptr [EBP + -0x18],EDI",
            "MOV EDX,dword ptr [EBP + -0x1c]",
            "POP ECX",
            "MOV dword ptr [EBP + -0x8],EAX",
            "POP ECX",
            "JZ 0x000025ef",
            "MOV ECX,dword ptr [EBP + -0x14]",
            "ADD ECX,EDX",
            "CMP ECX,EDI",
            "JA 0x000025ef",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x0000267b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000264b",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EBP + -0x18],EDI",
            "MOV dword ptr [EBP + -0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOV EAX,dword ptr [ESI + 0x24]",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JMP 0x00002619",
            "MOV ECX,dword ptr [ESI + 0x24]",
            "MOV EDI,0x2000000",
            "TEST EDI,ECX",
            "JZ 0x00002605",
            "TEST dword ptr [EBP + -0x10],EDI",
            "JZ 0x00002605",
            "OR dword ptr [EBP + -0x10],ECX",
            "JMP 0x00002611",
            "OR ECX,dword ptr [EBP + -0x10]",
            "AND ECX,0xfdffffff",
            "MOV dword ptr [EBP + -0x10],ECX",
            "SUB EAX,EDX",
            "ADD EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOV EAX,dword ptr [EBX]",
            "INC dword ptr [EBP + 0x8]",
            "ADD ESI,0x28",
            "MOVZX EAX,word ptr [EAX + 0x6]",
            "CMP dword ptr [EBP + 0x8],EAX",
            "JL 0x0000259d",
            "PUSH 0x1",
            "POP EAX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x0000267b",
            "NEG EAX",
            "POP ECX",
            "SBB EAX,EAX",
            "POP ECX",
            "NEG EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET",
            "XOR EAX,EAX",
            "JMP 0x00002646"
        ],
        "function_address": {
            "start": "0000254b",
            "end": "0000264e"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000025b9",
                    "000025e1"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002571",
                    "000025b2",
                    "000025db"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000025a8",
                    "000025d8",
                    "00002613"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000257a",
                    "000025bf",
                    "000025e4",
                    "00002616"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002580",
                    "00002631"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000256e",
                    "000025b5",
                    "000025c8",
                    "000025de",
                    "00002634"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002585",
                    "000025ea",
                    "000025fb",
                    "00002600",
                    "00002605",
                    "0000260e"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000254b",
        "original_name": "FUN_0000254b",
        "predicted_name": "FUN_0000264f.",
        "prediction_full_response": "The predicted function name is FUN_0000264f.</s>"
    },
    "00002a46": {
        "decomp_code": "\nvoid __fastcall FUN_00002a46(undefined4 *param_1)\n\n{\n  *(undefined1 *)(param_1 + 1) = 0;\n  *param_1 = 0x40bc7c;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,ECX",
            "AND byte ptr [EAX + 0x4],0x0",
            "MOV dword ptr [EAX],0x40bc7c",
            "RET"
        ],
        "function_address": {
            "start": "00002a46",
            "end": "00002a52"
        },
        "variable_metadata": {},
        "func_name": "FUN_00002a46",
        "original_name": "FUN_00002a46",
        "predicted_name": "__gmon_start__",
        "prediction_full_response": "The predicted function name is __gmon_start__</s>"
    },
    "0000501f": {
        "decomp_code": "\nint FUN_0000501f(uint param_1,undefined4 param_2,int param_3,int *param_4,int *param_5,\n                undefined4 param_6,undefined4 param_7,undefined4 param_8,int param_9)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 local_8;\n  \n  local_8 = 0;\n  iVar1 = (**(code **)(param_9 + 0x20))(*(undefined4 *)(param_9 + 0x28),0x120,4);\n  if (iVar1 == 0) {\n    return -4;\n  }\n  iVar2 = FUN_00004c19(param_3,param_1,0x101,0x40ce6c,0x40cee8,param_6,param_4,param_8,&local_8,\n                       iVar1);\n  if (iVar2 == 0) {\n    if (*param_4 == 0) goto LAB_00005104;\n    iVar2 = FUN_00004c19(param_3 + param_1 * 4,param_2,0,0x40cf64,0x40cfdc,param_7,param_5,param_8,\n                         &local_8,iVar1);\n    if (iVar2 == 0) {\n      if ((*param_5 != 0) || (param_1 < 0x102)) {\n        iVar2 = 0;\n        goto LAB_00005110;\n      }\nLAB_000050e8:\n      *(undefined4 *)(param_9 + 0x18) = 0x40f750;\n    }\n    else {\n      if (iVar2 == -3) {\n        *(undefined4 *)(param_9 + 0x18) = 0x40f790;\n        goto LAB_00005110;\n      }\n      if (iVar2 != -5) {\n        if (iVar2 == -4) goto LAB_00005110;\n        goto LAB_000050e8;\n      }\n      *(undefined4 *)(param_9 + 0x18) = 0x40f774;\n    }\n  }\n  else {\n    if (iVar2 == -3) {\n      *(undefined4 *)(param_9 + 0x18) = 0x40f72c;\n      goto LAB_00005110;\n    }\n    if (iVar2 == -4) goto LAB_00005110;\nLAB_00005104:\n    *(undefined4 *)(param_9 + 0x18) = 0x40f70c;\n  }\n  iVar2 = -3;\nLAB_00005110:\n  (**(code **)(param_9 + 0x24))(*(undefined4 *)(param_9 + 0x28),iVar1);\n  return iVar2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "AND dword ptr [EBP + -0x4],0x0",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x28]",
            "PUSH 0x4",
            "PUSH 0x120",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0xc",
            "MOV dword ptr [EBP + 0x28],EAX",
            "TEST EAX,EAX",
            "JNZ 0x0000504a",
            "PUSH -0x4",
            "POP EAX",
            "JMP 0x0000511f",
            "PUSH EBX",
            "PUSH EDI",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "PUSH dword ptr [EBP + 0x24]",
            "MOV EDI,0x101",
            "PUSH dword ptr [EBP + 0x14]",
            "PUSH dword ptr [EBP + 0x1c]",
            "PUSH 0x40cee8",
            "PUSH 0x40ce6c",
            "PUSH EDI",
            "PUSH EBX",
            "PUSH dword ptr [EBP + 0x10]",
            "CALL 0x00004c19",
            "ADD ESP,0x28",
            "TEST EAX,EAX",
            "JNZ 0x000050f1",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "CMP dword ptr [EAX],0x0",
            "JZ 0x00005104",
            "PUSH dword ptr [EBP + 0x28]",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EBP + 0x24]",
            "LEA EAX,[EAX + EBX*0x4]",
            "PUSH dword ptr [EBP + 0x18]",
            "PUSH dword ptr [EBP + 0x20]",
            "PUSH 0x40cfdc",
            "PUSH 0x40cf64",
            "PUSH 0x0",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH EAX",
            "CALL 0x00004c19",
            "ADD ESP,0x28",
            "TEST EAX,EAX",
            "JNZ 0x000050c7",
            "MOV EAX,dword ptr [EBP + 0x18]",
            "CMP dword ptr [EAX],0x0",
            "JNZ 0x000050c3",
            "CMP EBX,EDI",
            "JA 0x000050e8",
            "XOR EDI,EDI",
            "JMP 0x00005110",
            "CMP EAX,-0x3",
            "JNZ 0x000050d5",
            "MOV dword ptr [ESI + 0x18],0x40f790",
            "JMP 0x0000510e",
            "CMP EAX,-0x5",
            "JNZ 0x000050e3",
            "MOV dword ptr [ESI + 0x18],0x40f774",
            "JMP 0x0000510b",
            "CMP EAX,-0x4",
            "JZ 0x0000510e",
            "MOV dword ptr [ESI + 0x18],0x40f750",
            "JMP 0x0000510b",
            "CMP EAX,-0x3",
            "JNZ 0x000050ff",
            "MOV dword ptr [ESI + 0x18],0x40f72c",
            "JMP 0x0000510e",
            "CMP EAX,-0x4",
            "JZ 0x0000510e",
            "MOV dword ptr [ESI + 0x18],0x40f70c",
            "PUSH -0x3",
            "POP EAX",
            "MOV EDI,EAX",
            "PUSH dword ptr [EBP + 0x28]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "POP ECX",
            "MOV EAX,EDI",
            "POP ECX",
            "POP EDI",
            "POP EBX",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "0000501f",
            "end": "00005121"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005023",
                    "0000504d",
                    "00005088"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000501f",
        "original_name": "FUN_0000501f",
        "predicted_name": "[PYTHON]",
        "prediction_full_response": "[PYTHON]\n\ndef get_predicted_function_name(decompiled_code):\n    # Check if the decompiled code includes the pattern \"if (something == something_else)\"\n    if \"if (\" in decompiled_code and \" == \" in decompiled_code:\n        # If the pattern is found, return the predicted function name\n        return \"compare_values\"\n    else:\n        # If the pattern is not found, return an empty string\n        return \"\"\n\n[/PYTHON]\n</s>"
    },
    "000076b4": {
        "decomp_code": "\nsize_t __cdecl strlen(char *_Str)\n\n{\n  size_t sVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076b4. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  sVar1 = (*pcRam00408130)();\n  return sVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408130]"
        ],
        "function_address": {
            "start": "000076b4",
            "end": "000076b9"
        },
        "variable_metadata": {
            "_Str": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            }
        },
        "func_name": "strlen",
        "original_name": "strlen",
        "predicted_name": "get_current_time",
        "prediction_full_response": "The predicted function name is get_current_time</s>"
    },
    "0000541f": {
        "decomp_code": "\nuint FUN_0000541f(uint param_1,byte *param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_2 == (byte *)0x0) {\n    return 0;\n  }\n  param_1 = ~param_1;\n  if (7 < param_3) {\n    uVar2 = param_3 >> 3;\n    do {\n      param_3 = param_3 - 8;\n      uVar1 = *(uint *)((param_1 & 0xff ^ (uint)*param_2) * 4 + 0x40d054) ^ param_1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[1]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[2]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[3]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[4]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[5]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      uVar1 = *(uint *)((uVar1 & 0xff ^ (uint)param_2[6]) * 4 + 0x40d054) ^ uVar1 >> 8;\n      param_1 = uVar1 >> 8 ^ *(uint *)((uVar1 & 0xff ^ (uint)param_2[7]) * 4 + 0x40d054);\n      param_2 = param_2 + 8;\n      uVar2 = uVar2 - 1;\n    } while (uVar2 != 0);\n  }\n  for (; param_3 != 0; param_3 = param_3 - 1) {\n    param_1 = param_1 >> 8 ^ *(uint *)((param_1 & 0xff ^ (uint)*param_2) * 4 + 0x40d054);\n    param_2 = param_2 + 1;\n  }\n  return ~param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EDX,dword ptr [EBP + 0xc]",
            "TEST EDX,EDX",
            "JNZ 0x0000542d",
            "XOR EAX,EAX",
            "POP EBP",
            "RET",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "CMP dword ptr [EBP + 0x10],0x8",
            "PUSH ESI",
            "PUSH EDI",
            "NOT EAX",
            "MOV ECX,0xff",
            "JC 0x0000550e",
            "MOV EDI,dword ptr [EBP + 0x10]",
            "PUSH EBX",
            "SHR EDI,0x3",
            "MOVZX EBX,byte ptr [EDX]",
            "MOV ESI,EAX",
            "SUB dword ptr [EBP + 0x10],0x8",
            "AND ESI,ECX",
            "XOR ESI,EBX",
            "MOV EBX,EAX",
            "SHR EBX,0x8",
            "MOV EAX,dword ptr [ESI*0x4 + 0x40d054]",
            "XOR EAX,EBX",
            "INC EDX",
            "MOV ESI,EAX",
            "MOVZX EBX,byte ptr [EDX]",
            "AND ESI,ECX",
            "XOR ESI,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV ESI,dword ptr [ESI*0x4 + 0x40d054]",
            "SHR EAX,0x8",
            "XOR ESI,EAX",
            "INC EDX",
            "MOV EAX,ESI",
            "AND EAX,ECX",
            "XOR EAX,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40d054]",
            "SHR ESI,0x8",
            "XOR EAX,ESI",
            "INC EDX",
            "MOV ESI,EAX",
            "AND ESI,ECX",
            "XOR ESI,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV ESI,dword ptr [ESI*0x4 + 0x40d054]",
            "SHR EAX,0x8",
            "XOR ESI,EAX",
            "INC EDX",
            "MOV EAX,ESI",
            "AND EAX,ECX",
            "XOR EAX,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40d054]",
            "SHR ESI,0x8",
            "XOR EAX,ESI",
            "INC EDX",
            "MOV ESI,EAX",
            "AND ESI,ECX",
            "XOR ESI,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV ESI,dword ptr [ESI*0x4 + 0x40d054]",
            "SHR EAX,0x8",
            "XOR ESI,EAX",
            "INC EDX",
            "MOV EAX,ESI",
            "AND EAX,ECX",
            "XOR EAX,EBX",
            "MOVZX EBX,byte ptr [EDX + 0x1]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40d054]",
            "SHR ESI,0x8",
            "XOR EAX,ESI",
            "INC EDX",
            "MOV ESI,EAX",
            "AND ESI,ECX",
            "XOR ESI,EBX",
            "SHR EAX,0x8",
            "MOV ESI,dword ptr [ESI*0x4 + 0x40d054]",
            "XOR EAX,ESI",
            "INC EDX",
            "DEC EDI",
            "JNZ 0x0000544a",
            "POP EBX",
            "CMP dword ptr [EBP + 0x10],0x0",
            "JZ 0x0000552f",
            "MOVZX EDI,byte ptr [EDX]",
            "MOV ESI,EAX",
            "AND ESI,ECX",
            "XOR ESI,EDI",
            "SHR EAX,0x8",
            "MOV ESI,dword ptr [ESI*0x4 + 0x40d054]",
            "XOR EAX,ESI",
            "INC EDX",
            "DEC dword ptr [EBP + 0x10]",
            "JNZ 0x00005514",
            "POP EDI",
            "POP ESI",
            "NOT EAX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "0000541f",
            "end": "00005534"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000541f",
        "original_name": "FUN_0000541f",
        "predicted_name": "crc32_le.",
        "prediction_full_response": "The predicted function name is crc32_le.</s>"
    },
    "00006a97": {
        "decomp_code": "\nundefined4 FUN_00006a97(int param_1)\n\n{\n  int *piVar1;\n  code *pcVar2;\n  undefined4 local_4;\n  \n  pcVar2 = pcRam00408174;\n  local_4 = 0;\n  if ((param_1 == 0) || (piVar1 = *(int **)(param_1 + 0x7c), piVar1 == (int *)0x0)) {\n    local_4 = 0xffffff9a;\n  }\n  else {\n    if ((piVar1[0x17] == 0) && (piVar1[0x14] != piVar1[0x15])) {\n      local_4 = 0xffffff97;\n    }\n    if (*piVar1 != 0) {\n      (*pcRam00408174)(*piVar1);\n      *piVar1 = 0;\n    }\n    *piVar1 = 0;\n    if (piVar1[0x10] != 0) {\n      FUN_00005739(piVar1 + 1);\n    }\n    piVar1[0x10] = 0;\n    (*pcVar2)(piVar1);\n    *(undefined4 *)(param_1 + 0x7c) = 0;\n  }\n  return local_4;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ECX",
            "PUSH EBX",
            "MOV EBX,dword ptr [ESP + 0xc]",
            "PUSH EBP",
            "XOR EBP,EBP",
            "CMP EBX,EBP",
            "PUSH ESI",
            "MOV dword ptr [ESP + 0xc],EBP",
            "JZ 0x00006ab0",
            "MOV ESI,dword ptr [EBX + 0x7c]",
            "CMP ESI,EBP",
            "JNZ 0x00006ab5",
            "PUSH -0x66",
            "POP EAX",
            "JMP 0x00006afd",
            "CMP dword ptr [ESI + 0x5c],EBP",
            "JNZ 0x00006aca",
            "MOV EAX,dword ptr [ESI + 0x50]",
            "CMP EAX,dword ptr [ESI + 0x54]",
            "JZ 0x00006aca",
            "MOV dword ptr [ESP + 0xc],0xffffff97",
            "MOV EAX,dword ptr [ESI]",
            "PUSH EDI",
            "MOV EDI,dword ptr [0x00408174]",
            "CMP EAX,EBP",
            "JZ 0x00006add",
            "PUSH EAX",
            "CALL EDI",
            "POP ECX",
            "MOV dword ptr [ESI],EBP",
            "CMP dword ptr [ESI + 0x40],EBP",
            "MOV dword ptr [ESI],EBP",
            "JZ 0x00006aee",
            "LEA EAX,[ESI + 0x4]",
            "PUSH EAX",
            "CALL 0x00005739",
            "POP ECX",
            "PUSH ESI",
            "MOV dword ptr [ESI + 0x40],EBP",
            "CALL EDI",
            "MOV EAX,dword ptr [ESP + 0x14]",
            "POP ECX",
            "MOV dword ptr [EBX + 0x7c],EBP",
            "POP EDI",
            "POP ESI",
            "POP EBP",
            "POP EBX",
            "POP ECX",
            "RET"
        ],
        "function_address": {
            "start": "00006a97",
            "end": "00006b01"
        },
        "variable_metadata": {
            "local_4": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006aa3",
                    "00006ac2",
                    "00006af4"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00006a97",
        "original_name": "FUN_00006a97",
        "predicted_name": "FUN_00005739.",
        "prediction_full_response": "The predicted function name is FUN_00005739.</s>"
    },
    "00003cfc": {
        "decomp_code": "\nvoid FUN_00003cfc(int param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  \n  iVar1 = *param_2;\n  iVar2 = param_2[1];\n  uVar3 = *(undefined4 *)(param_1 + 0x34);\n  if (**(uint **)(param_1 + 4) < 10) {\n                    /* WARNING: Could not emulate address calculation at 0x00003d47 */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(**(uint **)(param_1 + 4) * 4 + 0x404287))();\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x20);\n  *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x1c);\n  param_2[1] = iVar2;\n  iVar2 = *param_2;\n  *param_2 = iVar1;\n  param_2[2] = param_2[2] + (iVar1 - iVar2);\n  *(undefined4 *)(param_1 + 0x34) = uVar3;\n  FUN_00003bd6(param_1,param_2,0xfffffffe);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x18",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0xc]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "MOV EAX,dword ptr [ESI]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV EDX,dword ptr [EDI + 0x34]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "MOV EAX,dword ptr [EDI + 0x20]",
            "MOV EBX,dword ptr [EDI + 0x4]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [EDI + 0x1c]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "CMP EDX,EAX",
            "JNC 0x00003d34",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x00003d39",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "SUB EAX,EDX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "MOV ECX,dword ptr [EBX]",
            "CMP ECX,0x9",
            "JA 0x00004255",
            "JMP dword ptr [ECX*0x4 + 0x404287]",
            "CMP EAX,0x102",
            "JC 0x00003dea",
            "CMP dword ptr [EBP + -0x8],0xa",
            "JC 0x00003dea",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH ESI",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,EAX",
            "PUSH EDI",
            "SUB ECX,dword ptr [ESI]",
            "MOV dword ptr [ESI],EAX",
            "ADD dword ptr [ESI + 0x8],ECX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "PUSH dword ptr [EBX + 0x18]",
            "MOVZX EAX,byte ptr [EBX + 0x11]",
            "PUSH dword ptr [EBX + 0x14]",
            "PUSH EAX",
            "MOVZX EAX,byte ptr [EBX + 0x10]",
            "PUSH EAX",
            "CALL 0x0000514d",
            "MOV dword ptr [EBP + 0x10],EAX",
            "MOV EAX,dword ptr [ESI]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV EDX,dword ptr [EDI + 0x34]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "MOV EAX,dword ptr [EDI + 0x20]",
            "ADD ESP,0x18",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [EDI + 0x1c]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "CMP EDX,EAX",
            "JNC 0x00003dc7",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x00003dcc",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "SUB EAX,EDX",
            "CMP dword ptr [EBP + 0x10],0x0",
            "MOV dword ptr [EBP + -0xc],EAX",
            "JZ 0x00003dea",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "DEC ECX",
            "NEG ECX",
            "SBB ECX,ECX",
            "AND ECX,0x2",
            "ADD ECX,0x7",
            "MOV dword ptr [EBX],ECX",
            "JMP 0x00003d3c",
            "MOVZX EAX,byte ptr [EBX + 0x10]",
            "MOV dword ptr [EBX + 0xc],EAX",
            "MOV EAX,dword ptr [EBX + 0x14]",
            "MOV dword ptr [EBX + 0x8],EAX",
            "MOV dword ptr [EBX],0x1",
            "MOV EAX,dword ptr [EBX + 0xc]",
            "CMP dword ptr [EBP + 0x8],EAX",
            "JNC 0x00003e2d",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JZ 0x0000415f",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x8]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0xc],EAX",
            "INC dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + 0x8],0x8",
            "JMP 0x00003dfd",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV ECX,dword ptr [EBX + 0x8]",
            "AND EAX,dword ptr [EBP + 0xc]",
            "LEA EAX,[ECX + EAX*0x8]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "MOVZX EAX,byte ptr [EAX + 0x1]",
            "SHR dword ptr [EBP + 0xc],CL",
            "MOV ECX,dword ptr [EBP + -0x14]",
            "SUB dword ptr [EBP + 0x8],EAX",
            "MOVZX EAX,byte ptr [ECX]",
            "TEST EAX,EAX",
            "JNZ 0x00003e6c",
            "MOV EAX,dword ptr [ECX + 0x4]",
            "MOV dword ptr [EBX],0x6",
            "MOV dword ptr [EBX + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "JMP 0x00003d3c",
            "TEST AL,0x10",
            "JZ 0x00003e84",
            "AND EAX,0xf",
            "MOV dword ptr [EBX + 0x8],EAX",
            "MOV EAX,dword ptr [ECX + 0x4]",
            "MOV dword ptr [EBX + 0x4],EAX",
            "MOV dword ptr [EBX],0x2",
            "JMP 0x00003e64",
            "TEST AL,0x40",
            "JZ 0x00003f71",
            "TEST AL,0x20",
            "JZ 0x00004171",
            "MOV dword ptr [EBX],0x7",
            "JMP 0x00003e64",
            "MOV EAX,dword ptr [EBX + 0x8]",
            "CMP dword ptr [EBP + 0x8],EAX",
            "JNC 0x00003ecc",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JZ 0x0000415f",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x8]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0xc],EAX",
            "INC dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + 0x8],0x8",
            "JMP 0x00003e9c",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV ECX,dword ptr [EBX + 0x8]",
            "AND EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EBX],0x3",
            "SHR dword ptr [EBP + 0xc],CL",
            "ADD dword ptr [EBX + 0x4],EAX",
            "MOV EAX,ECX",
            "SUB dword ptr [EBP + 0x8],EAX",
            "MOVZX EAX,byte ptr [EBX + 0x11]",
            "MOV dword ptr [EBX + 0xc],EAX",
            "MOV EAX,dword ptr [EBX + 0x18]",
            "MOV dword ptr [EBX + 0x8],EAX",
            "MOV EAX,dword ptr [EBX + 0xc]",
            "CMP dword ptr [EBP + 0x8],EAX",
            "JNC 0x00003f27",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JZ 0x0000415f",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x8]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0xc],EAX",
            "INC dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + 0x8],0x8",
            "JMP 0x00003ef7",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV ECX,dword ptr [EBX + 0x8]",
            "AND EAX,dword ptr [EBP + 0xc]",
            "LEA EAX,[ECX + EAX*0x8]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "MOVZX EAX,byte ptr [EAX + 0x1]",
            "SHR dword ptr [EBP + 0xc],CL",
            "MOV ECX,dword ptr [EBP + -0x14]",
            "SUB dword ptr [EBP + 0x8],EAX",
            "MOVZX EAX,byte ptr [ECX]",
            "TEST AL,0x10",
            "JZ 0x00003f69",
            "AND EAX,0xf",
            "MOV dword ptr [EBX + 0x8],EAX",
            "MOV EAX,dword ptr [ECX + 0x4]",
            "MOV dword ptr [EBX + 0xc],EAX",
            "MOV dword ptr [EBX],0x4",
            "JMP 0x00003e64",
            "TEST AL,0x40",
            "JNZ 0x000041a6",
            "MOV dword ptr [EBX + 0xc],EAX",
            "MOV EAX,dword ptr [ECX + 0x4]",
            "LEA EAX,[ECX + EAX*0x8]",
            "MOV dword ptr [EBX + 0x8],EAX",
            "JMP 0x00003e64",
            "MOV EAX,dword ptr [EBX + 0x8]",
            "CMP dword ptr [EBP + 0x8],EAX",
            "JNC 0x00003fb2",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JZ 0x0000415f",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x8]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0xc],EAX",
            "INC dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + 0x8],0x8",
            "JMP 0x00003f82",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV ECX,dword ptr [EBX + 0x8]",
            "AND EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EBX],0x5",
            "SHR dword ptr [EBP + 0xc],CL",
            "ADD dword ptr [EBX + 0xc],EAX",
            "MOV EAX,ECX",
            "SUB dword ptr [EBP + 0x8],EAX",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "MOV EAX,EDX",
            "SUB EAX,dword ptr [EBX + 0xc]",
            "CMP EAX,ECX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JNC 0x00003ff5",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "SUB EAX,ECX",
            "MOV dword ptr [EBP + -0x18],EAX",
            "MOV EAX,dword ptr [EBP + -0x10]",
            "ADD EAX,dword ptr [EBP + -0x18]",
            "CMP EAX,dword ptr [EDI + 0x28]",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JC 0x00003fe7",
            "CMP dword ptr [EBX + 0x4],0x0",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "JZ 0x00004157",
            "TEST EAX,EAX",
            "JNZ 0x00004090",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "CMP EDX,EAX",
            "MOV dword ptr [EBP + -0x14],EAX",
            "JNZ 0x00004032",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "CMP EAX,ECX",
            "JZ 0x00004032",
            "MOV EDX,ECX",
            "CMP EDX,EAX",
            "JNC 0x00004029",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x0000402e",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "TEST EAX,EAX",
            "JNZ 0x00004090",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV dword ptr [EDI + 0x34],EDX",
            "PUSH ESI",
            "PUSH EDI",
            "CALL 0x00003bd6",
            "MOV EDX,dword ptr [EDI + 0x34]",
            "MOV dword ptr [EBP + 0x10],EAX",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "ADD ESP,0xc",
            "CMP EDX,EAX",
            "MOV dword ptr [EBP + -0x18],EAX",
            "JNC 0x00004057",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x0000405c",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "SUB EAX,EDX",
            "MOV ECX,dword ptr [EDI + 0x2c]",
            "MOV dword ptr [EBP + -0xc],EAX",
            "CMP EDX,ECX",
            "MOV dword ptr [EBP + -0x14],ECX",
            "JNZ 0x00004088",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "CMP EAX,ECX",
            "JZ 0x00004085",
            "MOV EDX,ECX",
            "CMP EDX,EAX",
            "JNC 0x0000407e",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x00004088",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "JMP 0x00004088",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "TEST EAX,EAX",
            "JZ 0x000041b5",
            "MOV ECX,dword ptr [EBP + -0x10]",
            "AND dword ptr [EBP + 0x10],0x0",
            "MOV CL,byte ptr [ECX]",
            "MOV byte ptr [EDX],CL",
            "INC EDX",
            "INC dword ptr [EBP + -0x10]",
            "DEC EAX",
            "MOV ECX,dword ptr [EBP + -0x10]",
            "MOV dword ptr [EBP + -0xc],EAX",
            "CMP ECX,dword ptr [EDI + 0x2c]",
            "JNZ 0x000040b1",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "MOV dword ptr [EBP + -0x10],ECX",
            "DEC dword ptr [EBX + 0x4]",
            "JNZ 0x00004002",
            "JMP 0x00004157",
            "TEST EAX,EAX",
            "JNZ 0x00004149",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "CMP EDX,EAX",
            "MOV dword ptr [EBP + -0x14],EAX",
            "JNZ 0x000040ef",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "CMP EAX,ECX",
            "JZ 0x000040ef",
            "MOV EDX,ECX",
            "CMP EDX,EAX",
            "JNC 0x000040e6",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x000040eb",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "TEST EAX,EAX",
            "JNZ 0x00004149",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV dword ptr [EDI + 0x34],EDX",
            "PUSH ESI",
            "PUSH EDI",
            "CALL 0x00003bd6",
            "MOV EDX,dword ptr [EDI + 0x34]",
            "MOV dword ptr [EBP + 0x10],EAX",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "ADD ESP,0xc",
            "CMP EDX,EAX",
            "MOV dword ptr [EBP + -0x18],EAX",
            "JNC 0x00004114",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x00004119",
            "MOV EAX,dword ptr [EDI + 0x2c]",
            "SUB EAX,EDX",
            "MOV ECX,dword ptr [EDI + 0x2c]",
            "MOV dword ptr [EBP + -0xc],EAX",
            "CMP EDX,ECX",
            "MOV dword ptr [EBP + -0x14],ECX",
            "JNZ 0x00004145",
            "MOV ECX,dword ptr [EDI + 0x28]",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "CMP EAX,ECX",
            "JZ 0x00004142",
            "MOV EDX,ECX",
            "CMP EDX,EAX",
            "JNC 0x0000413b",
            "SUB EAX,EDX",
            "DEC EAX",
            "JMP 0x00004145",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "JMP 0x00004145",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "TEST EAX,EAX",
            "JZ 0x000041b5",
            "MOV CL,byte ptr [EBX + 0x8]",
            "AND dword ptr [EBP + 0x10],0x0",
            "MOV byte ptr [EDX],CL",
            "INC EDX",
            "DEC EAX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "AND dword ptr [EBX],0x0",
            "JMP 0x00003d3c",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "AND dword ptr [ESI + 0x4],0x0",
            "JMP 0x000041c7",
            "MOV dword ptr [EBX],0x9",
            "MOV dword ptr [ESI + 0x18],0x40f630",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH -0x3",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,EAX",
            "SUB ECX,dword ptr [ESI]",
            "MOV dword ptr [ESI],EAX",
            "ADD dword ptr [ESI + 0x8],ECX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "JMP 0x00004278",
            "MOV dword ptr [EBX],0x9",
            "MOV dword ptr [ESI + 0x18],0x40f618",
            "JMP 0x0000417e",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV ECX,EAX",
            "SUB ECX,dword ptr [ESI]",
            "MOV dword ptr [ESI],EAX",
            "ADD dword ptr [ESI + 0x8],ECX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "JMP 0x00004278",
            "CMP dword ptr [EBP + 0x8],0x7",
            "JBE 0x000041ee",
            "SUB dword ptr [EBP + 0x8],0x8",
            "INC dword ptr [EBP + -0x8]",
            "DEC dword ptr [EBP + -0x4]",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV dword ptr [EDI + 0x34],EDX",
            "PUSH ESI",
            "PUSH EDI",
            "CALL 0x00003bd6",
            "MOV EDX,dword ptr [EDI + 0x34]",
            "ADD ESP,0xc",
            "CMP dword ptr [EDI + 0x30],EDX",
            "JZ 0x0000422a",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "PUSH EAX",
            "MOV dword ptr [EDI + 0x20],ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],ECX",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],ECX",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV EBX,ECX",
            "SUB EBX,dword ptr [ESI]",
            "MOV dword ptr [ESI],ECX",
            "ADD dword ptr [ESI + 0x8],EBX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "JMP 0x00004278",
            "MOV dword ptr [EBX],0x8",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH 0x1",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,EAX",
            "SUB ECX,dword ptr [ESI]",
            "MOV dword ptr [ESI],EAX",
            "ADD dword ptr [ESI + 0x8],ECX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "JMP 0x00004278",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH -0x2",
            "MOV dword ptr [EDI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EDI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV ECX,EAX",
            "SUB ECX,dword ptr [ESI]",
            "MOV dword ptr [ESI],EAX",
            "ADD dword ptr [ESI + 0x8],ECX",
            "MOV dword ptr [EDI + 0x34],EDX",
            "PUSH ESI",
            "PUSH EDI",
            "CALL 0x00003bd6",
            "ADD ESP,0xc",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00003cfc",
            "end": "00004286"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003d16",
                    "00003d59",
                    "00003d70",
                    "00003da9",
                    "00003e05",
                    "00003e19",
                    "00003ea4",
                    "00003eb8",
                    "00003eff",
                    "00003f13",
                    "00003f8a",
                    "00003f9e",
                    "0000418c",
                    "000041c1",
                    "000041e8",
                    "00004213",
                    "0000423e",
                    "00004263"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003fe4",
                    "00003fea",
                    "0000404d",
                    "0000406c",
                    "0000410a",
                    "00004129"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003d0d",
                    "00003d76",
                    "00003da0",
                    "00003e0f",
                    "00003e24",
                    "00003eae",
                    "00003ec3",
                    "00003f09",
                    "00003f1e",
                    "00003f94",
                    "00003fa9",
                    "00004192",
                    "000041c7",
                    "000041eb",
                    "00004219",
                    "00004244",
                    "00004269"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003e3d",
                    "00003e4b",
                    "00003f37",
                    "00003f45",
                    "0000400f",
                    "00004029",
                    "00004064",
                    "0000407e",
                    "000040cc",
                    "000040e6",
                    "00004121",
                    "0000413b"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003d39",
                    "00003dd0",
                    "00003e64",
                    "00003ff9",
                    "0000405f",
                    "00004085",
                    "000040a3",
                    "0000411c",
                    "00004142",
                    "00004154"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003fda",
                    "00003fe7",
                    "00003ff0",
                    "00004090",
                    "0000409c",
                    "000040a0",
                    "000040ae"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00003cfc",
        "original_name": "FUN_00003cfc",
        "predicted_name": "FUN_00003d47.",
        "prediction_full_response": "The predicted function name is FUN_00003d47.</s>"
    },
    "00002a53": {
        "decomp_code": "\nvoid * __thiscall FUN_00002a53(void *param_1,byte param_2)\n\n{\n  FUN_00002a6f();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "CALL 0x00002a6f",
            "TEST byte ptr [ESP + 0x8],0x1",
            "JZ 0x00002a69",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "MOV EAX,ESI",
            "POP ESI",
            "RET 0x4"
        ],
        "function_address": {
            "start": "00002a53",
            "end": "00002a6e"
        },
        "variable_metadata": {},
        "func_name": "FUN_00002a53",
        "original_name": "FUN_00002a53",
        "predicted_name": "operator_delete_or_not",
        "prediction_full_response": "The predicted function name is operator_delete_or_not</s>"
    },
    "0000514d": {
        "decomp_code": "\nundefined4 FUN_0000514d(int param_1,int param_2,int param_3,int param_4,int param_5,int *param_6)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int *piVar3;\n  int iVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  byte *pbVar12;\n  undefined4 uStack_2c;\n  byte *local_14;\n  byte *local_10;\n  byte *local_c;\n  uint local_8;\n  \n  piVar3 = param_6;\n  local_10 = *(byte **)(param_5 + 0x34);\n  uVar9 = *(uint *)(param_5 + 0x1c);\n  local_c = (byte *)*param_6;\n  local_8 = param_6[1];\n  param_6 = *(int **)(param_5 + 0x20);\n  if (local_10 < *(byte **)(param_5 + 0x30)) {\n    local_14 = *(byte **)(param_5 + 0x30) + (-1 - (int)local_10);\n  }\n  else {\n    local_14 = (byte *)(*(int *)(param_5 + 0x2c) - (int)local_10);\n  }\n  uVar8 = *(uint *)(param_1 * 4 + 0x40bca8);\n  uVar2 = *(uint *)(param_2 * 4 + 0x40bca8);\n  do {\n    for (; uVar9 < 0x14; uVar9 = uVar9 + 8) {\n      local_8 = local_8 - 1;\n      param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n      local_c = local_c + 1;\n    }\n    pbVar12 = (byte *)(param_3 + (uVar8 & (uint)param_6) * 8);\n    bVar1 = *pbVar12;\nLAB_000051d5:\n    uVar6 = (uint)bVar1;\n    if (uVar6 != 0) {\n      param_6 = (int *)((uint)param_6 >> (pbVar12[1] & 0x1f));\n      uVar9 = uVar9 - pbVar12[1];\n      if ((bVar1 & 0x10) != 0) {\n        uVar6 = uVar6 & 0xf;\n        uVar10 = *(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6;\n        param_6 = (int *)((uint)param_6 >> (sbyte)uVar6);\n        uVar10 = uVar10 + *(int *)(pbVar12 + 4);\n        for (uVar9 = uVar9 - uVar6; uVar9 < 0xf; uVar9 = uVar9 + 8) {\n          local_8 = local_8 - 1;\n          param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n          local_c = local_c + 1;\n        }\n        uVar6 = uVar2 & (uint)param_6;\n        iVar4 = param_4 + uVar6 * 8;\n        param_6 = (int *)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));\n        uVar9 = uVar9 - *(byte *)(iVar4 + 1);\n        bVar1 = *(byte *)(param_4 + uVar6 * 8);\n        while ((bVar1 & 0x10) == 0) {\n          if ((bVar1 & 0x40) != 0) {\n            piVar3[6] = 0x40f618;\n            uVar8 = piVar3[1] - local_8;\n            if (uVar9 >> 3 < piVar3[1] - local_8) {\n              uVar8 = uVar9 >> 3;\n            }\n            uStack_2c = 0xfffffffd;\n            goto LAB_000053ed;\n          }\n          iVar7 = (*(uint *)((uint)bVar1 * 4 + 0x40bca8) & (uint)param_6) + *(int *)(iVar4 + 4);\n          pbVar12 = (byte *)(iVar4 + iVar7 * 8);\n          iVar4 = iVar4 + iVar7 * 8;\n          param_6 = (int *)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));\n          uVar9 = uVar9 - *(byte *)(iVar4 + 1);\n          bVar1 = *pbVar12;\n        }\n        uVar6 = bVar1 & 0xf;\n        for (; uVar9 < uVar6; uVar9 = uVar9 + 8) {\n          local_8 = local_8 - 1;\n          param_6 = (int *)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));\n          local_c = local_c + 1;\n        }\n        uVar11 = *(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6;\n        uVar9 = uVar9 - uVar6;\n        param_6 = (int *)((uint)param_6 >> (sbyte)uVar6);\n        local_14 = local_14 + -uVar10;\n        pbVar5 = local_10 + -(uVar11 + *(int *)(iVar4 + 4));\n        pbVar12 = *(byte **)(param_5 + 0x28);\n        if (pbVar5 < pbVar12) {\n          do {\n            pbVar5 = pbVar5 + (*(int *)(param_5 + 0x2c) - (int)pbVar12);\n          } while (pbVar5 < pbVar12);\n          uVar6 = *(int *)(param_5 + 0x2c) - (int)pbVar5;\n          if (uVar6 < uVar10) {\n            param_1 = uVar10 - uVar6;\n            do {\n              *local_10 = *pbVar5;\n              local_10 = local_10 + 1;\n              pbVar5 = pbVar5 + 1;\n              uVar6 = uVar6 - 1;\n            } while (uVar6 != 0);\n            pbVar12 = *(byte **)(param_5 + 0x28);\n            do {\n              *local_10 = *pbVar12;\n              local_10 = local_10 + 1;\n              pbVar12 = pbVar12 + 1;\n              param_1 = param_1 + -1;\n            } while (param_1 != 0);\n          }\n          else {\n            *local_10 = *pbVar5;\n            local_10[1] = pbVar5[1];\n            local_10 = local_10 + 2;\n            pbVar5 = pbVar5 + 2;\n            param_1 = uVar10 - 2;\n            do {\n              *local_10 = *pbVar5;\n              local_10 = local_10 + 1;\n              pbVar5 = pbVar5 + 1;\n              param_1 = param_1 + -1;\n            } while (param_1 != 0);\n          }\n        }\n        else {\n          *local_10 = *pbVar5;\n          local_10[1] = pbVar5[1];\n          local_10 = local_10 + 2;\n          pbVar5 = pbVar5 + 2;\n          param_1 = uVar10 - 2;\n          do {\n            *local_10 = *pbVar5;\n            local_10 = local_10 + 1;\n            pbVar5 = pbVar5 + 1;\n            param_1 = param_1 + -1;\n          } while (param_1 != 0);\n        }\n        goto LAB_0000536f;\n      }\n      if ((bVar1 & 0x40) == 0) break;\n      if ((bVar1 & 0x20) == 0) {\n        piVar3[6] = 0x40f630;\n        uVar8 = piVar3[1] - local_8;\n        if (uVar9 >> 3 < piVar3[1] - local_8) {\n          uVar8 = uVar9 >> 3;\n        }\n        uStack_2c = 0xfffffffd;\n      }\n      else {\n        uVar8 = piVar3[1] - local_8;\n        if (uVar9 >> 3 < piVar3[1] - local_8) {\n          uVar8 = uVar9 >> 3;\n        }\n        uStack_2c = 1;\n      }\n      goto LAB_000053ed;\n    }\n    param_6 = (int *)((uint)param_6 >> (pbVar12[1] & 0x1f));\n    uVar9 = uVar9 - pbVar12[1];\n    local_14 = local_14 + -1;\n    *local_10 = pbVar12[4];\n    local_10 = local_10 + 1;\nLAB_0000536f:\n    if ((local_14 < (byte *)0x102) || (local_8 < 10)) {\n      uVar8 = piVar3[1] - local_8;\n      if (uVar9 >> 3 < piVar3[1] - local_8) {\n        uVar8 = uVar9 >> 3;\n      }\n      uStack_2c = 0;\nLAB_000053ed:\n      *(int **)(param_5 + 0x20) = param_6;\n      *(uint *)(param_5 + 0x1c) = uVar9 + uVar8 * -8;\n      piVar3[1] = uVar8 + local_8;\n      iVar4 = *piVar3;\n      *piVar3 = (int)local_c - uVar8;\n      piVar3[2] = piVar3[2] + (((int)local_c - uVar8) - iVar4);\n      *(byte **)(param_5 + 0x34) = local_10;\n      return uStack_2c;\n    }\n  } while( true );\n  pbVar12 = pbVar12 + ((*(uint *)(uVar6 * 4 + 0x40bca8) & (uint)param_6) + *(int *)(pbVar12 + 4)) *\n                      8;\n  bVar1 = *pbVar12;\n  goto LAB_000051d5;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x18",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x18]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x1c]",
            "MOV ECX,dword ptr [ESI + 0x34]",
            "MOV EDX,dword ptr [ESI + 0x1c]",
            "MOV EAX,dword ptr [EDI]",
            "MOV dword ptr [EBP + -0xc],ECX",
            "MOV dword ptr [EBP + -0x8],EAX",
            "MOV EAX,dword ptr [EDI + 0x4]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [ESI + 0x20]",
            "MOV dword ptr [EBP + 0x1c],EAX",
            "MOV EAX,dword ptr [ESI + 0x30]",
            "CMP ECX,EAX",
            "JNC 0x00005182",
            "SUB EAX,ECX",
            "DEC EAX",
            "JMP 0x00005187",
            "MOV EAX,dword ptr [ESI + 0x2c]",
            "SUB EAX,ECX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "CMP EDX,0x14",
            "JNC 0x000051c1",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "DEC dword ptr [EBP + -0x4]",
            "MOV ECX,EDX",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x1c],EAX",
            "INC dword ptr [EBP + -0x8]",
            "ADD EDX,0x8",
            "JMP 0x000051a4",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "AND EAX,dword ptr [EBP + 0x1c]",
            "LEA EAX,[ECX + EAX*0x8]",
            "MOVZX ECX,byte ptr [EAX]",
            "MOV dword ptr [EBP + 0x8],ECX",
            "TEST ECX,ECX",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "JZ 0x00005358",
            "SHR dword ptr [EBP + 0x1c],CL",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SUB EDX,ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "TEST CL,0x10",
            "JNZ 0x00005213",
            "TEST CL,0x40",
            "JNZ 0x000053b8",
            "MOV ECX,dword ptr [ECX*0x4 + 0x40bca8]",
            "AND ECX,dword ptr [EBP + 0x1c]",
            "ADD ECX,dword ptr [EAX + 0x4]",
            "LEA EAX,[EAX + ECX*0x8]",
            "MOVZX ECX,byte ptr [EAX]",
            "MOV dword ptr [EBP + 0x8],ECX",
            "TEST ECX,ECX",
            "JMP 0x000051d5",
            "AND ECX,0xf",
            "MOV ESI,dword ptr [ECX*0x4 + 0x40bca8]",
            "AND ESI,dword ptr [EBP + 0x1c]",
            "SHR dword ptr [EBP + 0x1c],CL",
            "ADD ESI,dword ptr [EAX + 0x4]",
            "SUB EDX,ECX",
            "MOV dword ptr [EBP + 0x8],ESI",
            "CMP EDX,0xf",
            "JNC 0x00005248",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "DEC dword ptr [EBP + -0x4]",
            "MOV ECX,EDX",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x1c],EAX",
            "INC dword ptr [EBP + -0x8]",
            "ADD EDX,0x8",
            "JMP 0x0000522b",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV ECX,dword ptr [EBP + 0x14]",
            "AND EAX,dword ptr [EBP + 0x1c]",
            "MOVZX EBX,byte ptr [ECX + EAX*0x8]",
            "LEA EAX,[ECX + EAX*0x8]",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SHR dword ptr [EBP + 0x1c],CL",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SUB EDX,ECX",
            "TEST BL,0x10",
            "JNZ 0x00005295",
            "TEST BL,0x40",
            "JNZ 0x00005383",
            "MOV ECX,dword ptr [EBX*0x4 + 0x40bca8]",
            "AND ECX,dword ptr [EBP + 0x1c]",
            "ADD ECX,dword ptr [EAX + 0x4]",
            "MOVZX EBX,byte ptr [EAX + ECX*0x8]",
            "LEA EAX,[EAX + ECX*0x8]",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SHR dword ptr [EBP + 0x1c],CL",
            "MOV dword ptr [EBP + -0x18],ECX",
            "SUB EDX,ECX",
            "JMP 0x00005265",
            "AND EBX,0xf",
            "CMP EDX,EBX",
            "JNC 0x000052b4",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "DEC dword ptr [EBP + -0x4]",
            "MOVZX ESI,byte ptr [ECX]",
            "MOV ECX,EDX",
            "SHL ESI,CL",
            "OR dword ptr [EBP + 0x1c],ESI",
            "INC dword ptr [EBP + -0x8]",
            "ADD EDX,0x8",
            "JMP 0x00005298",
            "MOV ESI,dword ptr [EBX*0x4 + 0x40bca8]",
            "MOV ECX,EBX",
            "AND ESI,dword ptr [EBP + 0x1c]",
            "SUB EDX,EBX",
            "SHR dword ptr [EBP + 0x1c],CL",
            "ADD ESI,dword ptr [EAX + 0x4]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "SUB dword ptr [EBP + -0x10],EAX",
            "MOV EBX,dword ptr [EBP + 0x18]",
            "MOV EAX,ECX",
            "SUB EAX,ESI",
            "MOV ESI,dword ptr [EBX + 0x28]",
            "CMP EAX,ESI",
            "JNC 0x0000533a",
            "MOV EBX,dword ptr [EBX + 0x2c]",
            "MOV dword ptr [EBP + -0x18],EBX",
            "SUB EBX,ESI",
            "ADD EAX,EBX",
            "CMP EAX,ESI",
            "JC 0x000052e7",
            "MOV ESI,dword ptr [EBP + -0x18]",
            "SUB ESI,EAX",
            "CMP dword ptr [EBP + 0x8],ESI",
            "JBE 0x00005316",
            "SUB dword ptr [EBP + 0x8],ESI",
            "MOV BL,byte ptr [EAX]",
            "MOV byte ptr [ECX],BL",
            "INC ECX",
            "INC EAX",
            "DEC ESI",
            "JNZ 0x000052fa",
            "MOV EAX,dword ptr [EBP + 0x18]",
            "MOV ESI,dword ptr [EAX + 0x28]",
            "MOV AL,byte ptr [ESI]",
            "MOV byte ptr [ECX],AL",
            "INC ECX",
            "INC ESI",
            "DEC dword ptr [EBP + 0x8]",
            "JNZ 0x00005309",
            "JMP 0x00005332",
            "MOV BL,byte ptr [EAX]",
            "MOV byte ptr [ECX],BL",
            "MOV BL,byte ptr [EAX + 0x1]",
            "INC ECX",
            "INC EAX",
            "MOV byte ptr [ECX],BL",
            "INC ECX",
            "INC EAX",
            "SUB dword ptr [EBP + 0x8],0x2",
            "MOV BL,byte ptr [EAX]",
            "MOV byte ptr [ECX],BL",
            "INC ECX",
            "INC EAX",
            "DEC dword ptr [EBP + 0x8]",
            "JNZ 0x00005327",
            "MOV ESI,dword ptr [EBP + 0x18]",
            "MOV dword ptr [EBP + -0xc],ECX",
            "JMP 0x0000536f",
            "MOV BL,byte ptr [EAX]",
            "MOV byte ptr [ECX],BL",
            "MOV BL,byte ptr [EAX + 0x1]",
            "INC ECX",
            "INC EAX",
            "MOV byte ptr [ECX],BL",
            "INC ECX",
            "INC EAX",
            "SUB dword ptr [EBP + 0x8],0x2",
            "MOV BL,byte ptr [EAX]",
            "MOV byte ptr [ECX],BL",
            "INC ECX",
            "INC EAX",
            "DEC dword ptr [EBP + 0x8]",
            "JNZ 0x0000534b",
            "JMP 0x00005332",
            "SHR dword ptr [EBP + 0x1c],CL",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "MOV AL,byte ptr [EAX + 0x4]",
            "SUB EDX,ECX",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "INC dword ptr [EBP + -0xc]",
            "DEC dword ptr [EBP + -0x10]",
            "MOV byte ptr [ECX],AL",
            "CMP dword ptr [EBP + -0x10],0x102",
            "JC 0x000053a3",
            "CMP dword ptr [EBP + -0x4],0xa",
            "JC 0x000053a3",
            "JMP 0x000051a4",
            "MOV ECX,dword ptr [EDI + 0x4]",
            "MOV EAX,EDX",
            "SUB ECX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x18],0x40f618",
            "SHR EAX,0x3",
            "CMP EAX,ECX",
            "JNC 0x0000539b",
            "MOV ECX,EAX",
            "MOV ESI,dword ptr [EBP + 0x18]",
            "PUSH -0x3",
            "POP EAX",
            "JMP 0x000053ed",
            "MOV ECX,dword ptr [EDI + 0x4]",
            "MOV EAX,EDX",
            "SUB ECX,dword ptr [EBP + -0x4]",
            "SHR EAX,0x3",
            "CMP EAX,ECX",
            "JNC 0x000053b4",
            "MOV ECX,EAX",
            "XOR EAX,EAX",
            "JMP 0x000053ed",
            "TEST CL,0x20",
            "JZ 0x000053d2",
            "MOV ECX,dword ptr [EDI + 0x4]",
            "MOV EAX,EDX",
            "SUB ECX,dword ptr [EBP + -0x4]",
            "SHR EAX,0x3",
            "CMP EAX,ECX",
            "JNC 0x000053ce",
            "MOV ECX,EAX",
            "PUSH 0x1",
            "JMP 0x000053ec",
            "MOV ECX,dword ptr [EDI + 0x4]",
            "MOV EAX,EDX",
            "SUB ECX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x18],0x40f630",
            "SHR EAX,0x3",
            "CMP EAX,ECX",
            "JNC 0x000053ea",
            "MOV ECX,EAX",
            "PUSH -0x3",
            "POP EAX",
            "MOV EBX,dword ptr [EBP + 0x1c]",
            "SUB dword ptr [EBP + -0x8],ECX",
            "MOV dword ptr [ESI + 0x20],EBX",
            "MOV EBX,ECX",
            "SHL EBX,0x3",
            "SUB EDX,EBX",
            "MOV dword ptr [ESI + 0x1c],EDX",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "ADD ECX,EDX",
            "MOV dword ptr [EDI + 0x4],ECX",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "MOV EDX,ECX",
            "SUB EDX,dword ptr [EDI]",
            "MOV dword ptr [EDI],ECX",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "ADD dword ptr [EDI + 0x8],EDX",
            "MOV dword ptr [ESI + 0x34],ECX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "0000514d",
            "end": "0000541e"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005167",
                    "000051a9",
                    "000051b9",
                    "00005230",
                    "00005240",
                    "0000529c",
                    "000052ac",
                    "000053f0",
                    "00005408"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000528e",
                    "000052e2",
                    "000052ed"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000516d",
                    "000051ac",
                    "00005233",
                    "0000529f",
                    "00005378",
                    "00005388",
                    "000053a8",
                    "000053c2",
                    "000053d7",
                    "00005400"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005194",
                    "000051c1"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005164",
                    "000052cb",
                    "00005335",
                    "00005364",
                    "00005367",
                    "00005411"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005187",
                    "000052ce",
                    "0000536a",
                    "0000536f"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000514d",
        "original_name": "FUN_0000514d",
        "predicted_name": "The function you provided is not a complete function, it is missing the function name and the closing curly bracket. Also, it is not properly indented, which makes it hard to read.",
        "prediction_full_response": "The function you provided is not a complete function, it is missing the function name and the closing curly bracket. Also, it is not properly indented, which makes it hard to read.\n\nHowever, from the code you provided, it seems that the function is intended to be a part of a larger program that implements a compression algorithm. The function takes in a number of parameters, including a pointer to a buffer, and it appears to be decompressing data from the buffer. The function returns a value that indicates the result of the decompression operation.\n\nWithout more context, it is not possible to provide a more specific answer to your question. If you provide more information about the program and the function, I may be able to provide a more detailed answer.</s>"
    },
    "0000267b": {
        "decomp_code": "\nbool FUN_0000267b(int *param_1,int *param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar1 = param_2[2];\n  if (uVar1 == 0) {\n    bVar5 = true;\n  }\n  else {\n    uVar2 = param_2[3];\n    if ((uVar2 & 0x2000000) == 0) {\n      uVar4 = *(uint *)((((uVar2 >> 0x1e & 1) + (uVar2 >> 0x1d & 1) * 2) * 2 - ((int)uVar2 >> 0x1f))\n                        * 4 + 0x40f53c);\n      if ((uVar2 & 0x4000000) != 0) {\n        uVar4 = uVar4 | 0x200;\n      }\n      iVar3 = (*pcRam004080ac)(*param_2,uVar1,uVar4,&param_2);\n      bVar5 = iVar3 != 0;\n    }\n    else {\n      if ((*param_2 == param_2[1]) &&\n         (((param_2[4] != 0 || (*(uint *)(*param_1 + 0x38) == param_1[0xe])) ||\n          (uVar1 % (uint)param_1[0xe] == 0)))) {\n        (*(code *)param_1[8])(*param_2,uVar1,0x4000,param_1[0xc]);\n      }\n      bVar5 = true;\n    }\n  }\n  return bVar5;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH EBX",
            "PUSH ESI",
            "MOV EBX,dword ptr [EAX + 0x8]",
            "TEST EBX,EBX",
            "JNZ 0x00002692",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x00002719",
            "MOV ECX,dword ptr [EAX + 0xc]",
            "TEST ECX,0x2000000",
            "JZ 0x000026d8",
            "PUSH EDI",
            "MOV EDI,dword ptr [EAX]",
            "CMP EDI,dword ptr [EAX + 0x4]",
            "JNZ 0x000026d2",
            "CMP dword ptr [EAX + 0x10],0x0",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "JNZ 0x000026c2",
            "MOV EAX,dword ptr [ECX]",
            "MOV ESI,dword ptr [ECX + 0x38]",
            "CMP dword ptr [EAX + 0x38],ESI",
            "JZ 0x000026c2",
            "MOV EAX,EBX",
            "XOR EDX,EDX",
            "DIV ESI",
            "TEST EDX,EDX",
            "JNZ 0x000026d2",
            "PUSH dword ptr [ECX + 0x30]",
            "PUSH 0x4000",
            "PUSH EBX",
            "PUSH EDI",
            "CALL dword ptr [ECX + 0x20]",
            "ADD ESP,0x10",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "JMP 0x00002719",
            "MOV EDX,ECX",
            "MOV ESI,ECX",
            "SHR EDX,0x1d",
            "SHR ESI,0x1e",
            "AND EDX,0x1",
            "AND ESI,0x1",
            "LEA EDX,[ESI + EDX*0x2]",
            "MOV ESI,ECX",
            "SHR ESI,0x1f",
            "TEST ECX,0x4000000",
            "LEA EDX,[ESI + EDX*0x2]",
            "MOV EDX,dword ptr [EDX*0x4 + 0x40f53c]",
            "JZ 0x00002705",
            "OR DH,0x2",
            "LEA ECX,[EBP + 0xc]",
            "PUSH ECX",
            "PUSH EDX",
            "PUSH EBX",
            "PUSH dword ptr [EAX]",
            "CALL dword ptr [0x004080ac]",
            "NEG EAX",
            "SBB EAX,EAX",
            "NEG EAX",
            "POP ESI",
            "POP EBX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "0000267b",
            "end": "0000271c"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000267b",
        "original_name": "FUN_0000267b",
        "predicted_name": "pico_set_read_timeout",
        "prediction_full_response": "The predicted function name is pico_set_read_timeout</s>"
    },
    "000076ae": {
        "decomp_code": "\nvoid * __cdecl memset(void *_Dst,int _Val,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076ae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam0040812c)();\n  return pvVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x0040812c]"
        ],
        "function_address": {
            "start": "000076ae",
            "end": "000076b3"
        },
        "variable_metadata": {
            "_Size": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            },
            "_Dst": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            },
            "_Val": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "int"
            }
        },
        "func_name": "memset",
        "original_name": "memset",
        "predicted_name": "_malloc_r",
        "prediction_full_response": "The predicted function name is _malloc_r</s>"
    },
    "00001ce8": {
        "decomp_code": "\nundefined4 FUN_00001ce8(undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined1 local_410 [1024];\n  int local_10;\n  undefined4 local_c;\n  int local_8;\n  \n  local_c = 0;\n  local_8 = (*pcRam00408024)(0,0,0xf003f);\n  if (local_8 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    local_10 = (*pcRam00408004)(local_8,0x40f8ac,0xf01ff);\n    if (local_10 == 0) {\n      (*pcRam0040811c)(local_410,0x40f42c,param_1);\n      iVar2 = (*pcRam00408000)(local_8,0x40f8ac,0x40f8ac,0xf01ff,0x10,2,1,local_410,0,0,0,0,0);\n      uVar1 = local_c;\n      if (iVar2 != 0) {\n        (*pcRam00408008)(iVar2,0,0);\n        (*pcRam0040800c)(iVar2);\n        local_c = 1;\n        uVar1 = local_c;\n      }\n    }\n    else {\n      (*pcRam00408008)(local_10,0,0);\n      (*pcRam0040800c)(local_10);\n      uVar1 = 1;\n    }\n    (*pcRam0040800c)(local_8);\n  }\n  return uVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x40c",
            "PUSH EDI",
            "XOR EDI,EDI",
            "PUSH 0xf003f",
            "PUSH EDI",
            "PUSH EDI",
            "MOV dword ptr [EBP + -0x8],EDI",
            "CALL dword ptr [0x00408024]",
            "CMP EAX,EDI",
            "MOV dword ptr [EBP + -0x4],EAX",
            "JNZ 0x00001d12",
            "XOR EAX,EAX",
            "JMP 0x00001da8",
            "PUSH EBX",
            "PUSH ESI",
            "MOV EBX,0xf01ff",
            "MOV ESI,0x40f8ac",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EAX",
            "CALL dword ptr [0x00408004]",
            "CMP EAX,EDI",
            "MOV dword ptr [EBP + -0xc],EAX",
            "JZ 0x00001d45",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EAX",
            "CALL dword ptr [0x00408008]",
            "PUSH dword ptr [EBP + -0xc]",
            "CALL dword ptr [0x0040800c]",
            "PUSH 0x1",
            "POP ESI",
            "JMP 0x00001d9b",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0xfffffbf4]",
            "PUSH 0x40f42c",
            "PUSH EAX",
            "CALL dword ptr [0x0040811c]",
            "ADD ESP,0xc",
            "LEA EAX,[EBP + 0xfffffbf4]",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EAX",
            "PUSH 0x1",
            "PUSH 0x2",
            "PUSH 0x10",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [0x00408000]",
            "MOV ESI,EAX",
            "CMP ESI,EDI",
            "JZ 0x00001d98",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH ESI",
            "CALL dword ptr [0x00408008]",
            "PUSH ESI",
            "CALL dword ptr [0x0040800c]",
            "MOV dword ptr [EBP + -0x8],0x1",
            "MOV ESI,dword ptr [EBP + -0x8]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [0x0040800c]",
            "MOV EAX,ESI",
            "POP ESI",
            "POP EBX",
            "POP EDI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001ce8",
            "end": "00001daa"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001cfb",
                    "00001d91",
                    "00001d98"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001d06",
                    "00001d72",
                    "00001d9b"
                ],
                "type": "undefined4"
            },
            "local_410": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001d48",
                    "00001d5d"
                ],
                "type": "undefined"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001d29",
                    "00001d37"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00001ce8",
        "original_name": "FUN_00001ce8",
        "predicted_name": "\"send_command\".",
        "prediction_full_response": "The predicted function name is \"send_command\".</s>"
    },
    "00005d0e": {
        "decomp_code": "\nundefined4 FUN_00005d0e(char *param_1,int param_2,int param_3)\n\n{\n  undefined4 uVar1;\n  \n  if (*param_1 != '\\0') {\n    if (param_1[1] != '\\0') {\n      if (param_3 == 0) {\n        uVar1 = 0;\n        param_2 = *(int *)(param_1 + 0xc) + param_2;\n      }\n      else if (param_3 == 1) {\n        uVar1 = 1;\n      }\n      else {\n        if (param_3 != 2) {\n          return 0x13;\n        }\n        uVar1 = 2;\n      }\n      (*pcRam004080c8)(*(undefined4 *)(param_1 + 4),param_2,0,uVar1);\n      return 0;\n    }\n    if (*param_1 != '\\0') {\n      return 0x1d;\n    }\n  }\n  if (param_3 != 0) {\n    if (param_3 == 1) {\n      *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + param_2;\n      return 0;\n    }\n    if (param_3 != 2) {\n      return 0;\n    }\n    param_2 = *(int *)(param_1 + 0x18) + param_2;\n  }\n  *(int *)(param_1 + 0x1c) = param_2;\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "XOR EDX,EDX",
            "MOV CL,byte ptr [EAX]",
            "CMP CL,DL",
            "JZ 0x00005d5f",
            "CMP byte ptr [EAX + 0x1],DL",
            "JZ 0x00005d57",
            "CMP dword ptr [EBP + 0x10],EDX",
            "JNZ 0x00005d31",
            "MOV ECX,dword ptr [EAX + 0xc]",
            "PUSH EDX",
            "ADD ECX,dword ptr [EBP + 0xc]",
            "PUSH EDX",
            "PUSH ECX",
            "JMP 0x00005d47",
            "CMP dword ptr [EBP + 0x10],0x1",
            "JNZ 0x00005d3b",
            "PUSH 0x1",
            "JMP 0x00005d43",
            "CMP dword ptr [EBP + 0x10],0x2",
            "JNZ 0x00005d52",
            "PUSH 0x2",
            "PUSH EDX",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EAX + 0x4]",
            "CALL dword ptr [0x004080c8]",
            "JMP 0x00005d86",
            "PUSH 0x13",
            "POP EAX",
            "POP EBP",
            "RET",
            "CMP CL,DL",
            "JZ 0x00005d5f",
            "PUSH 0x1d",
            "JMP 0x00005d54",
            "CMP dword ptr [EBP + 0x10],EDX",
            "JNZ 0x00005d69",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "JMP 0x00005d83",
            "CMP dword ptr [EBP + 0x10],0x1",
            "JNZ 0x00005d77",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "ADD dword ptr [EAX + 0x1c],ECX",
            "JMP 0x00005d86",
            "CMP dword ptr [EBP + 0x10],0x2",
            "JNZ 0x00005d86",
            "MOV ECX,dword ptr [EAX + 0x18]",
            "ADD ECX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [EAX + 0x1c],ECX",
            "XOR EAX,EAX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00005d0e",
            "end": "00005d89"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005d0e",
        "original_name": "FUN_00005d0e",
        "predicted_name": "\"set_file_size\".",
        "prediction_full_response": "The predicted function name is \"set_file_size\".</s>"
    },
    "0000271d": {
        "decomp_code": "\nundefined4 FUN_0000271d(int *param_1)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0xc0) == 0) {\n    return 1;\n  }\n  puVar2 = *(undefined4 **)(*(int *)(*param_1 + 0xc0) + 0xc + iVar1);\n  if (puVar2 != (undefined4 *)0x0) {\n    for (; (code *)*puVar2 != (code *)0x0; puVar2 = puVar2 + 1) {\n      (*(code *)*puVar2)(iVar1,1,0);\n    }\n  }\n  return 1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EAX + 0x4]",
            "MOV EAX,dword ptr [EAX]",
            "ADD EAX,0xc0",
            "MOV EAX,dword ptr [EAX]",
            "TEST EAX,EAX",
            "JNZ 0x00002737",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "RET",
            "PUSH ESI",
            "MOV ESI,dword ptr [EAX + EDI*0x1 + 0xc]",
            "TEST ESI,ESI",
            "JZ 0x00002752",
            "MOV EAX,dword ptr [ESI]",
            "TEST EAX,EAX",
            "JZ 0x00002752",
            "PUSH 0x0",
            "PUSH 0x1",
            "PUSH EDI",
            "CALL EAX",
            "ADD ESI,0x4",
            "JMP 0x00002740",
            "PUSH 0x1",
            "POP EAX",
            "POP ESI",
            "POP EDI",
            "RET"
        ],
        "function_address": {
            "start": "0000271d",
            "end": "00002757"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000271d",
        "original_name": "FUN_0000271d",
        "predicted_name": "_rl_dispatching_keymap",
        "prediction_full_response": "The predicted function name is _rl_dispatching_keymap</s>"
    },
    "00007740": {
        "decomp_code": "\nint __cdecl strcmp(char *_Str1,char *_Str2)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007740. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = (*pcRam00408160)();\n  return iVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408160]"
        ],
        "function_address": {
            "start": "00007740",
            "end": "00007745"
        },
        "variable_metadata": {
            "_Str2": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            },
            "_Str1": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            }
        },
        "func_name": "strcmp",
        "original_name": "strcmp",
        "predicted_name": "strcmp",
        "prediction_full_response": "The predicted function name is strcmp</s>"
    },
    "00001000": {
        "decomp_code": "\nbool FUN_00001000(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  bool bVar3;\n  undefined4 uVar4;\n  \n  if (param_2 == 0) {\n    uVar4 = 0x40e018;\n  }\n  else {\n    uVar4 = 0x40e01c;\n  }\n  iVar1 = (*pcRam00408118)(0x40e010,uVar4);\n  if (iVar1 == 0) {\n    bVar3 = false;\n  }\n  else {\n    if (param_2 == 0) {\n      iVar2 = (*pcRam00408110)(param_1,0x30c,1,iVar1);\n    }\n    else {\n      iVar2 = (*pcRam00408114)();\n    }\n    bVar3 = iVar2 != 0;\n    (*pcRam0040810c)(iVar1);\n  }\n  return bVar3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "XOR ESI,ESI",
            "CMP dword ptr [ESP + 0xc],ESI",
            "PUSH EDI",
            "JZ 0x00001011",
            "PUSH 0x40e01c",
            "JMP 0x00001016",
            "PUSH 0x40e018",
            "PUSH 0x40e010",
            "CALL dword ptr [0x00408118]",
            "MOV EDI,EAX",
            "POP ECX",
            "CMP EDI,ESI",
            "POP ECX",
            "JNZ 0x0000102d",
            "XOR EAX,EAX",
            "JMP 0x00001061",
            "CMP dword ptr [ESP + 0x10],ESI",
            "PUSH EDI",
            "PUSH 0x1",
            "PUSH 0x30c",
            "PUSH dword ptr [ESP + 0x18]",
            "JZ 0x00001047",
            "CALL dword ptr [0x00408114]",
            "JMP 0x0000104d",
            "CALL dword ptr [0x00408110]",
            "ADD ESP,0x10",
            "TEST EAX,EAX",
            "JZ 0x00001057",
            "PUSH 0x1",
            "POP ESI",
            "PUSH EDI",
            "CALL dword ptr [0x0040810c]",
            "POP ECX",
            "MOV EAX,ESI",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00001000",
            "end": "00001063"
        },
        "variable_metadata": {},
        "func_name": "FUN_00001000",
        "original_name": "FUN_00001000",
        "predicted_name": "write_ram_data.",
        "prediction_full_response": "The predicted function name is write_ram_data.</s>"
    },
    "00005edf": {
        "decomp_code": "\nint FUN_00005edf(undefined4 param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int local_10;\n  uint local_c;\n  uint local_8;\n  \n  iVar1 = FUN_00005d0e(param_1,0,2);\n  if (iVar1 == 0) {\n    uVar2 = FUN_00005cdd(param_1);\n    local_8 = 0xffff;\n    if (uVar2 < 0xffff) {\n      local_8 = uVar2;\n    }\n    iVar1 = (*pcRam00408178)(0x404);\n    if (iVar1 != 0) {\n      local_10 = -1;\n      local_c = 4;\n      if (4 < local_8) {\n        while( true ) {\n          uVar3 = local_c + 0x400;\n          local_c = local_8;\n          if (uVar3 <= local_8) {\n            local_c = uVar3;\n          }\n          iVar6 = uVar2 - local_c;\n          uVar3 = 0x404;\n          if (uVar2 - iVar6 < 0x405) {\n            uVar3 = uVar2 - iVar6;\n          }\n          iVar4 = FUN_00005d0e(param_1,iVar6,0);\n          if ((iVar4 != 0) || (iVar4 = FUN_00005d8a(iVar1,uVar3,1,param_1), iVar4 != 1)) break;\n          iVar4 = uVar3 - 3;\n          do {\n            iVar5 = iVar4;\n            iVar4 = iVar5 + -1;\n            if (iVar5 < 0) goto LAB_00005fc0;\n          } while ((((*(char *)(iVar4 + iVar1) != 'P') || (*(char *)(iVar5 + iVar1) != 'K')) ||\n                   (*(char *)(iVar5 + 1 + iVar1) != '\\x05')) ||\n                  (*(char *)(iVar5 + 2 + iVar1) != '\\x06'));\n          local_10 = iVar4 + iVar6;\nLAB_00005fc0:\n          if ((local_10 != 0) || (local_8 <= local_c)) break;\n        }\n      }\n      (*pcRam00408174)(iVar1);\n      return local_10;\n    }\n  }\n  return -1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x10",
            "PUSH EBX",
            "PUSH EDI",
            "PUSH 0x2",
            "PUSH 0x0",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00005f2a",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005cdd",
            "POP ECX",
            "MOV ECX,EAX",
            "MOV EAX,0xffff",
            "CMP ECX,EAX",
            "MOV dword ptr [EBP + -0x10],ECX",
            "MOV dword ptr [EBP + -0x4],EAX",
            "JNC 0x00005f17",
            "MOV dword ptr [EBP + -0x4],ECX",
            "MOV EDI,0x404",
            "PUSH EDI",
            "CALL dword ptr [0x00408178]",
            "MOV EBX,EAX",
            "POP ECX",
            "TEST EBX,EBX",
            "JNZ 0x00005f32",
            "OR EAX,0xffffffff",
            "JMP 0x00005fde",
            "OR dword ptr [EBP + -0xc],0xffffffff",
            "PUSH 0x4",
            "POP EAX",
            "CMP dword ptr [EBP + -0x4],EAX",
            "JBE 0x00005fd3",
            "PUSH ESI",
            "JMP 0x00005f4d",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV EDI,0x404",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "ADD EAX,0x400",
            "CMP EAX,ECX",
            "MOV dword ptr [EBP + -0x8],ECX",
            "JA 0x00005f5f",
            "MOV dword ptr [EBP + -0x8],EAX",
            "MOV ESI,dword ptr [EBP + -0x10]",
            "MOV EAX,dword ptr [EBP + -0x10]",
            "SUB ESI,dword ptr [EBP + -0x8]",
            "SUB EAX,ESI",
            "CMP EAX,EDI",
            "JA 0x00005f70",
            "MOV EDI,EAX",
            "PUSH 0x0",
            "PUSH ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00005fd2",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH 0x1",
            "PUSH EDI",
            "PUSH EBX",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JNZ 0x00005fd2",
            "LEA EAX,[EDI + -0x3]",
            "MOV ECX,EAX",
            "DEC EAX",
            "TEST ECX,ECX",
            "JL 0x00005fc0",
            "CMP byte ptr [EAX + EBX*0x1],0x50",
            "JNZ 0x00005f99",
            "CMP byte ptr [EAX + EBX*0x1 + 0x1],0x4b",
            "JNZ 0x00005f99",
            "CMP byte ptr [EAX + EBX*0x1 + 0x2],0x5",
            "JNZ 0x00005f99",
            "CMP byte ptr [EAX + EBX*0x1 + 0x3],0x6",
            "JNZ 0x00005f99",
            "ADD EAX,ESI",
            "MOV dword ptr [EBP + -0xc],EAX",
            "CMP dword ptr [EBP + -0xc],0x0",
            "JNZ 0x00005fd2",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "CMP dword ptr [EBP + -0x8],EAX",
            "JC 0x00005f45",
            "POP ESI",
            "PUSH EBX",
            "CALL dword ptr [0x00408174]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "POP ECX",
            "POP EDI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00005edf",
            "end": "00005fe1"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005f45",
                    "00005f57",
                    "00005f5c",
                    "00005f65",
                    "00005fc9"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005f0f",
                    "00005f14",
                    "00005f39",
                    "00005f4d",
                    "00005fc6"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005f32",
                    "00005fbd",
                    "00005fc0",
                    "00005fda"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005f0c",
                    "00005f5f",
                    "00005f62"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00005edf",
        "original_name": "FUN_00005edf",
        "predicted_name": "[INST: Here is the predicted function name based on the decompiled codes: find_pk_sig]",
        "prediction_full_response": "[INST: Here is the predicted function name based on the decompiled codes: find_pk_sig]</s>"
    },
    "00003a28": {
        "decomp_code": "\nvoid __thiscall FUN_00003a28(int param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined1 local_10 [12];\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    iVar1 = 0;\n    if (0 < *(int *)(param_1 + 0x3cc)) {\n      do {\n        *param_2 = *param_2 ^ *param_3;\n        param_3 = param_3 + 1;\n        param_2 = param_2 + 1;\n        iVar1 = iVar1 + 1;\n      } while (iVar1 < *(int *)(param_1 + 0x3cc));\n    }\n    return;\n  }\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xc",
            "CMP byte ptr [ECX + 0x4],0x0",
            "PUSH ESI",
            "JNZ 0x00003a51",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0xc]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0xc]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "XOR ESI,ESI",
            "CMP dword ptr [ECX + 0x3cc],ESI",
            "JLE 0x00003a72",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV DL,byte ptr [EDI]",
            "XOR byte ptr [EAX],DL",
            "INC EDI",
            "INC EAX",
            "INC ESI",
            "CMP ESI,dword ptr [ECX + 0x3cc]",
            "JL 0x00003a62",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "00003a28",
            "end": "00003a76"
        },
        "variable_metadata": {
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003a3a",
                    "00003a43"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00003a28",
        "original_name": "FUN_00003a28",
        "predicted_name": "_ZN10CryptoBase10CryptoBase10CryptoBase",
        "prediction_full_response": "The predicted function name is _ZN10CryptoBase10CryptoBase10CryptoBase</s>"
    },
    "000076c8": {
        "decomp_code": "\nvoid FUN_000076c8(void)\n\n{\n  undefined1 auStack_c [12];\n  \n  puRamffdff000 = auStack_c;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH -0x1",
            "PUSH EAX",
            "MOV EAX,FS:[0x0]",
            "PUSH EAX",
            "MOV EAX,dword ptr [ESP + 0xc]",
            "MOV dword ptr FS:[0x0],ESP",
            "MOV dword ptr [ESP + 0xc],EBP",
            "LEA EBP,[ESP + 0xc]",
            "PUSH EAX",
            "RET"
        ],
        "function_address": {
            "start": "000076c8",
            "end": "000076e6"
        },
        "variable_metadata": {
            "local_res0": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000076d2",
                    "000076dd",
                    "000076e1"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000076c8",
        "original_name": "FUN_000076c8",
        "predicted_name": "init_stack_protector.",
        "prediction_full_response": "The predicted function name is init_stack_protector.</s>"
    },
    "000014a6": {
        "decomp_code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint __thiscall FUN_000014a6(int param_1,undefined4 param_2,uint *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int local_248 [2];\n  undefined1 local_240;\n  undefined4 local_23f;\n  undefined2 uStack_23b;\n  undefined1 uStack_239;\n  uint local_238;\n  uint local_234;\n  undefined1 local_230 [512];\n  undefined4 local_30;\n  int local_2c;\n  uint local_28;\n  int local_24;\n  uint local_20 [3];\n  undefined4 local_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x4081e0;\n  uStack_10 = 0x4076f4;\n  local_14 = puRamffdff000;\n  iVar3 = 0;\n  local_30 = 0;\n  local_248[0] = 0;\n  local_240 = 0;\n  local_23f = 0;\n  uStack_23b = 0;\n  uStack_239 = 0;\n  local_248[1] = 0;\n  local_20[0] = 0;\n  local_8 = 0;\n  puRamffdff000 = &local_14;\n  iVar1 = (*pcRam00408034)(param_2,0x80000000,1,0,3,0,0);\n  if (iVar1 != -1) {\n    (*pcRam00408030)(iVar1,&local_28);\n    if ((local_24 < 1) && ((local_24 < 0 || (local_28 < 0x6400001)))) {\n      iVar2 = (*pcRam0040f880)(iVar1,&local_240,8,local_20,0);\n      if (iVar2 != 0) {\n        iVar2 = memcmp(&local_240,(void *)0x40eb7c,8);\n        if (iVar2 == 0) {\n          iVar2 = (*pcRam0040f880)(iVar1,local_248,4,local_20,0);\n          if ((iVar2 != 0) && (local_248[0] == 0x100)) {\n            iVar2 = (*pcRam0040f880)(iVar1,*(undefined4 *)(param_1 + 0x4c8),0x100,local_20,0);\n            if (iVar2 != 0) {\n              iVar2 = (*pcRam0040f880)(iVar1,local_248 + 1,4,local_20,0);\n              if (iVar2 != 0) {\n                iVar2 = (*pcRam0040f880)(iVar1,&local_238,8,local_20,0);\n                if (((iVar2 != 0) && ((int)local_234 < 1)) &&\n                   (((int)local_234 < 0 || (local_238 < 0x6400001)))) {\n                  iVar2 = FUN_000019e1(*(undefined4 *)(param_1 + 0x4c8),local_248[0],local_230,\n                                       &local_30);\n                  if (iVar2 != 0) {\n                    FUN_00002a76(local_230,uRam0040f578,local_30,0x10);\n                    local_2c = (*pcRam004080dc)(0,local_238);\n                    if (local_2c != 0) {\n                      iVar2 = (*pcRam0040f880)(iVar1,*(undefined4 *)(param_1 + 0x4c8),local_28,\n                                               local_20,0);\n                      iVar1 = local_2c;\n                      if (((iVar2 != 0) && (local_20[0] != 0)) &&\n                         ((0x7fffffff < local_234 ||\n                          (((int)local_234 < 1 && (local_238 <= local_20[0])))))) {\n                        FUN_00003a77(*(undefined4 *)(param_1 + 0x4c8),local_2c,local_20[0],1);\n                        *param_3 = local_238;\n                        iVar3 = iVar1;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  local_unwind2(&local_14,0xffffffff);\n  puRamffdff000 = (undefined4 *)local_14;\n  return iVar3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH -0x1",
            "PUSH 0x4081e0",
            "PUSH 0x4076f4",
            "MOV EAX,FS:[0x0]",
            "PUSH EAX",
            "MOV dword ptr FS:[0x0],ESP",
            "SUB ESP,0x23c",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV ESI,ECX",
            "OR dword ptr [EBP + 0xfffffdb8],0xffffffff",
            "XOR EBX,EBX",
            "MOV dword ptr [EBP + -0x2c],EBX",
            "MOV dword ptr [EBP + 0xfffffdbc],EBX",
            "MOV byte ptr [EBP + 0xfffffdc4],BL",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffdc5]",
            "STOSD ES:EDI",
            "STOSW ES:EDI",
            "STOSB ES:EDI",
            "MOV dword ptr [EBP + 0xfffffdc0],EBX",
            "MOV dword ptr [EBP + -0x1c],EBX",
            "MOV dword ptr [EBP + -0x4],EBX",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH 0x3",
            "PUSH EBX",
            "PUSH 0x1",
            "PUSH 0x80000000",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x00408034]",
            "MOV EDI,EAX",
            "MOV dword ptr [EBP + 0xfffffdb8],EDI",
            "CMP EDI,-0x1",
            "JZ 0x000016d0",
            "LEA EAX,[EBP + -0x24]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL dword ptr [0x00408030]",
            "CMP dword ptr [EBP + -0x20],EBX",
            "JG 0x000016d0",
            "JL 0x00001547",
            "CMP dword ptr [EBP + -0x24],0x6400000",
            "JA 0x000016d0",
            "PUSH EBX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH 0x8",
            "LEA EAX,[EBP + 0xfffffdc4]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "PUSH 0x8",
            "PUSH 0x40eb7c",
            "LEA EAX,[EBP + 0xfffffdc4]",
            "PUSH EAX",
            "CALL 0x000076ee",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x000016d0",
            "PUSH EBX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH 0x4",
            "LEA EAX,[EBP + 0xfffffdbc]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "MOV EAX,0x100",
            "CMP dword ptr [EBP + 0xfffffdbc],EAX",
            "JNZ 0x000016d0",
            "PUSH EBX",
            "LEA ECX,[EBP + -0x1c]",
            "PUSH ECX",
            "PUSH EAX",
            "PUSH dword ptr [ESI + 0x4c8]",
            "PUSH EDI",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "PUSH EBX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH 0x4",
            "LEA EAX,[EBP + 0xfffffdc0]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "PUSH EBX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH 0x8",
            "LEA EAX,[EBP + 0xfffffdcc]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "CMP dword ptr [EBP + 0xfffffdd0],EBX",
            "JG 0x000016d0",
            "JL 0x00001623",
            "CMP dword ptr [EBP + 0xfffffdcc],0x6400000",
            "JA 0x000016d0",
            "LEA EAX,[EBP + -0x2c]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffdd4]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0xfffffdbc]",
            "PUSH dword ptr [ESI + 0x4c8]",
            "LEA ECX,[ESI + 0x4]",
            "CALL 0x000019e1",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "LEA EDI,[ESI + 0x54]",
            "PUSH 0x10",
            "PUSH dword ptr [EBP + -0x2c]",
            "PUSH dword ptr [0x0040f578]",
            "LEA EAX,[EBP + 0xfffffdd4]",
            "PUSH EAX",
            "MOV ECX,EDI",
            "CALL 0x00002a76",
            "PUSH dword ptr [EBP + 0xfffffdcc]",
            "PUSH EBX",
            "CALL dword ptr [0x004080dc]",
            "MOV dword ptr [EBP + -0x28],EAX",
            "CMP EAX,EBX",
            "JZ 0x000016d0",
            "PUSH EBX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + -0x24]",
            "PUSH dword ptr [ESI + 0x4c8]",
            "PUSH dword ptr [EBP + 0xfffffdb8]",
            "CALL dword ptr [0x0040f880]",
            "TEST EAX,EAX",
            "JZ 0x000016d0",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "CMP EAX,EBX",
            "JZ 0x000016d0",
            "CMP EBX,dword ptr [EBP + 0xfffffdd0]",
            "JG 0x000016b1",
            "JL 0x000016d0",
            "CMP EAX,dword ptr [EBP + 0xfffffdcc]",
            "JC 0x000016d0",
            "PUSH 0x1",
            "PUSH EAX",
            "MOV EBX,dword ptr [EBP + -0x28]",
            "PUSH EBX",
            "PUSH dword ptr [ESI + 0x4c8]",
            "MOV ECX,EDI",
            "CALL 0x00003a77",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV ECX,dword ptr [EBP + 0xfffffdcc]",
            "MOV dword ptr [EAX],ECX",
            "PUSH -0x1",
            "LEA EAX,[EBP + -0x10]",
            "PUSH EAX",
            "CALL 0x000076fa",
            "POP ECX",
            "POP ECX",
            "MOV EAX,EBX",
            "JMP 0x000016f9",
            "MOV ECX,dword ptr [EBP + -0x10]",
            "MOV dword ptr FS:[0x0],ECX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "000014a6",
            "end": "00001709"
        },
        "variable_metadata": {
            "local_24c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014ce",
                    "00001515",
                    "00001688"
                ],
                "type": "undefined4"
            },
            "local_248": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014da",
                    "00001589",
                    "000015a4",
                    "0000162e"
                ],
                "type": "undefined4"
            },
            "local_238": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000015ef",
                    "00001613",
                    "00001666",
                    "000016a9",
                    "000016c8"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001673",
                    "000016b4"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014fb"
                ],
                "type": "undefined4"
            },
            "local_244": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014f2",
                    "000015d2"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001524",
                    "0000153a",
                    "0000167f"
                ],
                "type": "undefined4"
            },
            "local_234": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001605",
                    "0000169f"
                ],
                "type": "undefined4"
            },
            "local_240": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014e0",
                    "0000154e",
                    "0000156b"
                ],
                "type": "undefined1"
            },
            "local_230": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001627",
                    "00001658"
                ],
                "type": "undefined"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014f8",
                    "00001548",
                    "00001583",
                    "000015b1",
                    "000015cc",
                    "000015e9",
                    "0000167b",
                    "00001698"
                ],
                "type": "undefined4"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014d7",
                    "00001623",
                    "0000164f"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000016d2",
                    "000016f9"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000152f"
                ],
                "type": "undefined4"
            },
            "local_23f": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000014e8"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_000014a6",
        "original_name": "FUN_000014a6",
        "predicted_name": "",
        "prediction_full_response": ""
    },
    "000017ff": {
        "decomp_code": "\nvoid * __thiscall FUN_000017ff(void *param_1,byte param_2)\n\n{\n  FUN_0000181b();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "CALL 0x0000181b",
            "TEST byte ptr [ESP + 0x8],0x1",
            "JZ 0x00001815",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "MOV EAX,ESI",
            "POP ESI",
            "RET 0x4"
        ],
        "function_address": {
            "start": "000017ff",
            "end": "0000181a"
        },
        "variable_metadata": {},
        "func_name": "FUN_000017ff",
        "original_name": "FUN_000017ff",
        "predicted_name": "operator_delete_or_not",
        "prediction_full_response": "The predicted function name is operator_delete_or_not</s>"
    },
    "0000797b": {
        "decomp_code": "\nvoid Unwind_0040797b(void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [EBP + -0x10]",
            "ADD ECX,0x2c",
            "JMP 0x0000181b"
        ],
        "function_address": {
            "start": "0000797b",
            "end": "00007985"
        },
        "variable_metadata": {},
        "func_name": "Unwind@0040797b",
        "original_name": "Unwind@0040797b",
        "predicted_name": "FUN_0000181b",
        "prediction_full_response": "The predicted function name is FUN_0000181b</s>"
    },
    "00007986": {
        "decomp_code": "\nvoid Unwind_00407986(void)\n\n{\n  FUN_00002a6f();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [EBP + -0x10]",
            "ADD ECX,0x54",
            "JMP 0x00002a6f"
        ],
        "function_address": {
            "start": "00007986",
            "end": "00007990"
        },
        "variable_metadata": {},
        "func_name": "Unwind@00407986",
        "original_name": "Unwind@00407986",
        "predicted_name": "FUN_00002a70",
        "prediction_full_response": "The predicted function name is FUN_00002a70</s>"
    },
    "00002457": {
        "decomp_code": "\nundefined4 FUN_00002457(uint param_1,uint param_2)\n\n{\n  if (param_1 < param_2) {\n    (*pcRam004080a8)(0xd);\n    return 0;\n  }\n  return 1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "CMP EAX,dword ptr [ESP + 0x8]",
            "JNC 0x0000246c",
            "PUSH 0xd",
            "CALL dword ptr [0x004080a8]",
            "XOR EAX,EAX",
            "RET",
            "PUSH 0x1",
            "POP EAX",
            "RET"
        ],
        "function_address": {
            "start": "00002457",
            "end": "0000246f"
        },
        "variable_metadata": {},
        "func_name": "FUN_00002457",
        "original_name": "FUN_00002457",
        "predicted_name": "check_range",
        "prediction_full_response": "The predicted function name is check_range</s>"
    },
    "000061e0": {
        "decomp_code": "\nint FUN_000061e0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,int param_4,\n                uint param_5,int param_6,uint param_7,int param_8,uint param_9)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 *puVar3;\n  uint uVar4;\n  undefined4 local_60;\n  undefined1 local_5c [4];\n  undefined1 local_58 [4];\n  undefined1 local_54 [4];\n  undefined4 local_50;\n  undefined1 local_4c [4];\n  undefined1 local_48 [4];\n  undefined1 local_44 [4];\n  uint local_40;\n  uint local_3c;\n  uint local_38;\n  undefined1 local_34 [4];\n  undefined1 local_30 [4];\n  undefined1 local_2c [4];\n  undefined1 local_28 [24];\n  undefined4 local_10;\n  int local_c;\n  int local_8;\n  \n  puVar3 = param_1;\n  local_8 = 0;\n  if (param_1 == (undefined4 *)0x0) {\n    return -0x66;\n  }\n  iVar1 = FUN_00005d0e(*param_1,param_1[5] + param_1[3],0);\n  if (iVar1 == 0) {\n    iVar1 = FUN_00005e6b(*param_1,&local_c);\n    if (iVar1 == 0) {\n      if (local_c != 0x2014b50) {\n        local_8 = -0x67;\n      }\n    }\n    else {\n      local_8 = -1;\n    }\n  }\n  else {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_60);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_5c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_58);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_54);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,&local_50);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  FUN_00006191(local_50,local_28);\n  iVar1 = FUN_00005e6b(*param_1,local_4c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_48);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_44);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_40);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_3c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,&local_38);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_34);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e27(*param_1,local_30);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,local_2c);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  iVar1 = FUN_00005e6b(*param_1,&local_10);\n  if (iVar1 != 0) {\n    local_8 = -1;\n  }\n  uVar2 = local_40;\n  if (local_8 == 0) {\n    if (param_4 != 0) {\n      uVar2 = param_5;\n      if (local_40 < param_5) {\n        *(undefined1 *)(local_40 + param_4) = 0;\n        uVar2 = local_40;\n      }\n      if (((local_40 != 0) && (param_5 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_4,uVar2,1,*param_1), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      uVar2 = local_40 - uVar2;\n      if (local_8 != 0) goto LAB_00006435;\n    }\n    if (param_6 != 0) {\n      uVar4 = local_3c;\n      if (param_7 <= local_3c) {\n        uVar4 = param_7;\n      }\n      if (uVar2 != 0) {\n        iVar1 = FUN_00005d0e(*param_1,uVar2,1);\n        if (iVar1 == 0) {\n          param_1 = (undefined4 *)0x0;\n          uVar2 = (uint)param_1;\n        }\n        else {\n          local_8 = -1;\n        }\n      }\n      param_1 = (undefined4 *)uVar2;\n      if (((local_3c != 0) && (param_7 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_6,uVar4,1,*puVar3), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      iVar1 = (int)param_1 + (local_3c - uVar4);\n      goto LAB_00006438;\n    }\n  }\nLAB_00006435:\n  iVar1 = uVar2 + local_3c;\nLAB_00006438:\n  if (local_8 == 0) {\n    if (param_8 != 0) {\n      uVar2 = param_9;\n      if (local_38 < param_9) {\n        *(undefined1 *)(local_38 + param_8) = 0;\n        uVar2 = local_38;\n      }\n      if ((iVar1 != 0) && (iVar1 = FUN_00005d0e(*puVar3,iVar1,1), iVar1 != 0)) {\n        local_8 = -1;\n      }\n      if (((local_38 != 0) && (param_9 != 0)) &&\n         (iVar1 = FUN_00005d8a(param_8,uVar2,1,*puVar3), iVar1 != 1)) {\n        local_8 = -1;\n      }\n      if (local_8 != 0) {\n        return local_8;\n      }\n    }\n    if (param_2 != (undefined4 *)0x0) {\n      puVar3 = &local_60;\n      for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *param_2 = *puVar3;\n        puVar3 = puVar3 + 1;\n        param_2 = param_2 + 1;\n      }\n    }\n    if (param_3 != (undefined4 *)0x0) {\n      *param_3 = local_10;\n    }\n  }\n  return local_8;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x5c",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "XOR EDI,EDI",
            "CMP ESI,EDI",
            "MOV dword ptr [EBP + -0x4],EDI",
            "JNZ 0x000061fc",
            "PUSH -0x66",
            "POP EAX",
            "JMP 0x000064b7",
            "MOV EAX,dword ptr [ESI + 0x14]",
            "PUSH EBX",
            "ADD EAX,dword ptr [ESI + 0xc]",
            "PUSH EDI",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x0000621b",
            "OR EBX,0xffffffff",
            "MOV dword ptr [EBP + -0x4],EBX",
            "JMP 0x00006245",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006232",
            "OR dword ptr [EBP + -0x4],0xffffffff",
            "JMP 0x00006242",
            "CMP dword ptr [EBP + -0x8],0x2014b50",
            "JZ 0x00006242",
            "MOV dword ptr [EBP + -0x4],0xffffff99",
            "OR EBX,0xffffffff",
            "LEA EAX,[EBP + -0x5c]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006259",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x58]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000626d",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x54]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006281",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x50]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006295",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x4c]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000062a9",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x24]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + -0x4c]",
            "CALL 0x00006191",
            "LEA EAX,[EBP + -0x48]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "ADD ESP,0x10",
            "TEST EAX,EAX",
            "JZ 0x000062ca",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x44]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000062de",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x40]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000062f2",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x3c]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006306",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x38]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000631a",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x34]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000632e",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x30]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006342",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x2c]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006356",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0x28]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000636a",
            "MOV dword ptr [EBP + -0x4],EBX",
            "LEA EAX,[EBP + -0xc]",
            "PUSH EAX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000637e",
            "MOV dword ptr [EBP + -0x4],EBX",
            "MOV EAX,dword ptr [EBP + -0x3c]",
            "CMP dword ptr [EBP + -0x4],EDI",
            "MOV EDX,EAX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "JNZ 0x00006435",
            "MOV ECX,dword ptr [EBP + 0x14]",
            "CMP ECX,EDI",
            "JZ 0x000063d7",
            "CMP EAX,dword ptr [EBP + 0x18]",
            "JNC 0x000063a6",
            "AND byte ptr [EAX + ECX*0x1],0x0",
            "MOV EAX,dword ptr [EBP + -0x3c]",
            "MOV EDI,EAX",
            "JMP 0x000063a9",
            "MOV EDI,dword ptr [EBP + 0x18]",
            "TEST EAX,EAX",
            "JBE 0x000063c9",
            "CMP dword ptr [EBP + 0x18],0x0",
            "JBE 0x000063c9",
            "PUSH dword ptr [ESI]",
            "PUSH 0x1",
            "PUSH EDI",
            "PUSH ECX",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JZ 0x000063c9",
            "MOV dword ptr [EBP + -0x4],EBX",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SUB EDX,EDI",
            "CMP dword ptr [EBP + -0x4],0x0",
            "MOV dword ptr [EBP + 0x8],EDX",
            "JNZ 0x00006435",
            "CMP dword ptr [EBP + 0x1c],0x0",
            "JZ 0x00006435",
            "MOV EDI,dword ptr [EBP + -0x38]",
            "CMP EDI,dword ptr [EBP + 0x20]",
            "JC 0x000063e8",
            "MOV EDI,dword ptr [EBP + 0x20]",
            "TEST EDX,EDX",
            "JZ 0x00006405",
            "PUSH 0x1",
            "PUSH EDX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00006402",
            "AND dword ptr [EBP + 0x8],EAX",
            "JMP 0x00006405",
            "MOV dword ptr [EBP + -0x4],EBX",
            "CMP dword ptr [EBP + -0x38],0x0",
            "JBE 0x00006429",
            "CMP dword ptr [EBP + 0x20],0x0",
            "JBE 0x00006429",
            "PUSH dword ptr [ESI]",
            "PUSH 0x1",
            "PUSH EDI",
            "PUSH dword ptr [EBP + 0x1c]",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JZ 0x00006429",
            "MOV dword ptr [EBP + -0x4],EBX",
            "MOV EAX,dword ptr [EBP + -0x38]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SUB EAX,EDI",
            "ADD EDX,EAX",
            "JMP 0x00006438",
            "ADD EDX,dword ptr [EBP + -0x38]",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JNZ 0x000064b3",
            "MOV EDI,dword ptr [EBP + 0x24]",
            "TEST EDI,EDI",
            "JZ 0x00006498",
            "MOV EAX,dword ptr [EBP + -0x34]",
            "MOV EBX,dword ptr [EBP + 0x28]",
            "CMP EAX,EBX",
            "JNC 0x00006456",
            "AND byte ptr [EAX + EDI*0x1],0x0",
            "MOV EBX,dword ptr [EBP + -0x34]",
            "TEST EDX,EDX",
            "JZ 0x0000646f",
            "PUSH 0x1",
            "PUSH EDX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x0000646f",
            "OR dword ptr [EBP + -0x4],0xffffffff",
            "CMP dword ptr [EBP + -0x34],0x0",
            "JBE 0x00006492",
            "CMP dword ptr [EBP + 0x28],0x0",
            "JBE 0x00006492",
            "PUSH dword ptr [ESI]",
            "PUSH 0x1",
            "PUSH EBX",
            "PUSH EDI",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JZ 0x00006492",
            "OR dword ptr [EBP + -0x4],0xffffffff",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JNZ 0x000064b3",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "TEST EDI,EDI",
            "JZ 0x000064a7",
            "PUSH 0x14",
            "LEA ESI,[EBP + -0x5c]",
            "POP ECX",
            "MOVSD.REP ES:EDI,ESI",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "TEST EAX,EAX",
            "JZ 0x000064b3",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "MOV dword ptr [EAX],ECX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "POP EBX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000061e0",
            "end": "000064ba"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000621b",
                    "00006232"
                ],
                "type": "undefined4"
            },
            "local_50": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006295",
                    "000062ad"
                ],
                "type": "undefined4"
            },
            "local_60": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006245",
                    "000064a1"
                ],
                "type": "undefined"
            },
            "local_4c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000062b5"
                ],
                "type": "undefined"
            },
            "local_5c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006259"
                ],
                "type": "undefined"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006356"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000061ef",
                    "00006216",
                    "0000622c",
                    "0000623b",
                    "00006256",
                    "0000626a",
                    "0000627e",
                    "00006292",
                    "000062a6",
                    "000062c7",
                    "000062db",
                    "000062ef",
                    "00006303",
                    "00006317",
                    "0000632b",
                    "0000633f",
                    "00006353",
                    "00006367",
                    "0000637b",
                    "00006381",
                    "000063c6",
                    "000063ce",
                    "00006402",
                    "00006426",
                    "00006438",
                    "0000646b",
                    "0000648e",
                    "00006492",
                    "000064b3"
                ],
                "type": "undefined4"
            },
            "local_3c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006306",
                    "000063dd",
                    "00006405",
                    "00006429",
                    "00006435"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000062a9"
                ],
                "type": "undefined"
            },
            "local_38": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000631a",
                    "00006445",
                    "00006453",
                    "0000646f"
                ],
                "type": "undefined4"
            },
            "local_48": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000062ca"
                ],
                "type": "undefined"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000636a",
                    "000064ae"
                ],
                "type": "undefined4"
            },
            "local_54": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006281"
                ],
                "type": "undefined"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006342"
                ],
                "type": "undefined"
            },
            "local_40": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000062f2",
                    "0000637e",
                    "0000639f"
                ],
                "type": "undefined4"
            },
            "local_58": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000626d"
                ],
                "type": "undefined"
            },
            "local_34": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000632e"
                ],
                "type": "undefined"
            },
            "local_44": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000062de"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_000061e0",
        "original_name": "FUN_000061e0",
        "predicted_name": "The function you provided is likely a decompiled version of the C code for the `crypto_aead_encrypt` function from the Sodium library. The function is responsible for encrypting a message using the ChaCha20-Poly1305 authenticated encryption algorithm.",
        "prediction_full_response": "The function you provided is likely a decompiled version of the C code for the `crypto_aead_encrypt` function from the Sodium library. The function is responsible for encrypting a message using the ChaCha20-Poly1305 authenticated encryption algorithm.\n\nHere is the original function signature:\n\nint crypto_aead_encrypt(unsigned char *c, unsigned long long *clen,\n                        const unsigned char *m, unsigned long long mlen,\n                        const unsigned char *ad, unsigned long long adlen,\n                        const unsigned char *nsec, const unsigned char *npub,\n                        const unsigned char *k)\n\nThe function takes the following arguments:\n\n* `c`: A pointer to the ciphertext output buffer.\n* `clen`: A pointer to the length of the ciphertext output buffer.\n* `m`: A pointer to the plaintext input buffer.\n* `mlen`: The length of the plaintext input buffer.\n* `ad`: A pointer to the additional data input buffer.\n* `adlen`: The length of the additional data input buffer."
    },
    "0000135e": {
        "decomp_code": "\nvoid * __thiscall FUN_0000135e(void *param_1,byte param_2)\n\n{\n  FUN_0000137a();\n  if ((param_2 & 1) != 0) {\n    operator_delete(param_1);\n  }\n  return param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "CALL 0x0000137a",
            "TEST byte ptr [ESP + 0x8],0x1",
            "JZ 0x00001374",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "MOV EAX,ESI",
            "POP ESI",
            "RET 0x4"
        ],
        "function_address": {
            "start": "0000135e",
            "end": "00001379"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000135e",
        "original_name": "FUN_0000135e",
        "predicted_name": "operator_delete_or_not",
        "prediction_full_response": "The predicted function name is operator_delete_or_not</s>"
    },
    "000064bb": {
        "decomp_code": "\nvoid FUN_000064bb(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)\n\n{\n  FUN_000061e0(param_1,param_2,0,param_3,param_4,param_5,param_6,param_7,param_8);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH dword ptr [EBP + 0x24]",
            "PUSH dword ptr [EBP + 0x20]",
            "PUSH dword ptr [EBP + 0x1c]",
            "PUSH dword ptr [EBP + 0x18]",
            "PUSH dword ptr [EBP + 0x14]",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH 0x0",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x000061e0",
            "ADD ESP,0x24",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "000064bb",
            "end": "000064e1"
        },
        "variable_metadata": {},
        "func_name": "FUN_000064bb",
        "original_name": "FUN_000064bb",
        "predicted_name": "FUN_000061e0.",
        "prediction_full_response": "The predicted function name is FUN_000061e0.</s>"
    },
    "00007070": {
        "decomp_code": "\nvoid FUN_00007070(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined1 local_20c [260];\n  char local_108 [260];\n  \n  if ((param_1 != (char *)0x0) && (iVar2 = (*pcRam00408068)(param_1), iVar2 == -1)) {\n    (*pcRam004080c0)(param_1,0);\n  }\n  cVar1 = *param_2;\n  pcVar3 = param_2;\n  pcVar4 = param_2;\n  if (cVar1 != '\\0') {\n    do {\n      if ((cVar1 == '/') || (cVar1 == '\\\\')) {\n        pcVar4 = pcVar3;\n      }\n      cVar1 = pcVar3[1];\n      pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    if (pcVar4 != param_2) {\n      memcpy(local_20c,param_2,(int)pcVar4 - (int)param_2);\n      local_20c[(int)pcVar4 - (int)param_2] = 0;\n      FUN_00007070(param_1,local_20c);\n    }\n    local_108[0] = '\\0';\n    if (param_1 != (char *)0x0) {\n      strcpy(local_108,param_1);\n    }\n    strcat(local_108,param_2);\n    iVar2 = (*pcRam00408068)(local_108);\n    if (iVar2 == -1) {\n      (*pcRam004080c0)(local_108,0);\n    }\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x208",
            "PUSH EBX",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "TEST EBX,EBX",
            "PUSH EDI",
            "JZ 0x00007097",
            "PUSH EBX",
            "CALL dword ptr [0x00408068]",
            "CMP EAX,-0x1",
            "JNZ 0x00007097",
            "PUSH 0x0",
            "PUSH EBX",
            "CALL dword ptr [0x004080c0]",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV AL,byte ptr [EDI]",
            "TEST AL,AL",
            "JZ 0x00007132",
            "PUSH ESI",
            "MOV ESI,EDI",
            "MOV ECX,EDI",
            "CMP AL,0x2f",
            "JZ 0x000070b1",
            "CMP AL,0x5c",
            "JNZ 0x000070b3",
            "MOV ESI,ECX",
            "MOV AL,byte ptr [ECX + 0x1]",
            "INC ECX",
            "TEST AL,AL",
            "JNZ 0x000070a9",
            "CMP ESI,EDI",
            "JZ 0x000070e7",
            "SUB ESI,EDI",
            "LEA EAX,[EBP + 0xfffffdf8]",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x00007706",
            "AND byte ptr [EBP + ESI*0x1 + 0xfffffdf8],0x0",
            "LEA EAX,[EBP + 0xfffffdf8]",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x00007070",
            "ADD ESP,0x14",
            "AND byte ptr [EBP + 0xfffffefc],0x0",
            "POP ESI",
            "TEST EBX,EBX",
            "JZ 0x00007102",
            "LEA EAX,[EBP + 0xfffffefc]",
            "PUSH EBX",
            "PUSH EAX",
            "CALL 0x000076a8",
            "POP ECX",
            "POP ECX",
            "LEA EAX,[EBP + 0xfffffefc]",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x000077b4",
            "POP ECX",
            "LEA EAX,[EBP + 0xfffffefc]",
            "POP ECX",
            "PUSH EAX",
            "CALL dword ptr [0x00408068]",
            "CMP EAX,-0x1",
            "JNZ 0x00007132",
            "LEA EAX,[EBP + 0xfffffefc]",
            "PUSH 0x0",
            "PUSH EAX",
            "CALL dword ptr [0x004080c0]",
            "POP EDI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00007070",
            "end": "00007135"
        },
        "variable_metadata": {
            "local_108": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000070e7",
                    "000070f3",
                    "00007102",
                    "00007110",
                    "00007123"
                ],
                "type": "undefined1"
            },
            "local_20c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000070c1",
                    "000070d7"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00007070",
        "original_name": "FUN_00007070",
        "predicted_name": "FUN_00007070.",
        "prediction_full_response": "The predicted function name is FUN_00007070.</s>"
    },
    "000018b9": {
        "decomp_code": "\nundefined4 __fastcall FUN_000018b9(int param_1)\n\n{\n  if (*(int *)(param_1 + 8) != 0) {\n    (*pcRam0040f89c)(*(int *)(param_1 + 8));\n    *(undefined4 *)(param_1 + 8) = 0;\n  }\n  if (*(int *)(param_1 + 0xc) != 0) {\n    (*pcRam0040f89c)(*(int *)(param_1 + 0xc));\n    *(undefined4 *)(param_1 + 0xc) = 0;\n  }\n  if (*(int *)(param_1 + 4) != 0) {\n    (*pcRam00408010)(*(int *)(param_1 + 4),0);\n    *(undefined4 *)(param_1 + 4) = 0;\n  }\n  return 1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "TEST EAX,EAX",
            "JZ 0x000018ce",
            "PUSH EAX",
            "CALL dword ptr [0x0040f89c]",
            "AND dword ptr [ESI + 0x8],0x0",
            "MOV EAX,dword ptr [ESI + 0xc]",
            "TEST EAX,EAX",
            "JZ 0x000018e0",
            "PUSH EAX",
            "CALL dword ptr [0x0040f89c]",
            "AND dword ptr [ESI + 0xc],0x0",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x000018f4",
            "PUSH 0x0",
            "PUSH EAX",
            "CALL dword ptr [0x00408010]",
            "AND dword ptr [ESI + 0x4],0x0",
            "PUSH 0x1",
            "POP EAX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "000018b9",
            "end": "000018f8"
        },
        "variable_metadata": {},
        "func_name": "FUN_000018b9",
        "original_name": "FUN_000018b9",
        "predicted_name": "\"cleanup_fd_list\".",
        "prediction_full_response": "The predicted function name is \"cleanup_fd_list\".</s>"
    },
    "0000583c": {
        "decomp_code": "\nundefined4 FUN_0000583c(int *param_1)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  \n  if ((((param_1 != (int *)0x0) && ((uint *)param_1[7] != (uint *)0x0)) && (*param_1 != 0)) &&\n     (uVar1 = *(uint *)param_1[7], uVar1 < 0xe)) {\n                    /* WARNING: Could not emulate address calculation at 0x00005880 */\n                    /* WARNING: Treating indirect jump as call */\n    uVar2 = (**(code **)(uVar1 * 4 + 0x405b76))();\n    return uVar2;\n  }\n  return 0xfffffffe;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "TEST ESI,ESI",
            "JZ 0x00005b5d",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "TEST EAX,EAX",
            "JZ 0x00005b5d",
            "CMP dword ptr [ESI],0x0",
            "JZ 0x00005b5d",
            "CMP dword ptr [EBP + 0xc],0x4",
            "PUSH -0x5",
            "POP EBX",
            "JNZ 0x0000586f",
            "MOV dword ptr [EBP + 0xc],EBX",
            "JMP 0x00005873",
            "AND dword ptr [EBP + 0xc],0x0",
            "MOV ECX,dword ptr [EAX]",
            "PUSH 0xd",
            "POP EDI",
            "CMP ECX,EDI",
            "JA 0x00005b5d",
            "JMP dword ptr [ECX*0x4 + 0x405b76]",
            "MOV ECX,dword ptr [ESI + 0x4]",
            "TEST ECX,ECX",
            "JZ 0x00005a87",
            "DEC ECX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],ECX",
            "MOV ECX,dword ptr [ESI]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV dword ptr [EAX + 0x4],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "AND ECX,0xf",
            "INC dword ptr [ESI]",
            "CMP CL,0x8",
            "JZ 0x000058c2",
            "MOV dword ptr [EAX],EDI",
            "MOV dword ptr [ESI + 0x18],0x40f7fc",
            "JMP 0x00005a73",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "SHR ECX,0x4",
            "ADD ECX,0x8",
            "CMP ECX,dword ptr [EAX + 0x10]",
            "JBE 0x000058de",
            "MOV dword ptr [EAX],EDI",
            "MOV dword ptr [ESI + 0x18],0x40f7e8",
            "JMP 0x00005a73",
            "MOV dword ptr [EAX],0x1",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [ESI]",
            "MOV dword ptr [EBP + 0x8],ECX",
            "MOV ECX,dword ptr [ESI + 0x1c]",
            "PUSH 0x1f",
            "MOVZX EBX,byte ptr [EAX]",
            "INC EAX",
            "XOR EDX,EDX",
            "MOV dword ptr [ESI],EAX",
            "MOV EAX,dword ptr [ECX + 0x4]",
            "SHL EAX,0x8",
            "ADD EAX,EBX",
            "POP EDI",
            "DIV EDI",
            "TEST EDX,EDX",
            "JZ 0x00005938",
            "PUSH 0xd",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "POP EDI",
            "MOV dword ptr [ECX],EDI",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [ESI + 0x18],0x40f7d0",
            "MOV dword ptr [EAX + 0x4],0x5",
            "JMP 0x00005a7d",
            "TEST BL,0x20",
            "JNZ 0x00005a8e",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "PUSH 0xd",
            "MOV dword ptr [ECX],0x7",
            "POP EDI",
            "JMP 0x00005a7d",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH dword ptr [EAX + 0x14]",
            "CALL 0x000043b6",
            "MOV EBX,EAX",
            "ADD ESP,0xc",
            "CMP EBX,-0x3",
            "JNZ 0x00005977",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX],EDI",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "AND dword ptr [EAX + 0x4],0x0",
            "JMP 0x00005a7d",
            "TEST EBX,EBX",
            "JNZ 0x0000597e",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "CMP EBX,0x1",
            "JNZ 0x00005a87",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "LEA ECX,[EAX + 0x4]",
            "PUSH ECX",
            "PUSH ESI",
            "PUSH dword ptr [EAX + 0x14]",
            "CALL 0x000042c0",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "ADD ESP,0xc",
            "CMP dword ptr [EAX + 0xc],0x0",
            "JZ 0x000059b1",
            "MOV dword ptr [EAX],0xc",
            "JMP 0x00005a7d",
            "MOV dword ptr [EAX],0x8",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV ECX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [ESI]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,0x18",
            "MOV dword ptr [ECX + 0x8],EAX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0x9",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x10",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0xa",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x8",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0xb",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "CMP ECX,dword ptr [EAX + 0x8]",
            "JZ 0x00005b65",
            "MOV dword ptr [EAX],EDI",
            "MOV dword ptr [ESI + 0x18],0x40f7b8",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX + 0x4],0x5",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV ECX,dword ptr [EAX]",
            "JMP 0x00005878",
            "MOV EAX,EBX",
            "JMP 0x00005b60",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EAX],0x2",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV ECX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOV EAX,dword ptr [ESI]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "MOVZX EAX,byte ptr [EAX]",
            "SHL EAX,0x18",
            "MOV dword ptr [ECX + 0x8],EAX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0x3",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x10",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0x4",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x8",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV dword ptr [EAX],0x5",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "TEST EAX,EAX",
            "JZ 0x00005a87",
            "MOV ECX,dword ptr [ESI]",
            "DEC EAX",
            "INC dword ptr [ESI + 0x8]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "MOVZX ECX,byte ptr [ECX]",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "PUSH 0x2",
            "ADD dword ptr [EAX + 0x8],ECX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "INC dword ptr [ESI]",
            "MOV ECX,dword ptr [EAX + 0x8]",
            "MOV dword ptr [ESI + 0x30],ECX",
            "MOV dword ptr [EAX],0x6",
            "JMP 0x00005b5f",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX],EDI",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [ESI + 0x18],0x40f608",
            "AND dword ptr [EAX + 0x4],0x0",
            "PUSH -0x2",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "POP EBP",
            "RET",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EAX],0xc",
            "PUSH 0x1",
            "JMP 0x00005b5f",
            "PUSH -0x3",
            "JMP 0x00005b5f"
        ],
        "function_address": {
            "start": "0000583c",
            "end": "00005b75"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000583c",
        "original_name": "FUN_0000583c",
        "predicted_name": "mu_stream_read",
        "prediction_full_response": "The predicted function name is mu_stream_read</s>"
    },
    "00005739": {
        "decomp_code": "\nundefined4 FUN_00005739(int param_1)\n\n{\n  int iVar1;\n  \n  if (((param_1 != 0) && (*(int *)(param_1 + 0x1c) != 0)) && (*(int *)(param_1 + 0x24) != 0)) {\n    iVar1 = *(int *)(*(int *)(param_1 + 0x1c) + 0x14);\n    if (iVar1 != 0) {\n      FUN_00004be5(iVar1,param_1);\n    }\n    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),*(undefined4 *)(param_1 + 0x1c));\n    *(undefined4 *)(param_1 + 0x1c) = 0;\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "TEST ESI,ESI",
            "JZ 0x00005772",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "TEST EAX,EAX",
            "JZ 0x00005772",
            "CMP dword ptr [ESI + 0x24],0x0",
            "JZ 0x00005772",
            "MOV EAX,dword ptr [EAX + 0x14]",
            "TEST EAX,EAX",
            "JZ 0x0000575f",
            "PUSH ESI",
            "PUSH EAX",
            "CALL 0x00004be5",
            "POP ECX",
            "POP ECX",
            "PUSH dword ptr [ESI + 0x1c]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "AND dword ptr [ESI + 0x1c],0x0",
            "POP ECX",
            "POP ECX",
            "XOR EAX,EAX",
            "POP ESI",
            "RET",
            "PUSH -0x2",
            "POP EAX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00005739",
            "end": "00005776"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005739",
        "original_name": "FUN_00005739",
        "predicted_name": "FUN_00004be5.",
        "prediction_full_response": "The predicted function name is FUN_00004be5.</s>"
    },
    "00007918": {
        "decomp_code": "\nvoid __thiscall type_info::~type_info(type_info *this)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00007918. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408198)();\n  return;\n}\n\n",
        "args_metadata": {
            "this": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": true
                },
                "addresses": [],
                "count": 0,
                "type": "type_info *",
                "register": "ECX"
            }
        },
        "assembly": [
            "JMP dword ptr [0x00408198]"
        ],
        "function_address": {
            "start": "00007918",
            "end": "0000791d"
        },
        "variable_metadata": {
            "this": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": true
                },
                "addresses": [],
                "type": "type_info *"
            }
        },
        "func_name": "~type_info",
        "original_name": "~type_info",
        "predicted_name": "~type_info.",
        "prediction_full_response": "The predicted function name is ~type_info.</s>"
    },
    "000075c4": {
        "decomp_code": "\nvoid FUN_000075c4(int *param_1,undefined4 param_2,undefined4 *param_3)\n\n{\n  *param_3 = 0;\n  *(undefined1 *)(param_3 + 1) = 0;\n  param_3[0x4a] = 0;\n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else if (*param_1 == 1) {\n    uRam0040f938 = FUN_00006c40(param_2,param_3);\n  }\n  else {\n    uRam0040f938 = 0x80000;\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0xc]",
            "MOV ECX,dword ptr [ESP + 0x4]",
            "XOR EDX,EDX",
            "CMP ECX,EDX",
            "MOV dword ptr [EAX],EDX",
            "MOV byte ptr [EAX + 0x4],DL",
            "MOV dword ptr [EAX + 0x128],EDX",
            "JNZ 0x000075e4",
            "MOV EAX,0x10000",
            "JMP 0x000075fd",
            "CMP dword ptr [ECX],0x1",
            "JZ 0x000075f0",
            "MOV EAX,0x80000",
            "JMP 0x000075fd",
            "MOV ECX,dword ptr [ECX + 0x4]",
            "PUSH EAX",
            "PUSH dword ptr [ESP + 0xc]",
            "CALL 0x00006c40",
            "MOV [0x0040f938],EAX",
            "RET"
        ],
        "function_address": {
            "start": "000075c4",
            "end": "00007602"
        },
        "variable_metadata": {},
        "func_name": "FUN_000075c4",
        "original_name": "FUN_000075c4",
        "predicted_name": "get_max_size.",
        "prediction_full_response": "The predicted function name is get_max_size.</s>"
    },
    "00002a76": {
        "decomp_code": "\nvoid __thiscall FUN_00002a76(int param_1,byte *param_2,uint *param_3,int param_4,byte *param_5)\n\n{\n  undefined4 uVar1;\n  uint uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  undefined4 *puVar6;\n  int iVar7;\n  int iVar8;\n  undefined4 *puVar9;\n  int iVar10;\n  undefined1 local_18 [20];\n  \n  if (param_2 == (byte *)0x0) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  if (((param_4 != 0x10) && (param_4 != 0x18)) && (param_4 != 0x20)) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  if (((param_5 != (byte *)0x10) && (param_5 != (byte *)0x18)) && (param_5 != (byte *)0x20)) {\n    param_3 = (uint *)0x40f57c;\n    (*pcRam00408184)(&param_3);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_18,(ThrowInfo *)0x40d570);\n  }\n  *(byte **)(param_1 + 0x3cc) = param_5;\n  *(int *)(param_1 + 0x3c8) = param_4;\n  memcpy((void *)(param_1 + 0x3d0),param_3,(size_t)param_5);\n  memcpy((void *)(param_1 + 0x3f0),param_3,*(size_t *)(param_1 + 0x3cc));\n  if (*(int *)(param_1 + 0x3c8) == 0x10) {\n    if (*(int *)(param_1 + 0x3cc) == 0x10) {\n      iVar3 = 10;\n    }\n    else {\n      iVar3 = ((*(int *)(param_1 + 0x3cc) != 0x18) - 1 & 0xfffffffe) + 0xe;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0x3c8) != 0x18) {\n      *(undefined4 *)(param_1 + 0x410) = 0xe;\n      goto LAB_00002b9a;\n    }\n    iVar3 = ((*(int *)(param_1 + 0x3cc) == 0x20) - 1 & 0xfffffffe) + 0xe;\n  }\n  *(int *)(param_1 + 0x410) = iVar3;\nLAB_00002b9a:\n  iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n  iVar7 = 0;\n  if (-1 < *(int *)(param_1 + 0x410)) {\n    puVar6 = (undefined4 *)(param_1 + 8);\n    do {\n      iVar10 = iVar3;\n      puVar9 = puVar6;\n      if (0 < iVar3) {\n        for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n          *puVar9 = 0;\n          puVar9 = puVar9 + 1;\n        }\n      }\n      iVar7 = iVar7 + 1;\n      puVar6 = puVar6 + 8;\n    } while (iVar7 <= *(int *)(param_1 + 0x410));\n  }\n  iVar7 = 0;\n  if (-1 < *(int *)(param_1 + 0x410)) {\n    puVar6 = (undefined4 *)(param_1 + 0x1e8);\n    do {\n      iVar10 = iVar3;\n      puVar9 = puVar6;\n      if (0 < iVar3) {\n        for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n          *puVar9 = 0;\n          puVar9 = puVar9 + 1;\n        }\n      }\n      iVar7 = iVar7 + 1;\n      puVar6 = puVar6 + 8;\n    } while (iVar7 <= *(int *)(param_1 + 0x410));\n  }\n  iVar7 = *(int *)(param_1 + 0x3c8) / 4;\n  iVar10 = (*(int *)(param_1 + 0x410) + 1) * iVar3;\n  puVar5 = (uint *)(param_1 + 0x414);\n  param_3 = (uint *)iVar7;\n  if (0 < iVar7) {\n    do {\n      *puVar5 = (uint)*param_2 << 0x18;\n      *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n      *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n      *puVar5 = *puVar5 | (uint)param_2[3];\n      param_2 = param_2 + 4;\n      puVar5 = puVar5 + 1;\n      param_3 = (uint *)((int)param_3 + -1);\n    } while (param_3 != (uint *)0x0);\n  }\n  param_3 = (uint *)0x0;\n  if (0 < iVar7) {\n    puVar6 = (undefined4 *)(param_1 + 0x414);\n    do {\n      if (iVar10 <= (int)param_3) goto LAB_00002e04;\n      iVar4 = (int)param_3 / iVar3;\n      iVar8 = (int)param_3 % iVar3;\n      *(undefined4 *)(param_1 + 8 + (iVar8 + iVar4 * 8) * 4) = *puVar6;\n      param_3 = (uint *)((int)param_3 + 1);\n      uVar1 = *puVar6;\n      puVar6 = puVar6 + 1;\n      *(undefined4 *)(param_1 + 0x1e8 + (iVar8 + (*(int *)(param_1 + 0x410) - iVar4) * 8) * 4) =\n           uVar1;\n    } while ((int)param_3 < iVar7);\n  }\n  if ((int)param_3 < iVar10) {\n    param_5 = (byte *)0x40bbfc;\n    do {\n      uVar2 = *(uint *)(param_1 + 0x410 + iVar7 * 4);\n      *(uint *)(param_1 + 0x414) =\n           *(uint *)(param_1 + 0x414) ^\n           CONCAT31(CONCAT21(CONCAT11(*(byte *)((uVar2 >> 0x10 & 0xff) + 0x4089fc) ^ *param_5,\n                                      *(undefined1 *)((uVar2 >> 8 & 0xff) + 0x4089fc)),\n                             *(undefined1 *)((uVar2 & 0xff) + 0x4089fc)),\n                    *(undefined1 *)((uVar2 >> 0x18) + 0x4089fc));\n      param_5 = param_5 + 1;\n      if (iVar7 == 8) {\n        puVar5 = (uint *)(param_1 + 0x418);\n        iVar4 = 3;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n        uVar2 = *(uint *)(param_1 + 0x420);\n        puVar5 = (uint *)(param_1 + 0x428);\n        *(uint *)(param_1 + 0x424) =\n             *(uint *)(param_1 + 0x424) ^\n             CONCAT31(CONCAT21(CONCAT11(*(undefined1 *)((uVar2 >> 0x18) + 0x4089fc),\n                                        *(undefined1 *)((uVar2 >> 0x10 & 0xff) + 0x4089fc)),\n                               *(undefined1 *)((uVar2 >> 8 & 0xff) + 0x4089fc)),\n                      *(undefined1 *)((uVar2 & 0xff) + 0x4089fc));\n        iVar4 = 3;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n      }\n      else if (1 < iVar7) {\n        puVar5 = (uint *)(param_1 + 0x418);\n        iVar4 = iVar7 + -1;\n        do {\n          *puVar5 = *puVar5 ^ puVar5[-1];\n          puVar5 = puVar5 + 1;\n          iVar4 = iVar4 + -1;\n        } while (iVar4 != 0);\n      }\n      param_2 = (byte *)0x0;\n      if (0 < iVar7) {\n        puVar6 = (undefined4 *)(param_1 + 0x414);\n        do {\n          if (iVar10 <= (int)param_3) goto LAB_00002e04;\n          iVar4 = (int)param_3 / iVar3;\n          iVar8 = (int)param_3 % iVar3;\n          *(undefined4 *)(param_1 + 8 + (iVar8 + iVar4 * 8) * 4) = *puVar6;\n          param_2 = (byte *)((int)param_2 + 1);\n          uVar1 = *puVar6;\n          puVar6 = puVar6 + 1;\n          param_3 = (uint *)((int)param_3 + 1);\n          *(undefined4 *)(param_1 + 0x1e8 + (iVar8 + (*(int *)(param_1 + 0x410) - iVar4) * 8) * 4) =\n               uVar1;\n        } while ((int)param_2 < iVar7);\n      }\n    } while ((int)param_3 < iVar10);\n  }\nLAB_00002e04:\n  param_5 = (byte *)0x1;\n  if (1 < *(int *)(param_1 + 0x410)) {\n    param_3 = (uint *)(param_1 + 0x208);\n    do {\n      iVar7 = iVar3;\n      puVar5 = param_3;\n      if (0 < iVar3) {\n        do {\n          uVar2 = *puVar5;\n          *puVar5 = *(uint *)((uVar2 >> 0x18) * 4 + 0x40abfc) ^\n                    *(uint *)((uVar2 >> 0x10 & 0xff) * 4 + 0x40affc) ^\n                    *(uint *)((uVar2 >> 8 & 0xff) * 4 + 0x40b3fc) ^\n                    *(uint *)((uVar2 & 0xff) * 4 + 0x40b7fc);\n          iVar7 = iVar7 + -1;\n          puVar5 = puVar5 + 1;\n        } while (iVar7 != 0);\n      }\n      param_5 = (byte *)((int)param_5 + 1);\n      param_3 = param_3 + 8;\n    } while ((int)param_5 < *(int *)(param_1 + 0x410));\n  }\n  *(undefined1 *)(param_1 + 4) = 1;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x14",
            "CMP dword ptr [EBP + 0x8],0x0",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV ESI,ECX",
            "JNZ 0x00002aa9",
            "LEA EAX,[EBP + 0xc]",
            "LEA ECX,[EBP + -0x14]",
            "PUSH EAX",
            "MOV dword ptr [EBP + 0xc],0x40f57c",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x14]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "PUSH 0x18",
            "POP EBX",
            "PUSH 0x10",
            "POP EDI",
            "CMP ECX,EDI",
            "JZ 0x00002ae1",
            "CMP ECX,EBX",
            "JZ 0x00002ae1",
            "CMP ECX,0x20",
            "JZ 0x00002ae1",
            "LEA EAX,[EBP + 0xc]",
            "LEA ECX,[EBP + -0x14]",
            "PUSH EAX",
            "MOV dword ptr [EBP + 0xc],0x40f57c",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x14]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "CMP EAX,EDI",
            "JZ 0x00002b13",
            "CMP EAX,EBX",
            "JZ 0x00002b13",
            "CMP EAX,0x20",
            "JZ 0x00002b13",
            "LEA EAX,[EBP + 0xc]",
            "LEA ECX,[EBP + -0x14]",
            "PUSH EAX",
            "MOV dword ptr [EBP + 0xc],0x40f57c",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x14]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "PUSH EAX",
            "MOV dword ptr [ESI + 0x3cc],EAX",
            "PUSH dword ptr [EBP + 0xc]",
            "LEA EAX,[ESI + 0x3d0]",
            "MOV dword ptr [ESI + 0x3c8],ECX",
            "PUSH EAX",
            "CALL 0x00007706",
            "PUSH dword ptr [ESI + 0x3cc]",
            "LEA EAX,[ESI + 0x3f0]",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH EAX",
            "CALL 0x00007706",
            "MOV EAX,dword ptr [ESI + 0x3c8]",
            "ADD ESP,0x18",
            "CMP EAX,EDI",
            "JZ 0x00002b75",
            "CMP EAX,EBX",
            "JZ 0x00002b61",
            "MOV dword ptr [ESI + 0x410],0xe",
            "JMP 0x00002b9a",
            "XOR EAX,EAX",
            "CMP dword ptr [ESI + 0x3cc],0x20",
            "SETZ AL",
            "DEC EAX",
            "AND AL,0xfe",
            "ADD EAX,0xe",
            "JMP 0x00002b94",
            "MOV EAX,dword ptr [ESI + 0x3cc]",
            "CMP EAX,EDI",
            "JNZ 0x00002b84",
            "PUSH 0xa",
            "POP EAX",
            "JMP 0x00002b94",
            "XOR ECX,ECX",
            "CMP EAX,EBX",
            "SETNZ CL",
            "DEC ECX",
            "AND ECX,0xfffffffe",
            "ADD ECX,0xe",
            "MOV EAX,ECX",
            "MOV dword ptr [ESI + 0x410],EAX",
            "MOV EAX,dword ptr [ESI + 0x3cc]",
            "PUSH 0x4",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "XOR EDX,EDX",
            "CMP dword ptr [ESI + 0x410],EDX",
            "MOV dword ptr [EBP + 0x10],EAX",
            "JL 0x00002bcf",
            "LEA EBX,[ESI + 0x8]",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "TEST ECX,ECX",
            "JLE 0x00002bc3",
            "XOR EAX,EAX",
            "MOV EDI,EBX",
            "STOSD.REP ES:EDI",
            "INC EDX",
            "ADD EBX,0x20",
            "CMP EDX,dword ptr [ESI + 0x410]",
            "JLE 0x00002bb6",
            "XOR EDX,EDX",
            "CMP dword ptr [ESI + 0x410],EDX",
            "JL 0x00002bf8",
            "LEA EBX,[ESI + 0x1e8]",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "TEST ECX,ECX",
            "JLE 0x00002bec",
            "XOR EAX,EAX",
            "MOV EDI,EBX",
            "STOSD.REP ES:EDI",
            "INC EDX",
            "ADD EBX,0x20",
            "CMP EDX,dword ptr [ESI + 0x410]",
            "JLE 0x00002bdf",
            "MOV EAX,dword ptr [ESI + 0x3c8]",
            "PUSH 0x4",
            "CDQ",
            "POP ECX",
            "MOV EDI,dword ptr [ESI + 0x410]",
            "IDIV ECX",
            "INC EDI",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "IMUL EDI,dword ptr [EBP + 0x10]",
            "MOV dword ptr [EBP + -0x8],EDI",
            "MOV EDX,EAX",
            "LEA EAX,[ESI + 0x414]",
            "TEST EDX,EDX",
            "MOV dword ptr [EBP + -0x4],EDX",
            "JLE 0x00002c4e",
            "MOV dword ptr [EBP + 0xc],EDX",
            "MOVZX EBX,byte ptr [ECX]",
            "SHL EBX,0x18",
            "INC ECX",
            "MOV dword ptr [EAX],EBX",
            "MOVZX EBX,byte ptr [ECX]",
            "SHL EBX,0x10",
            "OR dword ptr [EAX],EBX",
            "INC ECX",
            "XOR EBX,EBX",
            "MOV BH,byte ptr [ECX]",
            "OR dword ptr [EAX],EBX",
            "INC ECX",
            "MOVZX EBX,byte ptr [ECX]",
            "OR dword ptr [EAX],EBX",
            "INC ECX",
            "ADD EAX,0x4",
            "DEC dword ptr [EBP + 0xc]",
            "JNZ 0x00002c27",
            "AND dword ptr [EBP + 0xc],0x0",
            "TEST EDX,EDX",
            "JLE 0x00002ca5",
            "LEA ECX,[ESI + 0x414]",
            "CMP dword ptr [EBP + 0xc],EDI",
            "JGE 0x00002e04",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV EBX,dword ptr [ECX]",
            "CDQ",
            "IDIV dword ptr [EBP + 0x10]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CDQ",
            "IDIV dword ptr [EBP + 0x10]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV dword ptr [ESI + EAX*0x4 + 0x8],EBX",
            "MOV EAX,dword ptr [ESI + 0x410]",
            "SUB EAX,dword ptr [EBP + 0x8]",
            "INC dword ptr [EBP + 0xc]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV EDX,dword ptr [ECX]",
            "ADD ECX,0x4",
            "MOV dword ptr [ESI + EAX*0x4 + 0x1e8],EDX",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "CMP dword ptr [EBP + 0xc],EDX",
            "JL 0x00002c5c",
            "CMP dword ptr [EBP + 0xc],EDI",
            "JGE 0x00002e04",
            "MOV dword ptr [EBP + 0x14],0x40bbfc",
            "MOV EAX,dword ptr [ESI + EDX*0x4 + 0x410]",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "XOR ECX,ECX",
            "MOV CL,byte ptr [EBP + 0xa]",
            "MOVSX EBX,byte ptr [EBX]",
            "MOVSX ECX,byte ptr [ECX + 0x4089fc]",
            "XOR ECX,EBX",
            "XOR EBX,EBX",
            "MOV BL,AH",
            "AND EAX,0xff",
            "SHL ECX,0x8",
            "MOVZX EBX,byte ptr [EBX + 0x4089fc]",
            "MOVZX EAX,byte ptr [EAX + 0x4089fc]",
            "XOR ECX,EBX",
            "SHL ECX,0x8",
            "XOR ECX,EAX",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EBP + 0xb]",
            "SHL ECX,0x8",
            "MOVZX EAX,byte ptr [EAX + 0x4089fc]",
            "XOR ECX,EAX",
            "XOR dword ptr [ESI + 0x414],ECX",
            "INC dword ptr [EBP + 0x14]",
            "CMP EDX,0x8",
            "JZ 0x00002d32",
            "CMP EDX,0x1",
            "JLE 0x00002da7",
            "LEA EAX,[ESI + 0x418]",
            "LEA ECX,[EDX + -0x1]",
            "MOV EBX,dword ptr [EAX + -0x4]",
            "XOR dword ptr [EAX],EBX",
            "ADD EAX,0x4",
            "DEC ECX",
            "JNZ 0x00002d25",
            "JMP 0x00002da7",
            "PUSH 0x3",
            "LEA EAX,[ESI + 0x418]",
            "POP ECX",
            "MOV EBX,dword ptr [EAX + -0x4]",
            "XOR dword ptr [EAX],EBX",
            "ADD EAX,0x4",
            "DEC ECX",
            "JNZ 0x00002d3b",
            "MOV EAX,dword ptr [ESI + 0x420]",
            "XOR ECX,ECX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "XOR EBX,EBX",
            "MOV CL,byte ptr [EBP + 0xb]",
            "MOV BL,byte ptr [EBP + 0xa]",
            "PUSH 0x3",
            "MOVSX ECX,byte ptr [ECX + 0x4089fc]",
            "MOVZX EBX,byte ptr [EBX + 0x4089fc]",
            "SHL ECX,0x8",
            "XOR ECX,EBX",
            "XOR EBX,EBX",
            "MOV BL,AH",
            "AND EAX,0xff",
            "SHL ECX,0x8",
            "MOVZX EBX,byte ptr [EBX + 0x4089fc]",
            "MOVZX EAX,byte ptr [EAX + 0x4089fc]",
            "XOR ECX,EBX",
            "SHL ECX,0x8",
            "XOR ECX,EAX",
            "LEA EAX,[ESI + 0x428]",
            "XOR dword ptr [ESI + 0x424],ECX",
            "POP ECX",
            "MOV EBX,dword ptr [EAX + -0x4]",
            "XOR dword ptr [EAX],EBX",
            "ADD EAX,0x4",
            "DEC ECX",
            "JNZ 0x00002d9c",
            "AND dword ptr [EBP + 0x8],0x0",
            "TEST EDX,EDX",
            "JLE 0x00002dfb",
            "LEA ECX,[ESI + 0x414]",
            "CMP dword ptr [EBP + 0xc],EDI",
            "JGE 0x00002e04",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV EBX,dword ptr [ECX]",
            "CDQ",
            "IDIV dword ptr [EBP + 0x10]",
            "MOV EDI,EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "CDQ",
            "IDIV dword ptr [EBP + 0x10]",
            "LEA EAX,[EDX + EDI*0x8]",
            "MOV dword ptr [ESI + EAX*0x4 + 0x8],EBX",
            "MOV EAX,dword ptr [ESI + 0x410]",
            "SUB EAX,EDI",
            "INC dword ptr [EBP + 0x8]",
            "MOV EDI,dword ptr [EBP + -0x8]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV EDX,dword ptr [ECX]",
            "ADD ECX,0x4",
            "INC dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + EAX*0x4 + 0x1e8],EDX",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "CMP dword ptr [EBP + 0x8],EDX",
            "JL 0x00002db5",
            "CMP dword ptr [EBP + 0xc],EDI",
            "JL 0x00002cb5",
            "PUSH 0x1",
            "POP EAX",
            "CMP dword ptr [ESI + 0x410],EAX",
            "MOV dword ptr [EBP + 0x14],EAX",
            "JLE 0x00002e73",
            "LEA EAX,[ESI + 0x208]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "TEST ECX,ECX",
            "JLE 0x00002e61",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV EAX,dword ptr [EDI]",
            "XOR EDX,EDX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "XOR EBX,EBX",
            "MOV DL,byte ptr [EBP + 0xb]",
            "MOV BL,byte ptr [EBP + 0xa]",
            "MOV EDX,dword ptr [EDX*0x4 + 0x40abfc]",
            "XOR EDX,dword ptr [EBX*0x4 + 0x40affc]",
            "XOR EBX,EBX",
            "MOV BL,AH",
            "AND EAX,0xff",
            "XOR EDX,dword ptr [EBX*0x4 + 0x40b3fc]",
            "XOR EDX,dword ptr [EAX*0x4 + 0x40b7fc]",
            "MOV dword ptr [EDI],EDX",
            "ADD EDI,0x4",
            "DEC ECX",
            "JNZ 0x00002e25",
            "INC dword ptr [EBP + 0x14]",
            "ADD dword ptr [EBP + 0xc],0x20",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "CMP EAX,dword ptr [ESI + 0x410]",
            "JL 0x00002e1b",
            "MOV byte ptr [ESI + 0x4],0x1",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x10"
        ],
        "function_address": {
            "start": "00002a76",
            "end": "00002e7d"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002c12",
                    "00002dde"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002c1f",
                    "00002c9d",
                    "00002df3"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002a8a",
                    "00002a9b",
                    "00002ac2",
                    "00002ad3",
                    "00002af4",
                    "00002b05"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00002a76",
        "original_name": "FUN_00002a76",
        "predicted_name": "The function you provided is a C++ function that appears to be part of a larger program. It is not a complete function, and it is not possible to determine its purpose with the information provided.",
        "prediction_full_response": "The function you provided is a C++ function that appears to be part of a larger program. It is not a complete function, and it is not possible to determine its purpose with the information provided.\n\nThe function appears to be a member function of a class, and it takes a number of arguments, including a pointer to an instance of the class. The function appears to be setting some values in the class instance, based on the values of the arguments passed to the function.\n\nWithout more information about the program and the context in which this function is used, it is not possible to provide a more detailed explanation of the function's purpose.</s>"
    },
    "00005cc7": {
        "decomp_code": "\nundefined4 FUN_00005cc7(char *param_1)\n\n{\n  if ((*param_1 != '\\0') && (param_1[8] != '\\0')) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "CMP byte ptr [EAX],0x0",
            "JZ 0x00005cda",
            "CMP byte ptr [EAX + 0x8],0x0",
            "JZ 0x00005cda",
            "PUSH 0x1",
            "POP EAX",
            "RET",
            "XOR EAX,EAX",
            "RET"
        ],
        "function_address": {
            "start": "00005cc7",
            "end": "00005cdc"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005cc7",
        "original_name": "FUN_00005cc7",
        "predicted_name": "is_valid_uuid.",
        "prediction_full_response": "The predicted function name is is_valid_uuid.</s>"
    },
    "00003797": {
        "decomp_code": "\nvoid __thiscall FUN_00003797(int param_1,byte *param_2,byte *param_3)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  uint *puVar5;\n  byte *pbVar6;\n  undefined1 local_38 [12];\n  uint local_2c;\n  int local_28;\n  int local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  uint *local_c;\n  uint *local_8;\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_38,(ThrowInfo *)0x40d570);\n  }\n  if (*(int *)(param_1 + 0x3cc) == 0x10) {\n    FUN_000031bc(param_2,param_3);\n  }\n  else {\n    iVar3 = *(int *)(param_1 + 0x3cc) / 4;\n    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;\n    local_1c = *(int *)(iVar4 + 0x40bc28);\n    local_18 = *(int *)(iVar4 + 0x40bc30);\n    local_20 = *(int *)(iVar4 + 0x40bc38);\n    if (0 < iVar3) {\n      puVar5 = (uint *)(param_1 + 0x454);\n      local_10 = iVar3;\n      local_8 = (uint *)(param_1 + 0x1e8);\n      do {\n        *puVar5 = (uint)*param_2 << 0x18;\n        *puVar5 = *puVar5 | (uint)param_2[1] << 0x10;\n        *puVar5 = *puVar5 | (uint)param_2[2] << 8;\n        *puVar5 = *puVar5 | (uint)param_2[3];\n        puVar1 = local_8 + 1;\n        param_2 = param_2 + 4;\n        *puVar5 = *puVar5 ^ *local_8;\n        local_10 = local_10 + -1;\n        puVar5 = puVar5 + 1;\n        local_8 = puVar1;\n      } while (local_10 != 0);\n    }\n    local_10 = 1;\n    if (1 < *(int *)(param_1 + 0x410)) {\n      local_c = (uint *)(param_1 + 0x208);\n      do {\n        if (0 < iVar3) {\n          local_8 = local_c;\n          local_24 = local_18 - local_1c;\n          param_2 = (byte *)local_1c;\n          local_28 = local_20 - local_1c;\n          puVar5 = (uint *)(param_1 + 0x434);\n          local_14 = iVar3;\n          do {\n            local_2c = (uint)*(byte *)(param_1 + 0x455 + ((local_24 + (int)param_2) % iVar3) * 4);\n            puVar1 = local_8 + 1;\n            *puVar5 = *(uint *)(local_2c * 4 + 0x40a3fc) ^\n                      *(uint *)((*(uint *)(param_1 + 0x454 + ((local_28 + (int)param_2) % iVar3) * 4\n                                          ) & 0xff) * 4 + 0x40a7fc) ^\n                      *(uint *)((uint)*(byte *)(param_1 + 0x456 + ((int)param_2 % iVar3) * 4) * 4 +\n                               0x409ffc) ^\n                      *(uint *)((uint)*(byte *)((int)puVar5 + 0x23) * 4 + 0x409bfc) ^ *local_8;\n            puVar5 = puVar5 + 1;\n            param_2 = (byte *)((int)param_2 + 1);\n            local_14 = local_14 + -1;\n            local_8 = puVar1;\n          } while (local_14 != 0);\n        }\n        memcpy((void *)(param_1 + 0x454),(void *)(param_1 + 0x434),iVar3 << 2);\n        local_c = local_c + 8;\n        local_10 = local_10 + 1;\n      } while (local_10 < *(int *)(param_1 + 0x410));\n    }\n    local_8 = (uint *)0x0;\n    if (0 < iVar3) {\n      local_1c = local_1c - local_18;\n      local_20 = local_20 - local_18;\n      pbVar6 = param_3;\n      param_3 = (byte *)(param_1 + 0x454);\n      do {\n        uVar2 = *(undefined4 *)\n                 (param_1 + 0x1e8 + ((int)local_8 + *(int *)(param_1 + 0x410) * 8) * 4);\n        *pbVar6 = *(byte *)(*(byte *)((int)param_3 + 3) + 0x408afc) ^ (byte)((uint)uVar2 >> 0x18);\n        pbVar6[1] = *(byte *)(*(byte *)(param_1 + 0x456 + ((local_1c + local_18) % iVar3) * 4) +\n                             0x408afc) ^ (byte)((uint)uVar2 >> 0x10);\n        pbVar6[2] = *(byte *)(*(byte *)(param_1 + 0x455 + (local_18 % iVar3) * 4) + 0x408afc) ^\n                    (byte)((uint)uVar2 >> 8);\n        param_2._0_1_ = (byte)uVar2;\n        pbVar6[3] = *(byte *)((*(uint *)(param_1 + 0x454 + ((local_20 + local_18) % iVar3) * 4) &\n                              0xff) + 0x408afc) ^ (byte)param_2;\n        pbVar6 = pbVar6 + 4;\n        local_8 = (uint *)((int)local_8 + 1);\n        local_18 = local_18 + 1;\n        param_3 = (byte *)((int)param_3 + 4);\n      } while ((int)local_8 < iVar3);\n    }\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x34",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "CMP byte ptr [ESI + 0x4],0x0",
            "JNZ 0x000037c4",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0x34]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x34]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [ESI + 0x3cc]",
            "CMP EAX,0x10",
            "JNZ 0x000037e1",
            "PUSH dword ptr [EBP + 0xc]",
            "MOV ECX,ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x000031bc",
            "JMP 0x00003a21",
            "PUSH 0x4",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "MOV EDI,EAX",
            "SUB EAX,ECX",
            "XOR ECX,ECX",
            "CMP EDI,0x6",
            "SETNZ CL",
            "INC ECX",
            "NEG EAX",
            "SBB EAX,EAX",
            "AND EAX,ECX",
            "SHL EAX,0x5",
            "TEST EDI,EDI",
            "MOV ECX,dword ptr [EAX + 0x40bc28]",
            "MOV dword ptr [EBP + -0x18],ECX",
            "MOV ECX,dword ptr [EAX + 0x40bc30]",
            "MOV EAX,dword ptr [EAX + 0x40bc38]",
            "MOV dword ptr [EBP + -0x14],ECX",
            "MOV dword ptr [EBP + -0x1c],EAX",
            "LEA EAX,[ESI + 0x454]",
            "JLE 0x00003865",
            "LEA ECX,[ESI + 0x1e8]",
            "MOV dword ptr [EBP + -0xc],EDI",
            "MOV dword ptr [EBP + -0x4],ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOVZX EDX,byte ptr [ECX]",
            "SHL EDX,0x18",
            "INC ECX",
            "MOV dword ptr [EAX],EDX",
            "MOVZX EDX,byte ptr [ECX]",
            "SHL EDX,0x10",
            "OR dword ptr [EAX],EDX",
            "INC ECX",
            "XOR EDX,EDX",
            "MOV DH,byte ptr [ECX]",
            "OR dword ptr [EAX],EDX",
            "INC ECX",
            "MOV EDX,EAX",
            "MOVZX EBX,byte ptr [ECX]",
            "OR dword ptr [EAX],EBX",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + -0x4],0x4",
            "INC ECX",
            "MOV EBX,dword ptr [EBX]",
            "ADD EAX,0x4",
            "XOR dword ptr [EDX],EBX",
            "DEC dword ptr [EBP + -0xc]",
            "JNZ 0x00003831",
            "PUSH 0x1",
            "POP EAX",
            "CMP dword ptr [ESI + 0x410],EAX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "JLE 0x00003955",
            "LEA EAX,[ESI + 0x208]",
            "MOV dword ptr [EBP + -0x8],EAX",
            "TEST EDI,EDI",
            "JLE 0x00003923",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV EDX,dword ptr [EBP + -0x18]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [EBP + -0x14]",
            "SUB EAX,EDX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "MOV dword ptr [EBP + -0x20],EAX",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "SUB EAX,EDX",
            "LEA ECX,[ESI + 0x434]",
            "MOV dword ptr [EBP + -0x24],EAX",
            "MOV dword ptr [EBP + -0x10],EDI",
            "MOV EAX,dword ptr [EBP + -0x20]",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "ADD EAX,EBX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,EDX",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [ESI + EAX*0x4 + 0x455]",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "ADD EAX,EBX",
            "MOV dword ptr [EBP + -0x28],EDX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,dword ptr [ESI + EDX*0x4 + 0x454]",
            "MOV EDX,dword ptr [EBP + -0x28]",
            "AND EAX,0xff",
            "MOV EBX,dword ptr [EDX*0x4 + 0x40a3fc]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x40a7fc]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x456]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x409ffc]",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ECX + 0x23]",
            "XOR EBX,dword ptr [EAX*0x4 + 0x409bfc]",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "ADD dword ptr [EBP + -0x4],0x4",
            "XOR EBX,dword ptr [EAX]",
            "MOV dword ptr [ECX],EBX",
            "ADD ECX,0x4",
            "INC dword ptr [EBP + 0x8]",
            "DEC dword ptr [EBP + -0x10]",
            "JNZ 0x000038ad",
            "MOV EAX,EDI",
            "SHL EAX,0x2",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x434]",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x454]",
            "PUSH EAX",
            "CALL 0x00007706",
            "ADD dword ptr [EBP + -0x8],0x20",
            "ADD ESP,0xc",
            "INC dword ptr [EBP + -0xc]",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "CMP EAX,dword ptr [ESI + 0x410]",
            "JL 0x00003880",
            "AND dword ptr [EBP + -0x4],0x0",
            "TEST EDI,EDI",
            "JLE 0x00003a21",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV EBX,dword ptr [EBP + -0x14]",
            "LEA EAX,[ESI + 0x454]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "SUB EAX,EBX",
            "MOV dword ptr [EBP + -0x28],EAX",
            "MOV EAX,dword ptr [EBP + -0x1c]",
            "SUB EAX,EBX",
            "MOV dword ptr [EBP + -0x24],EAX",
            "MOV EAX,dword ptr [ESI + 0x410]",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "LEA EAX,[EDX + EAX*0x8]",
            "MOV EDX,dword ptr [EBP + 0xc]",
            "ADD dword ptr [EBP + 0xc],0x4",
            "MOV EAX,dword ptr [ESI + EAX*0x4 + 0x1e8]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EDX + 0x3]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x18",
            "MOV AL,byte ptr [EAX + 0x408afc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,dword ptr [EBP + -0x28]",
            "ADD EAX,EBX",
            "INC ECX",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x456]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x10",
            "MOV AL,byte ptr [EAX + 0x408afc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,EBX",
            "CDQ",
            "IDIV EDI",
            "XOR EAX,EAX",
            "INC ECX",
            "MOV AL,byte ptr [ESI + EDX*0x4 + 0x455]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "SAR EDX,0x8",
            "MOV AL,byte ptr [EAX + 0x408afc]",
            "XOR AL,DL",
            "MOV byte ptr [ECX],AL",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "ADD EAX,EBX",
            "INC ECX",
            "CDQ",
            "IDIV EDI",
            "MOV EAX,dword ptr [ESI + EDX*0x4 + 0x454]",
            "AND EAX,0xff",
            "MOV AL,byte ptr [EAX + 0x408afc]",
            "XOR AL,byte ptr [EBP + 0x8]",
            "MOV byte ptr [ECX],AL",
            "INC ECX",
            "INC dword ptr [EBP + -0x4]",
            "INC EBX",
            "CMP dword ptr [EBP + -0x4],EDI",
            "JL 0x00003980",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "00003797",
            "end": "00003a27"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000387d",
                    "00003888",
                    "0000393c"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003805",
                    "0000388b",
                    "00003970"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000038c8",
                    "000038d5",
                    "00003975",
                    "000039b2"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000382b",
                    "00003851",
                    "00003854",
                    "0000388e",
                    "0000390d",
                    "00003910",
                    "00003955",
                    "00003986",
                    "00003a14",
                    "00003a18"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003814",
                    "00003891",
                    "00003964"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000038a7",
                    "000038c3",
                    "0000397d",
                    "000039f3"
                ],
                "type": "undefined4"
            },
            "local_38": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000037ad",
                    "000037b6"
                ],
                "type": "undefined"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003828",
                    "00003860",
                    "0000386e",
                    "00003943",
                    "00003946"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003817",
                    "0000389c",
                    "00003978"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000038aa",
                    "0000391e"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003899",
                    "000038ad"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00003797",
        "original_name": "FUN_00003797",
        "predicted_name": "FUN_000031bc.",
        "prediction_full_response": "The predicted function name is FUN_000031bc.</s>"
    },
    "000075ad": {
        "decomp_code": "\nvoid FUN_000075ad(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  FUN_000074a4(param_1,param_2,3,param_3);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH dword ptr [ESP + 0xc]",
            "PUSH 0x3",
            "PUSH dword ptr [ESP + 0x10]",
            "PUSH dword ptr [ESP + 0x10]",
            "CALL 0x000074a4",
            "ADD ESP,0x10",
            "RET"
        ],
        "function_address": {
            "start": "000075ad",
            "end": "000075c3"
        },
        "variable_metadata": {},
        "func_name": "FUN_000075ad",
        "original_name": "FUN_000075ad",
        "predicted_name": "FUN_000074a4.",
        "prediction_full_response": "The predicted function name is FUN_000074a4.</s>"
    },
    "00001fe7": {
        "decomp_code": "\nundefined4 FUN_00001fe7(void)\n\n{\n  int *piVar1;\n  undefined1 *puVar2;\n  code *pcVar3;\n  int iVar4;\n  undefined4 *puVar5;\n  char *_Str2;\n  undefined1 local_210;\n  undefined4 local_20f;\n  undefined4 local_8;\n  \n  local_210 = uRam0040f910;\n  puVar5 = &local_20f;\n  for (iVar4 = 0x81; iVar4 != 0; iVar4 = iVar4 + -1) {\n    *puVar5 = 0;\n    puVar5 = puVar5 + 1;\n  }\n  *(undefined2 *)puVar5 = 0;\n  *(undefined1 *)((int)puVar5 + 2) = 0;\n  (*pcRam0040808c)(0,&local_210,0x208);\n  FUN_00001225(0x40f8ac);\n  piVar1 = (int *)(*pcRam0040816c)();\n  if (*piVar1 == 2) {\n    _Str2 = (char *)0x40f538;\n    piVar1 = (int *)(*pcRam00408168)();\n    iVar4 = strcmp(*(char **)(*piVar1 + 4),_Str2);\n    if ((iVar4 == 0) && (iVar4 = FUN_00001b5f(0), iVar4 != 0)) {\n      (*pcRam00408088)(&local_210,0x40f4d8,0);\n      iVar4 = (*pcRam00408068)(0x40f4d8);\n      if ((iVar4 != -1) && (iVar4 = FUN_00001f5d(), iVar4 != 0)) {\n        return 0;\n      }\n    }\n  }\n  pcVar3 = pcRam00408164;\n  iVar4 = (*pcRam00408164)(&local_210,0x5c);\n  if (iVar4 != 0) {\n    puVar2 = (undefined1 *)(*pcVar3)(&local_210,0x5c);\n    *puVar2 = 0;\n  }\n  (*pcRam004080d8)(&local_210);\n  FUN_000010fd(1);\n  FUN_00001dab(0,0x40f52c);\n  FUN_00001e9e();\n  FUN_00001064(0x40f520,0,0);\n  FUN_00001064(0x40f4fc,0,0);\n  iVar4 = FUN_0000170a();\n  if (iVar4 != 0) {\n    FUN_000012fd();\n    iVar4 = FUN_00001437(0,0,0);\n    if (iVar4 != 0) {\n      local_8 = 0;\n      iVar4 = FUN_000014a6(0x40f4f4,&local_8);\n      if (((iVar4 != 0) && (iVar4 = FUN_000021bd(iVar4,local_8), iVar4 != 0)) &&\n         (pcVar3 = (code *)FUN_00002924(iVar4,0x40f4e8), pcVar3 != (code *)0x0)) {\n        (*pcVar3)(0,0);\n      }\n    }\n    FUN_0000137a();\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x6e4",
            "MOV AL,[0x0040f910]",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV byte ptr [EBP + 0xfffffdf4],AL",
            "MOV ECX,0x81",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffdf5]",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "STOSB ES:EDI",
            "LEA EAX,[EBP + 0xfffffdf4]",
            "PUSH 0x208",
            "XOR EBX,EBX",
            "PUSH EAX",
            "PUSH EBX",
            "CALL dword ptr [0x0040808c]",
            "PUSH 0x40f8ac",
            "CALL 0x00001225",
            "POP ECX",
            "CALL dword ptr [0x0040816c]",
            "CMP dword ptr [EAX],0x2",
            "JNZ 0x0000208e",
            "PUSH 0x40f538",
            "CALL dword ptr [0x00408168]",
            "MOV EAX,dword ptr [EAX]",
            "PUSH dword ptr [EAX + 0x4]",
            "CALL 0x00007740",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x0000208e",
            "PUSH EBX",
            "CALL 0x00001b5f",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000208e",
            "MOV ESI,0x40f4d8",
            "PUSH EBX",
            "LEA EAX,[EBP + 0xfffffdf4]",
            "PUSH ESI",
            "PUSH EAX",
            "CALL dword ptr [0x00408088]",
            "PUSH ESI",
            "CALL dword ptr [0x00408068]",
            "CMP EAX,-0x1",
            "JZ 0x0000208e",
            "CALL 0x00001f5d",
            "TEST EAX,EAX",
            "JNZ 0x00002165",
            "MOV ESI,dword ptr [0x00408164]",
            "LEA EAX,[EBP + 0xfffffdf4]",
            "PUSH 0x5c",
            "PUSH EAX",
            "CALL ESI",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000020b4",
            "LEA EAX,[EBP + 0xfffffdf4]",
            "PUSH 0x5c",
            "PUSH EAX",
            "CALL ESI",
            "POP ECX",
            "MOV byte ptr [EAX],BL",
            "POP ECX",
            "LEA EAX,[EBP + 0xfffffdf4]",
            "PUSH EAX",
            "CALL dword ptr [0x004080d8]",
            "PUSH 0x1",
            "CALL 0x000010fd",
            "MOV dword ptr [ESP],0x40f52c",
            "PUSH EBX",
            "CALL 0x00001dab",
            "CALL 0x00001e9e",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH 0x40f520",
            "CALL 0x00001064",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH 0x40f4fc",
            "CALL 0x00001064",
            "ADD ESP,0x20",
            "CALL 0x0000170a",
            "TEST EAX,EAX",
            "JZ 0x00002165",
            "LEA ECX,[EBP + 0xfffff91c]",
            "CALL 0x000012fd",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH EBX",
            "LEA ECX,[EBP + 0xfffff91c]",
            "CALL 0x00001437",
            "TEST EAX,EAX",
            "JZ 0x0000215a",
            "LEA EAX,[EBP + -0x4]",
            "LEA ECX,[EBP + 0xfffff91c]",
            "PUSH EAX",
            "PUSH 0x40f4f4",
            "MOV dword ptr [EBP + -0x4],EBX",
            "CALL 0x000014a6",
            "CMP EAX,EBX",
            "JZ 0x0000215a",
            "PUSH dword ptr [EBP + -0x4]",
            "PUSH EAX",
            "CALL 0x000021bd",
            "POP ECX",
            "CMP EAX,EBX",
            "POP ECX",
            "JZ 0x0000215a",
            "PUSH 0x40f4e8",
            "PUSH EAX",
            "CALL 0x00002924",
            "POP ECX",
            "CMP EAX,EBX",
            "POP ECX",
            "JZ 0x0000215a",
            "PUSH EBX",
            "PUSH EBX",
            "CALL EAX",
            "LEA ECX,[EBP + 0xfffff91c]",
            "CALL 0x0000137a",
            "POP EDI",
            "POP ESI",
            "XOR EAX,EAX",
            "POP EBX",
            "LEAVE",
            "RET 0x10"
        ],
        "function_address": {
            "start": "00001fe7",
            "end": "0000216d"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000211b",
                    "0000212a",
                    "00002136"
                ],
                "type": "undefined4"
            },
            "local_210": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001ff8",
                    "00002010",
                    "00002067",
                    "00002094",
                    "000020a5",
                    "000020b4"
                ],
                "type": "undefined1"
            },
            "local_20f": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002005"
                ],
                "type": "undefined"
            },
            "local_6e8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000020fe",
                    "0000210c",
                    "0000211e",
                    "0000215a"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00001fe7",
        "original_name": "FUN_00001fe7",
        "predicted_name": "FUN_00001064.]",
        "prediction_full_response": "[/INST: The predicted function name is FUN_00001064.]</s>"
    },
    "000027df": {
        "decomp_code": "\nint FUN_000027df(uint *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  int *piVar6;\n  uint *puVar7;\n  undefined4 uVar8;\n  int local_c;\n  \n  piVar2 = (int *)param_1;\n  iVar1 = ((int *)param_1)[1];\n  iVar3 = 1;\n  local_c = 1;\n  if (*(int *)(*param_1 + 0x84) != 0) {\n    piVar6 = (int *)(*(int *)(*param_1 + 0x80) + iVar1);\n    iVar3 = (*pcRam004080b0)(piVar6,0x14);\n    while( true ) {\n      if (iVar3 != 0) {\n        return local_c;\n      }\n      if (piVar6[3] == 0) {\n        return local_c;\n      }\n      iVar3 = (*(code *)piVar2[9])(piVar6[3] + iVar1,piVar2[0xc]);\n      if (iVar3 == 0) break;\n      iVar4 = (*pcRam00408108)(piVar2[2],piVar2[3] * 4 + 4);\n      if (iVar4 == 0) {\n        (*(code *)piVar2[0xb])(iVar3,piVar2[0xc]);\n        uVar8 = 0xe;\n        goto LAB_000028fd;\n      }\n      piVar2[2] = iVar4;\n      *(int *)(iVar4 + piVar2[3] * 4) = iVar3;\n      piVar2[3] = piVar2[3] + 1;\n      if (*piVar6 == 0) {\n        puVar7 = (uint *)(iVar1 + piVar6[4]);\n        param_1 = puVar7;\n      }\n      else {\n        puVar7 = (uint *)(piVar6[4] + iVar1);\n        param_1 = (uint *)(*piVar6 + iVar1);\n      }\n      for (; uVar5 = *param_1, uVar5 != 0; param_1 = param_1 + 1) {\n        if ((uVar5 & 0x80000000) == 0) {\n          iVar4 = piVar2[0xc];\n          uVar5 = uVar5 + iVar1 + 2;\n        }\n        else {\n          iVar4 = piVar2[0xc];\n          uVar5 = uVar5 & 0xffff;\n        }\n        uVar5 = (*(code *)piVar2[10])(iVar3,uVar5,iVar4);\n        *puVar7 = uVar5;\n        if (uVar5 == 0) {\n          local_c = 0;\n          break;\n        }\n        puVar7 = puVar7 + 1;\n      }\n      if (local_c == 0) {\n        (*(code *)piVar2[0xb])(iVar3,piVar2[0xc]);\n        (*pcRam004080a8)(0x7f);\n        return 0;\n      }\n      piVar6 = piVar6 + 5;\n      iVar3 = (*pcRam004080b0)(piVar6,0x14);\n    }\n    uVar8 = 0x7e;\nLAB_000028fd:\n    (*pcRam004080a8)(uVar8);\n    local_c = 0;\n    iVar3 = local_c;\n  }\n  return iVar3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xc",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "PUSH 0x1",
            "MOV EAX,dword ptr [ESI]",
            "MOV EDI,dword ptr [ESI + 0x4]",
            "ADD EAX,0x80",
            "POP ECX",
            "MOV dword ptr [EBP + -0xc],EDI",
            "MOV dword ptr [EBP + -0x8],ECX",
            "CMP dword ptr [EAX + 0x4],0x0",
            "JNZ 0x0000280a",
            "MOV EAX,ECX",
            "JMP 0x00002920",
            "PUSH EBX",
            "MOV EBX,dword ptr [EAX]",
            "ADD EBX,EDI",
            "PUSH 0x14",
            "PUSH EBX",
            "CALL dword ptr [0x004080b0]",
            "TEST EAX,EAX",
            "JNZ 0x0000291c",
            "JMP 0x00002825",
            "MOV EDI,dword ptr [EBP + -0xc]",
            "MOV EAX,dword ptr [EBX + 0xc]",
            "TEST EAX,EAX",
            "JZ 0x0000291c",
            "PUSH dword ptr [ESI + 0x30]",
            "ADD EAX,EDI",
            "PUSH EAX",
            "CALL dword ptr [ESI + 0x24]",
            "POP ECX",
            "MOV dword ptr [EBP + -0x4],EAX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000028ec",
            "MOV EAX,dword ptr [ESI + 0xc]",
            "LEA EAX,[EAX*0x4 + 0x4]",
            "PUSH EAX",
            "PUSH dword ptr [ESI + 0x8]",
            "CALL dword ptr [0x00408108]",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000028f0",
            "MOV ECX,dword ptr [ESI + 0xc]",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [ESI + 0x8],EAX",
            "MOV dword ptr [EAX + ECX*0x4],EDX",
            "INC dword ptr [ESI + 0xc]",
            "MOV EAX,dword ptr [EBX]",
            "TEST EAX,EAX",
            "JZ 0x00002886",
            "ADD EAX,EDI",
            "MOV EDI,dword ptr [EBX + 0x10]",
            "ADD EDI,dword ptr [EBP + -0xc]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JMP 0x0000288e",
            "MOV EAX,dword ptr [EBX + 0x10]",
            "ADD EDI,EAX",
            "MOV dword ptr [EBP + 0x8],EDI",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV EAX,dword ptr [EAX]",
            "TEST EAX,EAX",
            "JZ 0x000028d0",
            "TEST EAX,0x80000000",
            "JZ 0x000028a8",
            "PUSH dword ptr [ESI + 0x30]",
            "AND EAX,0xffff",
            "JMP 0x000028b3",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "PUSH dword ptr [ESI + 0x30]",
            "ADD EAX,ECX",
            "ADD EAX,0x2",
            "PUSH EAX",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [ESI + 0x28]",
            "ADD ESP,0xc",
            "MOV dword ptr [EDI],EAX",
            "TEST EAX,EAX",
            "JZ 0x000028cc",
            "ADD dword ptr [EBP + 0x8],0x4",
            "ADD EDI,0x4",
            "JMP 0x0000288e",
            "AND dword ptr [EBP + -0x8],0x0",
            "CMP dword ptr [EBP + -0x8],0x0",
            "JZ 0x00002909",
            "ADD EBX,0x14",
            "PUSH 0x14",
            "PUSH EBX",
            "CALL dword ptr [0x004080b0]",
            "TEST EAX,EAX",
            "JZ 0x00002822",
            "JMP 0x0000291c",
            "PUSH 0x7e",
            "JMP 0x000028fd",
            "PUSH dword ptr [ESI + 0x30]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [ESI + 0x2c]",
            "POP ECX",
            "POP ECX",
            "PUSH 0xe",
            "CALL dword ptr [0x004080a8]",
            "AND dword ptr [EBP + -0x8],0x0",
            "JMP 0x0000291c",
            "PUSH dword ptr [ESI + 0x30]",
            "PUSH dword ptr [EBP + -0x4]",
            "CALL dword ptr [ESI + 0x2c]",
            "POP ECX",
            "POP ECX",
            "PUSH 0x7f",
            "CALL dword ptr [0x004080a8]",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "POP EBX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000027df",
            "end": "00002923"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000027fa",
                    "000028cc",
                    "000028d0",
                    "00002903",
                    "0000291c"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000283a",
                    "00002867",
                    "000028b4",
                    "000028f3",
                    "0000290c"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000027f7",
                    "00002822",
                    "0000287e",
                    "000028a8"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000027df",
        "original_name": "FUN_000027df",
        "predicted_name": "\\x0a",
        "prediction_full_response": "[/INST: The predicted function name is \\x0a</s>"
    },
    "00005c9f": {
        "decomp_code": "\nundefined4 FUN_00005c9f(void *param_1)\n\n{\n  if (param_1 == (void *)0x0) {\n    return 0xffffffff;\n  }\n  if (*(char *)((int)param_1 + 0x10) != '\\0') {\n    (*pcRam004080f0)(*(undefined4 *)((int)param_1 + 4));\n  }\n  operator_delete(param_1);\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "TEST ESI,ESI",
            "JNZ 0x00005cad",
            "OR EAX,0xffffffff",
            "POP ESI",
            "RET",
            "CMP byte ptr [ESI + 0x10],0x0",
            "JZ 0x00005cbc",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL dword ptr [0x004080f0]",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "XOR EAX,EAX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00005c9f",
            "end": "00005cc6"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005c9f",
        "original_name": "FUN_00005c9f",
        "predicted_name": "operator_delete",
        "prediction_full_response": "The predicted function name is operator_delete</s>"
    },
    "000019e1": {
        "decomp_code": "\nundefined4 __thiscall\nFUN_000019e1(int param_1,void *param_2,size_t param_3,void *param_4,size_t *param_5)\n\n{\n  int iVar1;\n  \n  if (*(int *)(param_1 + 8) != 0) {\n    (*pcRam00408050)(param_1 + 0x10);\n    iVar1 = (*pcRam0040f8a4)(*(undefined4 *)(param_1 + 8),0,1,0,param_2,&param_3);\n    if (iVar1 != 0) {\n      (*pcRam0040804c)(param_1 + 0x10);\n      memcpy(param_4,param_2,param_3);\n      *param_5 = param_3;\n      return 1;\n    }\n    (*pcRam0040804c)();\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "CMP dword ptr [ESI + 0x8],0x0",
            "JZ 0x00001a19",
            "LEA EDI,[ESI + 0x10]",
            "PUSH EDI",
            "CALL dword ptr [0x00408050]",
            "LEA EAX,[EBP + 0xc]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH 0x0",
            "PUSH 0x1",
            "PUSH 0x0",
            "PUSH dword ptr [ESI + 0x8]",
            "CALL dword ptr [0x0040f8a4]",
            "TEST EAX,EAX",
            "PUSH EDI",
            "JNZ 0x00001a1d",
            "CALL dword ptr [0x0040804c]",
            "XOR EAX,EAX",
            "JMP 0x00001a3f",
            "CALL dword ptr [0x0040804c]",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH dword ptr [EBP + 0x10]",
            "CALL 0x00007706",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "ADD ESP,0xc",
            "MOV dword ptr [EAX],ECX",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBP",
            "RET 0x10"
        ],
        "function_address": {
            "start": "000019e1",
            "end": "00001a44"
        },
        "variable_metadata": {},
        "func_name": "FUN_000019e1",
        "original_name": "FUN_000019e1",
        "predicted_name": "FUN_000019e1.",
        "prediction_full_response": "The predicted function name is FUN_000019e1.</s>"
    },
    "00002470": {
        "decomp_code": "\nundefined4 FUN_00002470(int param_1,undefined4 param_2,int param_3,int *param_4)\n\n{\n  size_t *psVar1;\n  int iVar2;\n  size_t sVar3;\n  int iVar4;\n  size_t *psVar5;\n  int local_8;\n  \n  local_8 = 0;\n  iVar2 = param_4[1];\n  iVar4 = *param_4;\n  psVar1 = (size_t *)((uint)*(ushort *)(iVar4 + 0x14) + iVar4);\n  if (*(short *)(iVar4 + 6) != 0) {\n    do {\n      psVar5 = psVar1 + 10;\n      if (*psVar5 == 0) {\n        sVar3 = *(size_t *)(param_3 + 0x38);\n        if (0 < (int)sVar3) {\n          iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],sVar3,0x1000,4,param_4[0xc]);\n          if (iVar4 == 0) {\n            return 0;\n          }\n          psVar1[8] = iVar2 + psVar1[9];\n          memset((void *)(iVar2 + psVar1[9]),0,sVar3);\n        }\n      }\n      else {\n        iVar4 = FUN_00002457(param_2,psVar1[0xb] + *psVar5);\n        if ((iVar4 == 0) ||\n           (iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],*psVar5,0x1000,4,param_4[0xc]),\n           iVar4 == 0)) {\n          return 0;\n        }\n        sVar3 = psVar1[9];\n        memcpy((void *)(iVar2 + sVar3),(void *)(psVar1[0xb] + param_1),*psVar5);\n        psVar1[8] = iVar2 + sVar3;\n      }\n      local_8 = local_8 + 1;\n      psVar1 = psVar5;\n    } while (local_8 < (int)(uint)*(ushort *)(*param_4 + 6));\n  }\n  return 1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x14]",
            "AND dword ptr [EBP + -0x4],0x0",
            "MOV EAX,dword ptr [EDI + 0x4]",
            "MOV dword ptr [EBP + 0x14],EAX",
            "MOV EAX,dword ptr [EDI]",
            "MOVZX ECX,word ptr [EAX + 0x14]",
            "CMP word ptr [EAX + 0x6],0x0",
            "LEA ESI,[ECX + EAX*0x1 + 0x18]",
            "JBE 0x0000253f",
            "ADD ESI,0x10",
            "MOV EAX,dword ptr [ESI]",
            "TEST EAX,EAX",
            "JNZ 0x000024df",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "MOV EBX,dword ptr [EAX + 0x38]",
            "TEST EBX,EBX",
            "JLE 0x0000252a",
            "PUSH dword ptr [EDI + 0x30]",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "ADD EAX,dword ptr [ESI + -0x4]",
            "PUSH 0x4",
            "PUSH 0x1000",
            "PUSH EBX",
            "PUSH EAX",
            "CALL dword ptr [EDI + 0x1c]",
            "ADD ESP,0x14",
            "TEST EAX,EAX",
            "JZ 0x00002547",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "PUSH EBX",
            "ADD EAX,dword ptr [ESI + -0x4]",
            "PUSH 0x0",
            "PUSH EAX",
            "MOV dword ptr [ESI + -0x8],EAX",
            "CALL 0x000076ae",
            "ADD ESP,0xc",
            "JMP 0x0000252a",
            "MOV ECX,dword ptr [ESI + 0x4]",
            "ADD ECX,EAX",
            "PUSH ECX",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00002457",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00002547",
            "PUSH dword ptr [EDI + 0x30]",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "MOV EAX,EBX",
            "ADD EAX,dword ptr [ESI + -0x4]",
            "PUSH 0x4",
            "PUSH 0x1000",
            "PUSH dword ptr [ESI]",
            "PUSH EAX",
            "CALL dword ptr [EDI + 0x1c]",
            "ADD ESP,0x14",
            "TEST EAX,EAX",
            "JZ 0x00002547",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "PUSH dword ptr [ESI]",
            "ADD EAX,dword ptr [EBP + 0x8]",
            "ADD EBX,dword ptr [ESI + -0x4]",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x00007706",
            "ADD ESP,0xc",
            "MOV dword ptr [ESI + -0x8],EBX",
            "MOV EAX,dword ptr [EDI]",
            "INC dword ptr [EBP + -0x4]",
            "ADD ESI,0x28",
            "MOVZX EAX,word ptr [EAX + 0x6]",
            "CMP dword ptr [EBP + -0x4],EAX",
            "JL 0x0000249c",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET",
            "XOR EAX,EAX",
            "JMP 0x00002542"
        ],
        "function_address": {
            "start": "00002470",
            "end": "0000254a"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000247a",
                    "0000252c",
                    "00002536"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00002470",
        "original_name": "FUN_00002470",
        "predicted_name": "FUN_00002457.",
        "prediction_full_response": "The predicted function name is FUN_00002457.</s>"
    },
    "00002a6f": {
        "decomp_code": "\nvoid __fastcall FUN_00002a6f(undefined4 *param_1)\n\n{\n  *param_1 = 0x40bc7c;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV dword ptr [ECX],0x40bc7c",
            "RET"
        ],
        "function_address": {
            "start": "00002a6f",
            "end": "00002a75"
        },
        "variable_metadata": {},
        "func_name": "FUN_00002a6f",
        "original_name": "FUN_00002a6f",
        "predicted_name": "set_g_debug_level",
        "prediction_full_response": "The predicted function name is set_g_debug_level</s>"
    },
    "00004be5": {
        "decomp_code": "\nundefined4 FUN_00004be5(int param_1,int param_2)\n\n{\n  FUN_000042c0(param_1,param_2,0);\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x28));\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x24));\n  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0xc]",
            "PUSH EDI",
            "MOV EDI,dword ptr [ESP + 0xc]",
            "PUSH 0x0",
            "PUSH ESI",
            "PUSH EDI",
            "CALL 0x000042c0",
            "PUSH dword ptr [EDI + 0x28]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "PUSH dword ptr [EDI + 0x24]",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x28]",
            "CALL dword ptr [ESI + 0x24]",
            "ADD ESP,0x24",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00004be5",
            "end": "00004c18"
        },
        "variable_metadata": {},
        "func_name": "FUN_00004be5",
        "original_name": "FUN_00004be5",
        "predicted_name": "FUN_000042c0.",
        "prediction_full_response": "The predicted function name is FUN_000042c0.</s>"
    },
    "000012fd": {
        "decomp_code": "\nundefined4 * FUN_000012fd(void)\n\n{\n  undefined4 *extraout_ECX;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;\n  FUN_000017dd();\n  *(undefined4 *)(unaff_EBP + -4) = 0;\n  FUN_000017dd();\n  *(undefined1 *)(unaff_EBP + -4) = 1;\n  FUN_00002a46();\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  extraout_ECX[0x132] = 0;\n  extraout_ECX[0x133] = 0;\n  extraout_ECX[0x134] = 0;\n  extraout_ECX[0x135] = 0;\n  *extraout_ECX = 0x4081d8;\n  return extraout_ECX;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,0x407966",
            "CALL 0x000076c8",
            "PUSH ECX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "MOV dword ptr [EBP + -0x10],ESI",
            "LEA ECX,[ESI + 0x4]",
            "CALL 0x000017dd",
            "XOR EDI,EDI",
            "LEA ECX,[ESI + 0x2c]",
            "MOV dword ptr [EBP + -0x4],EDI",
            "CALL 0x000017dd",
            "LEA ECX,[ESI + 0x54]",
            "MOV byte ptr [EBP + -0x4],0x1",
            "CALL 0x00002a46",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "MOV dword ptr [ESI + 0x4c8],EDI",
            "MOV dword ptr [ESI + 0x4cc],EDI",
            "MOV dword ptr [ESI + 0x4d0],EDI",
            "MOV dword ptr [ESI + 0x4d4],EDI",
            "MOV dword ptr [ESI],0x4081d8",
            "MOV EAX,ESI",
            "POP EDI",
            "POP ESI",
            "MOV dword ptr FS:[0x0],ECX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000012fd",
            "end": "0000135d"
        },
        "variable_metadata": {},
        "func_name": "FUN_000012fd",
        "original_name": "FUN_000012fd",
        "predicted_name": "FUN_00002a46.",
        "prediction_full_response": "The predicted function name is FUN_00002a46.</s>"
    },
    "000076e8": {
        "decomp_code": "\nvoid __cdecl operator_delete(void *param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000076e8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408140)();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408140]"
        ],
        "function_address": {
            "start": "000076e8",
            "end": "000076ed"
        },
        "variable_metadata": {
            "param_1": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            }
        },
        "func_name": "operator_delete",
        "original_name": "operator_delete",
        "predicted_name": "_mu_thread_start_routine",
        "prediction_full_response": "The predicted function name is _mu_thread_start_routine</s>"
    },
    "000074a4": {
        "decomp_code": "\nundefined4 * FUN_000074a4(void)\n\n{\n  void *pvVar1;\n  undefined4 *puVar2;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  pvVar1 = operator_new(0x244);\n  *(void **)(unaff_EBP + -0x10) = pvVar1;\n  *(undefined4 *)(unaff_EBP + -4) = 0;\n  if (pvVar1 == (void *)0x0) {\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    pvVar1 = (void *)FUN_00007527(*(undefined4 *)(unaff_EBP + 0x14));\n  }\n  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;\n  iRam0040f938 = FUN_00006b8e(*(undefined4 *)(unaff_EBP + 8),*(undefined4 *)(unaff_EBP + 0xc),\n                              *(undefined4 *)(unaff_EBP + 0x10));\n  if (iRam0040f938 == 0) {\n    puVar2 = (undefined4 *)operator_new(8);\n    *puVar2 = 1;\n    puVar2[1] = pvVar1;\n  }\n  else {\n    if (pvVar1 != (void *)0x0) {\n      FUN_00007572();\n      operator_delete(pvVar1);\n    }\n    puVar2 = (undefined4 *)0x0;\n  }\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  return puVar2;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,0x4079a6",
            "CALL 0x000076c8",
            "PUSH ECX",
            "PUSH ESI",
            "PUSH 0x244",
            "CALL 0x00007700",
            "POP ECX",
            "MOV ECX,EAX",
            "MOV dword ptr [EBP + -0x10],ECX",
            "AND dword ptr [EBP + -0x4],0x0",
            "TEST ECX,ECX",
            "JZ 0x000074d4",
            "PUSH dword ptr [EBP + 0x14]",
            "CALL 0x00007527",
            "MOV ESI,EAX",
            "JMP 0x000074d6",
            "XOR ESI,ESI",
            "PUSH dword ptr [EBP + 0x10]",
            "OR dword ptr [EBP + -0x4],0xffffffff",
            "MOV ECX,ESI",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00006b8e",
            "TEST EAX,EAX",
            "MOV [0x0040f938],EAX",
            "JZ 0x00007509",
            "TEST ESI,ESI",
            "JZ 0x00007505",
            "MOV ECX,ESI",
            "CALL 0x00007572",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "XOR EAX,EAX",
            "JMP 0x0000751a",
            "PUSH 0x8",
            "CALL 0x00007700",
            "POP ECX",
            "MOV dword ptr [EAX],0x1",
            "MOV dword ptr [EAX + 0x4],ESI",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "POP ESI",
            "MOV dword ptr FS:[0x0],ECX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000074a4",
            "end": "00007526"
        },
        "variable_metadata": {},
        "func_name": "FUN_000074a4",
        "original_name": "FUN_000074a4",
        "predicted_name": "FUN_00007572.",
        "prediction_full_response": "The predicted function name is FUN_00007572.</s>"
    },
    "000055a3": {
        "decomp_code": "\nbyte FUN_000055a3(undefined4 param_1,byte param_2)\n\n{\n  byte bVar1;\n  \n  bVar1 = FUN_00005588(param_1);\n  FUN_00005535(param_1,param_2 ^ bVar1);\n  return param_2 ^ bVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005588",
            "XOR byte ptr [EBP + 0xc],AL",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005535",
            "MOV AL,byte ptr [EBP + 0xc]",
            "ADD ESP,0xc",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "000055a3",
            "end": "000055c3"
        },
        "variable_metadata": {},
        "func_name": "FUN_000055a3",
        "original_name": "FUN_000055a3",
        "predicted_name": "FUN_00005535",
        "prediction_full_response": "The predicted function name is FUN_00005535</s>"
    },
    "00002758": {
        "decomp_code": "\nbool FUN_00002758(int *param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  int *piVar4;\n  ushort *puVar5;\n  bool bVar6;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0xa4) == 0) {\n    bVar6 = param_2 == 0;\n  }\n  else {\n    piVar3 = (int *)(*(int *)(*param_1 + 0xa0) + iVar1);\n    iVar2 = *piVar3;\n    while (iVar2 != 0) {\n      param_1 = (int *)0x0;\n      puVar5 = (ushort *)(piVar3 + 2);\n      if ((piVar3[1] - 8U & 0xfffffffe) != 0) {\n        do {\n          if ((*puVar5 & 0xf000) == 0x3000) {\n            piVar4 = (int *)((*puVar5 & 0xfff) + iVar2 + iVar1);\n            *piVar4 = *piVar4 + param_2;\n          }\n          param_1 = (int *)((int)param_1 + 1);\n          puVar5 = puVar5 + 1;\n        } while (param_1 < piVar3[1] - 8U >> 1);\n      }\n      piVar3 = (int *)((int)piVar3 + piVar3[1]);\n      iVar2 = *piVar3;\n    }\n    bVar6 = true;\n  }\n  return bVar6;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH ESI",
            "MOV ESI,dword ptr [EAX + 0x4]",
            "MOV EAX,dword ptr [EAX]",
            "ADD EAX,0xa0",
            "CMP dword ptr [EAX + 0x4],0x0",
            "JNZ 0x00002779",
            "XOR EAX,EAX",
            "CMP dword ptr [EBP + 0xc],EAX",
            "SETZ AL",
            "JMP 0x000027dc",
            "MOV EAX,dword ptr [EAX]",
            "ADD EAX,ESI",
            "MOV ECX,dword ptr [EAX]",
            "TEST ECX,ECX",
            "JBE 0x000027d9",
            "PUSH EBX",
            "PUSH EDI",
            "AND dword ptr [EBP + 0x8],0x0",
            "LEA EDI,[ECX + ESI*0x1]",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "LEA EDX,[EAX + 0x8]",
            "SUB ECX,0x8",
            "TEST ECX,0xfffffffe",
            "JBE 0x000027ce",
            "MOVZX ECX,word ptr [EDX]",
            "MOV EBX,ECX",
            "AND BX,0xf000",
            "CMP EBX,0x3000",
            "JNZ 0x000027bc",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "AND ECX,0xfff",
            "ADD ECX,EDI",
            "ADD dword ptr [ECX],EBX",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "INC dword ptr [EBP + 0x8]",
            "SUB ECX,0x8",
            "INC EDX",
            "SHR ECX,0x1",
            "INC EDX",
            "CMP dword ptr [EBP + 0x8],ECX",
            "JC 0x0000279d",
            "ADD EAX,dword ptr [EAX + 0x4]",
            "MOV ECX,dword ptr [EAX]",
            "TEST ECX,ECX",
            "JA 0x00002785",
            "POP EDI",
            "POP EBX",
            "PUSH 0x1",
            "POP EAX",
            "POP ESI",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00002758",
            "end": "000027de"
        },
        "variable_metadata": {},
        "func_name": "FUN_00002758",
        "original_name": "FUN_00002758",
        "predicted_name": "\"update_counts\".",
        "prediction_full_response": "The predicted function name is \"update_counts\".</s>"
    },
    "000064e2": {
        "decomp_code": "\nint FUN_000064e2(int param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 == 0) {\n    iVar1 = -0x66;\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(param_1 + 0x24);\n    *(undefined4 *)(param_1 + 0x10) = 0;\n    iVar1 = FUN_000061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);\n    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);\n  }\n  return iVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "PUSH EDI",
            "XOR EDI,EDI",
            "CMP ESI,EDI",
            "JNZ 0x000064f3",
            "PUSH -0x66",
            "POP EAX",
            "JMP 0x0000651d",
            "MOV EAX,dword ptr [ESI + 0x24]",
            "PUSH EDI",
            "PUSH EDI",
            "PUSH EDI",
            "MOV dword ptr [ESI + 0x14],EAX",
            "PUSH EDI",
            "PUSH EDI",
            "LEA EAX,[ESI + 0x78]",
            "PUSH EDI",
            "PUSH EAX",
            "LEA EAX,[ESI + 0x28]",
            "MOV dword ptr [ESI + 0x10],EDI",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x000061e0",
            "ADD ESP,0x24",
            "XOR ECX,ECX",
            "CMP EAX,EDI",
            "SETZ CL",
            "MOV dword ptr [ESI + 0x18],ECX",
            "POP EDI",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "000064e2",
            "end": "0000651f"
        },
        "variable_metadata": {},
        "func_name": "FUN_000064e2",
        "original_name": "FUN_000064e2",
        "predicted_name": "FUN_00006200.",
        "prediction_full_response": "The predicted function name is FUN_00006200.</s>"
    },
    "0000747b": {
        "decomp_code": "\nundefined4 __fastcall FUN_0000747b(int *param_1)\n\n{\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  param_1[1] = -1;\n  if (*param_1 != 0) {\n    FUN_00006162(*param_1);\n  }\n  *param_1 = 0;\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "CMP dword ptr [ESI + 0x4],-0x1",
            "JZ 0x0000748c",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006a97",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "OR dword ptr [ESI + 0x4],0xffffffff",
            "TEST EAX,EAX",
            "JZ 0x0000749d",
            "PUSH EAX",
            "CALL 0x00006162",
            "POP ECX",
            "AND dword ptr [ESI],0x0",
            "XOR EAX,EAX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "0000747b",
            "end": "000074a3"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000747b",
        "original_name": "FUN_0000747b",
        "predicted_name": "FUN_00006162.",
        "prediction_full_response": "The predicted function name is FUN_00006162.</s>"
    },
    "0000799c": {
        "decomp_code": "\nvoid Unwind_0040799c(void)\n\n{\n  int unaff_EBP;\n  \n  operator_delete(*(void **)(unaff_EBP + -0x10));\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH dword ptr [EBP + -0x10]",
            "CALL 0x000076e8",
            "POP ECX",
            "RET"
        ],
        "function_address": {
            "start": "0000799c",
            "end": "000079a5"
        },
        "variable_metadata": {},
        "func_name": "Unwind@0040799c",
        "original_name": "Unwind@0040799c",
        "predicted_name": "operator_delete_ptr",
        "prediction_full_response": "The predicted function name is operator_delete_ptr</s>"
    },
    "00001e9e": {
        "decomp_code": "\nvoid FUN_00001e9e(void)\n\n{\n  int iVar1;\n  undefined1 local_31c [178];\n  char local_26a [602];\n  undefined4 local_10 [3];\n  \n  local_10[0] = 0x40f488;\n  local_10[1] = 0x40f464;\n  local_10[2] = 0x40f440;\n  iVar1 = FUN_00001000(local_31c,1);\n  if (iVar1 != 0) {\n    iVar1 = (*pcRam00408120)();\n    strcpy(local_26a,(char *)local_10[iVar1 % 3]);\n    FUN_00001000(local_31c,0);\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x318",
            "LEA EAX,[EBP + 0xfffffce8]",
            "PUSH 0x1",
            "PUSH EAX",
            "MOV dword ptr [EBP + -0xc],0x40f488",
            "MOV dword ptr [EBP + -0x8],0x40f464",
            "MOV dword ptr [EBP + -0x4],0x40f440",
            "CALL 0x00001000",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00001efd",
            "CALL dword ptr [0x00408120]",
            "PUSH 0x3",
            "CDQ",
            "POP ECX",
            "IDIV ECX",
            "LEA EAX,[EBP + 0xfffffd9a]",
            "PUSH dword ptr [EBP + EDX*0x4 + -0xc]",
            "PUSH EAX",
            "CALL 0x000076a8",
            "LEA EAX,[EBP + 0xfffffce8]",
            "PUSH 0x0",
            "PUSH EAX",
            "CALL 0x00001000",
            "ADD ESP,0x10",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001e9e",
            "end": "00001efe"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001eb7"
                ],
                "type": "undefined4"
            },
            "local_26a": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001edc"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001ebe"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001eb0"
                ],
                "type": "undefined4"
            },
            "local_31c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001ea7",
                    "00001eec"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00001e9e",
        "original_name": "FUN_00001e9e",
        "predicted_name": "get_random_string.",
        "prediction_full_response": "The predicted function name is get_random_string.</s>"
    },
    "00005588": {
        "decomp_code": "\nuint FUN_00005588(int param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)(param_1 + 8) & 0xfffd | 2;\n  return (uVar1 ^ 1) * uVar1 >> 8 & 0xff;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "MOV EAX,dword ptr [EAX + 0x8]",
            "AND EAX,0xfffd",
            "OR AL,0x2",
            "MOV ECX,EAX",
            "XOR ECX,0x1",
            "IMUL ECX,EAX",
            "XOR EAX,EAX",
            "MOV AL,CH",
            "RET"
        ],
        "function_address": {
            "start": "00005588",
            "end": "000055a2"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005588",
        "original_name": "FUN_00005588",
        "predicted_name": "get_packet_type",
        "prediction_full_response": "The predicted function name is get_packet_type</s>"
    },
    "00007527": {
        "decomp_code": "\nundefined4 * __thiscall FUN_00007527(undefined4 *param_1,char *param_2)\n\n{\n  size_t sVar1;\n  char *_Dest;\n  \n  param_1[1] = 0xffffffff;\n  param_1[0x4d] = 0xffffffff;\n  *param_1 = 0;\n  param_1[0x4e] = 0;\n  param_1[0x4f] = 0;\n  if (param_2 != (char *)0x0) {\n    sVar1 = strlen(param_2);\n    _Dest = (char *)operator_new(sVar1 + 1);\n    param_1[0x4e] = _Dest;\n    strcpy(_Dest,param_2);\n  }\n  return param_1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,ECX",
            "PUSH EDI",
            "MOV EDI,dword ptr [ESP + 0xc]",
            "OR dword ptr [ESI + 0x4],0xffffffff",
            "OR dword ptr [ESI + 0x134],0xffffffff",
            "XOR EAX,EAX",
            "CMP EDI,EAX",
            "MOV dword ptr [ESI],EAX",
            "MOV dword ptr [ESI + 0x138],EAX",
            "MOV dword ptr [ESI + 0x13c],EAX",
            "JZ 0x0000756b",
            "PUSH EDI",
            "CALL 0x000076b4",
            "INC EAX",
            "PUSH EAX",
            "CALL 0x00007700",
            "PUSH EDI",
            "PUSH EAX",
            "MOV dword ptr [ESI + 0x138],EAX",
            "CALL 0x000076a8",
            "ADD ESP,0x10",
            "MOV EAX,ESI",
            "POP EDI",
            "POP ESI",
            "RET 0x4"
        ],
        "function_address": {
            "start": "00007527",
            "end": "00007571"
        },
        "variable_metadata": {},
        "func_name": "FUN_00007527",
        "original_name": "FUN_00007527",
        "predicted_name": "init_operator.",
        "prediction_full_response": "The predicted function name is init_operator.</s>"
    },
    "0000137a": {
        "decomp_code": "\nvoid FUN_0000137a(void)\n\n{\n  undefined4 *extraout_ECX;\n  int unaff_EBP;\n  \n  FUN_000076c8();\n  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;\n  *extraout_ECX = 0x4081d8;\n  *(undefined4 *)(unaff_EBP + -4) = 2;\n  FUN_000013ce();\n  *(undefined1 *)(unaff_EBP + -4) = 1;\n  FUN_00002a6f();\n  *(undefined1 *)(unaff_EBP + -4) = 0;\n  FUN_0000181b();\n  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;\n  FUN_0000181b();\n  uRamffdff000 = *(undefined4 *)(unaff_EBP + -0xc);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,0x407991",
            "CALL 0x000076c8",
            "PUSH ECX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "MOV dword ptr [EBP + -0x10],ESI",
            "MOV dword ptr [ESI],0x4081d8",
            "MOV dword ptr [EBP + -0x4],0x2",
            "CALL 0x000013ce",
            "LEA ECX,[ESI + 0x54]",
            "MOV byte ptr [EBP + -0x4],0x1",
            "CALL 0x00002a6f",
            "AND byte ptr [EBP + -0x4],0x0",
            "LEA ECX,[ESI + 0x2c]",
            "CALL 0x0000181b",
            "OR dword ptr [EBP + -0x4],0xffffffff",
            "LEA ECX,[ESI + 0x4]",
            "CALL 0x0000181b",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "POP ESI",
            "MOV dword ptr FS:[0x0],ECX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "0000137a",
            "end": "000013cd"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000137a",
        "original_name": "FUN_0000137a",
        "predicted_name": "FUN_000076c8.",
        "prediction_full_response": "The predicted function name is FUN_000076c8.</s>"
    },
    "00007924": {
        "decomp_code": "\nvoid __cdecl initterm(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00007924. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam004081b0)();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x004081b0]"
        ],
        "function_address": {
            "start": "00007924",
            "end": "00007929"
        },
        "variable_metadata": {},
        "func_name": "initterm",
        "original_name": "initterm",
        "predicted_name": "SYS_Ram004081b0",
        "prediction_full_response": "The predicted function name is SYS_Ram004081b0</s>"
    },
    "000076ee": {
        "decomp_code": "\nint __cdecl memcmp(void *_Buf1,void *_Buf2,size_t _Size)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000076ee. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = (*pcRam00408144)();\n  return iVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408144]"
        ],
        "function_address": {
            "start": "000076ee",
            "end": "000076f3"
        },
        "variable_metadata": {
            "_Size": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            },
            "_Buf2": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            },
            "_Buf1": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            }
        },
        "func_name": "memcmp",
        "original_name": "memcmp",
        "predicted_name": "__gmpn_cmp_nc.",
        "prediction_full_response": "The predicted function name is __gmpn_cmp_nc.</s>"
    },
    "00005e6b": {
        "decomp_code": "\nvoid FUN_00005e6b(int param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  \n  iVar3 = param_1;\n  iVar2 = FUN_00005def(param_1,&param_1);\n  iVar1 = param_1;\n  if (iVar2 == 0) {\n    iVar2 = FUN_00005def(iVar3,&param_1);\n  }\n  iVar4 = param_1 * 0x100;\n  if (iVar2 == 0) {\n    iVar2 = FUN_00005def(iVar3,&param_1);\n  }\n  iVar5 = param_1 * 0x10000;\n  if ((iVar2 == 0) && (iVar3 = FUN_00005def(iVar3,&param_1), iVar3 == 0)) {\n    *param_2 = param_1 * 0x1000000 + iVar1 + iVar4 + iVar5;\n    return;\n  }\n  *param_2 = 0;\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0x8]",
            "PUSH EDI",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005def",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00005e92",
            "LEA EAX,[EBP + 0x8]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005def",
            "POP ECX",
            "POP ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "SHL ECX,0x8",
            "ADD EDI,ECX",
            "TEST EAX,EAX",
            "JNZ 0x00005eaa",
            "LEA EAX,[EBP + 0x8]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005def",
            "POP ECX",
            "POP ECX",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "SHL ECX,0x10",
            "ADD EDI,ECX",
            "TEST EAX,EAX",
            "JNZ 0x00005ed5",
            "LEA EAX,[EBP + 0x8]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005def",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00005ed5",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOV EDX,dword ptr [EBP + 0xc]",
            "SHL ECX,0x18",
            "ADD ECX,EDI",
            "MOV dword ptr [EDX],ECX",
            "JMP 0x00005edb",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "AND dword ptr [ECX],0x0",
            "POP EDI",
            "POP ESI",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00005e6b",
            "end": "00005ede"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005e6b",
        "original_name": "FUN_00005e6b",
        "predicted_name": "FUN_00005def.",
        "prediction_full_response": "The predicted function name is FUN_00005def.</s>"
    },
    "00007136": {
        "decomp_code": "\nint __thiscall FUN_00007136(int *param_1,char *param_2,char *param_3,int param_4,int param_5)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char cVar3;\n  char *pcVar4;\n  void *pvVar5;\n  int iVar6;\n  int iVar7;\n  char *pcVar8;\n  char *pcVar9;\n  undefined1 local_33c [260];\n  undefined1 local_238 [264];\n  uint local_130;\n  undefined1 local_12c [8];\n  undefined1 local_124 [8];\n  undefined1 local_11c [16];\n  char local_10c [260];\n  undefined1 local_8 [4];\n  \n  iVar7 = param_5;\n  iVar6 = (int)param_2;\n  if (param_5 == 3) {\n    if (param_2 != (char *)param_1[1]) {\n      if (param_1[1] != -1) {\n        FUN_00006a97(*param_1);\n      }\n      iVar7 = *param_1;\n      param_1[1] = -1;\n      if (*(int *)(iVar7 + 4) <= iVar6) {\n        return 0x10000;\n      }\n      if (iVar6 < *(int *)(iVar7 + 0x10)) {\n        FUN_000064e2(iVar7);\n      }\n      while (*(int *)(*param_1 + 0x10) < iVar6) {\n        FUN_00006520(*param_1);\n      }\n      FUN_0000671d(*param_1,param_1[0x4e]);\n      param_1[1] = iVar6;\n    }\n    iVar6 = FUN_00006880(*param_1,param_3,param_4,(int)&param_2 + 3);\n    if (iVar6 < 1) {\n      FUN_00006a97(*param_1);\n      param_1[1] = -1;\n    }\n    if (param_2._3_1_ != '\\0') {\n      return 0;\n    }\n    if (iVar6 < 1) {\n      return ((iVar6 != -0x6a) - 1 & 0xfb001000) + 0x5000000;\n    }\n    return 0x600;\n  }\n  if ((param_5 != 2) && (param_5 != 1)) {\n    return 0x10000;\n  }\n  if (param_1[1] != -1) {\n    FUN_00006a97(*param_1);\n  }\n  iVar2 = (int)param_2;\n  iVar6 = *param_1;\n  param_1[1] = -1;\n  if (*(int *)(iVar6 + 4) <= (int)param_2) {\n    return 0x10000;\n  }\n  if ((int)param_2 < *(int *)(iVar6 + 0x10)) {\n    FUN_000064e2(iVar6);\n  }\n  while (*(int *)(*param_1 + 0x10) < iVar2) {\n    FUN_00006520(*param_1);\n  }\n  FUN_00006c40(iVar2,local_238);\n  pcVar4 = param_3;\n  if ((local_130 & 0x10) != 0) {\n    if (iVar7 == 1) {\n      return 0;\n    }\n    cVar3 = *param_3;\n    if (((cVar3 == '/') || (cVar3 == '\\\\')) || ((cVar3 != '\\0' && (param_3[1] == ':')))) {\n      param_1 = (int *)0x0;\n    }\n    else {\n      param_1 = param_1 + 0x50;\n    }\n    FUN_00007070(param_1,param_3);\n    return 0;\n  }\n  if (iVar7 == 1) goto LAB_00007331;\n  cVar3 = *param_3;\n  pcVar8 = param_3;\n  pcVar9 = param_3;\n  while (cVar3 != '\\0') {\n    if ((cVar3 == '/') || (cVar3 == '\\\\')) {\n      pcVar9 = pcVar8 + 1;\n    }\n    pcVar1 = pcVar8 + 1;\n    pcVar8 = pcVar8 + 1;\n    cVar3 = *pcVar1;\n  }\n  strcpy(local_10c,param_3);\n  if (pcVar9 == pcVar4) {\n    local_10c[0] = '\\0';\nLAB_000072e1:\n    (*pcRam004081d0)(local_33c,0x40f848,param_1 + 0x50,local_10c,pcVar9);\n    FUN_00007070(param_1 + 0x50,local_10c);\n  }\n  else {\n    pcVar9[(int)(local_10c + -(int)pcVar4)] = '\\0';\n    if (((local_10c[0] != '/') && (local_10c[0] != '\\\\')) &&\n       ((local_10c[0] == '\\0' || (local_10c[1] != ':')))) goto LAB_000072e1;\n    (*pcRam004081d0)(local_33c,0x40f840,local_10c,pcVar9);\n    FUN_00007070(0,local_10c);\n  }\n  pcVar4 = (char *)(*pcRam00408034)(local_33c,0x40000000,0,0,2,local_130,0);\nLAB_00007331:\n  if (pcVar4 == (char *)0xffffffff) {\n    return 0x200;\n  }\n  param_2 = pcVar4;\n  FUN_0000671d(*param_1,param_1[0x4e]);\n  if (param_1[0x4f] == 0) {\n    pvVar5 = operator_new(0x4000);\n    param_1[0x4f] = (int)pvVar5;\n  }\n  param_4 = 0;\n  do {\n    iVar6 = FUN_00006880(*param_1,param_1[0x4f],0x4000,(int)&param_3 + 3);\n    if (iVar6 == -0x6a) {\n      param_4 = 0x1000;\n      goto LAB_0000745a;\n    }\n    if (iVar6 < 0) break;\n    if ((0 < iVar6) && (iVar7 = (*pcRam00408048)(param_2,param_1[0x4f],iVar6,local_8,0), iVar7 == 0)\n       ) {\n      param_4 = 0x400;\n      goto LAB_0000745a;\n    }\n    if (param_3._3_1_ != '\\0') {\n      (*pcRam004080cc)(param_2,local_124,local_12c,local_11c);\n      goto LAB_0000745a;\n    }\n  } while (iVar6 != 0);\n  param_4 = 0x5000000;\nLAB_0000745a:\n  if (param_5 != 1) {\n    (*pcRam004080f0)(param_2);\n  }\n  FUN_00006a97(*param_1);\n  return param_4;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x338",
            "PUSH EBX",
            "MOV EBX,dword ptr [EBP + 0x14]",
            "PUSH ESI",
            "CMP EBX,0x3",
            "PUSH EDI",
            "MOV ESI,ECX",
            "JZ 0x00007168",
            "CMP EBX,0x2",
            "JZ 0x00007210",
            "CMP EBX,0x1",
            "JZ 0x00007210",
            "MOV EAX,0x10000",
            "JMP 0x00007474",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "CMP EDI,EAX",
            "JZ 0x000071b7",
            "CMP EAX,-0x1",
            "JZ 0x0000717f",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006a97",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "OR dword ptr [ESI + 0x4],0xffffffff",
            "CMP EDI,dword ptr [EAX + 0x4]",
            "JGE 0x0000715e",
            "CMP EDI,dword ptr [EAX + 0x10]",
            "JGE 0x00007196",
            "PUSH EAX",
            "CALL 0x000064e2",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "CMP dword ptr [EAX + 0x10],EDI",
            "JGE 0x000071a5",
            "PUSH EAX",
            "CALL 0x00006520",
            "JMP 0x00007195",
            "PUSH dword ptr [ESI + 0x138]",
            "PUSH dword ptr [ESI]",
            "CALL 0x0000671d",
            "POP ECX",
            "MOV dword ptr [ESI + 0x4],EDI",
            "POP ECX",
            "LEA EAX,[EBP + 0xb]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006880",
            "MOV EDI,EAX",
            "ADD ESP,0x10",
            "TEST EDI,EDI",
            "JG 0x000071dd",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006a97",
            "OR dword ptr [ESI + 0x4],0xffffffff",
            "POP ECX",
            "CMP byte ptr [EBP + 0xb],0x0",
            "JZ 0x000071ea",
            "XOR EAX,EAX",
            "JMP 0x00007474",
            "TEST EDI,EDI",
            "JLE 0x000071f8",
            "MOV EAX,0x600",
            "JMP 0x00007474",
            "XOR EAX,EAX",
            "CMP EDI,-0x6a",
            "SETNZ AL",
            "DEC EAX",
            "AND EAX,0xfb001000",
            "ADD EAX,0x5000000",
            "JMP 0x00007474",
            "CMP dword ptr [ESI + 0x4],-0x1",
            "JZ 0x0000721e",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006a97",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "OR dword ptr [ESI + 0x4],0xffffffff",
            "CMP EDI,dword ptr [EAX + 0x4]",
            "JGE 0x0000715e",
            "CMP EDI,dword ptr [EAX + 0x10]",
            "JGE 0x0000723c",
            "PUSH EAX",
            "CALL 0x000064e2",
            "POP ECX",
            "MOV EAX,dword ptr [ESI]",
            "CMP dword ptr [EAX + 0x10],EDI",
            "JGE 0x0000724b",
            "PUSH EAX",
            "CALL 0x00006520",
            "JMP 0x0000723b",
            "LEA EAX,[EBP + 0xfffffdcc]",
            "MOV ECX,ESI",
            "PUSH EAX",
            "PUSH EDI",
            "CALL 0x00006c40",
            "TEST byte ptr [EBP + 0xfffffed4],0x10",
            "JZ 0x0000729c",
            "CMP EBX,0x1",
            "JZ 0x000071e3",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV AL,byte ptr [ECX]",
            "CMP AL,0x2f",
            "JZ 0x00007283",
            "CMP AL,0x5c",
            "JZ 0x00007283",
            "TEST AL,AL",
            "JZ 0x00007288",
            "CMP byte ptr [ECX + 0x1],0x3a",
            "JNZ 0x00007288",
            "PUSH ECX",
            "PUSH 0x0",
            "JMP 0x00007290",
            "ADD ESI,0x140",
            "PUSH ECX",
            "PUSH ESI",
            "CALL 0x00007070",
            "POP ECX",
            "POP ECX",
            "JMP 0x000071e3",
            "CMP EBX,0x1",
            "JNZ 0x000072a9",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "JMP 0x00007331",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV EBX,EDI",
            "MOV ECX,EDI",
            "MOV AL,byte ptr [EDI]",
            "TEST AL,AL",
            "JZ 0x000072c7",
            "CMP AL,0x2f",
            "JZ 0x000072be",
            "CMP AL,0x5c",
            "JNZ 0x000072c1",
            "LEA EBX,[ECX + 0x1]",
            "MOV AL,byte ptr [ECX + 0x1]",
            "INC ECX",
            "JMP 0x000072b2",
            "LEA EAX,[EBP + 0xfffffef8]",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x000076a8",
            "POP ECX",
            "CMP EBX,EDI",
            "POP ECX",
            "JNZ 0x00007343",
            "AND byte ptr [EBP + 0xfffffef8],0x0",
            "LEA EAX,[EBP + 0xfffffef8]",
            "LEA EDI,[ESI + 0x140]",
            "PUSH EBX",
            "PUSH EAX",
            "PUSH EDI",
            "LEA EAX,[EBP + 0xfffffcc8]",
            "PUSH 0x40f848",
            "PUSH EAX",
            "CALL dword ptr [0x004081d0]",
            "LEA EAX,[EBP + 0xfffffef8]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL 0x00007070",
            "ADD ESP,0x1c",
            "XOR EAX,EAX",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0xfffffed4]",
            "PUSH 0x2",
            "PUSH EAX",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffcc8]",
            "PUSH 0x40000000",
            "PUSH EAX",
            "CALL dword ptr [0x00408034]",
            "CMP EAX,-0x1",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JNZ 0x000073ab",
            "MOV EAX,0x200",
            "JMP 0x00007474",
            "MOV EAX,EBX",
            "SUB EAX,EDI",
            "AND byte ptr [EBP + EAX*0x1 + 0xfffffef8],0x0",
            "CMP byte ptr [EBP + 0xfffffef8],0x2f",
            "JZ 0x0000737b",
            "CMP byte ptr [EBP + 0xfffffef8],0x5c",
            "JZ 0x0000737b",
            "CMP byte ptr [EBP + 0xfffffef8],0x0",
            "JZ 0x000072e1",
            "CMP byte ptr [EBP + 0xfffffef9],0x3a",
            "JNZ 0x000072e1",
            "LEA EAX,[EBP + 0xfffffef8]",
            "PUSH EBX",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffcc8]",
            "PUSH 0x40f840",
            "PUSH EAX",
            "CALL dword ptr [0x004081d0]",
            "LEA EAX,[EBP + 0xfffffef8]",
            "PUSH EAX",
            "PUSH 0x0",
            "CALL 0x00007070",
            "ADD ESP,0x18",
            "JMP 0x00007312",
            "PUSH dword ptr [ESI + 0x138]",
            "PUSH dword ptr [ESI]",
            "CALL 0x0000671d",
            "CMP dword ptr [ESI + 0x13c],0x0",
            "POP ECX",
            "POP ECX",
            "MOV EBX,0x4000",
            "JNZ 0x000073d5",
            "PUSH EBX",
            "CALL 0x00007700",
            "POP ECX",
            "MOV dword ptr [ESI + 0x13c],EAX",
            "AND dword ptr [EBP + 0x10],0x0",
            "LEA EAX,[EBP + 0xf]",
            "PUSH EAX",
            "PUSH EBX",
            "PUSH dword ptr [ESI + 0x13c]",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006880",
            "MOV EDI,EAX",
            "ADD ESP,0x10",
            "CMP EDI,-0x6a",
            "JZ 0x00007421",
            "TEST EDI,EDI",
            "JL 0x0000742a",
            "JLE 0x00007415",
            "LEA EAX,[EBP + -0x4]",
            "PUSH 0x0",
            "PUSH EAX",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x13c]",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x00408048]",
            "TEST EAX,EAX",
            "JZ 0x00007433",
            "CMP byte ptr [EBP + 0xf],0x0",
            "JNZ 0x0000743c",
            "TEST EDI,EDI",
            "JZ 0x0000742a",
            "JMP 0x000073d9",
            "MOV dword ptr [EBP + 0x10],0x1000",
            "JMP 0x0000745a",
            "MOV dword ptr [EBP + 0x10],0x5000000",
            "JMP 0x0000745a",
            "MOV dword ptr [EBP + 0x10],0x400",
            "JMP 0x0000745a",
            "LEA EAX,[EBP + 0xfffffee8]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffed8]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffee0]",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x004080cc]",
            "CMP dword ptr [EBP + 0x14],0x1",
            "JZ 0x00007469",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x004080f0]",
            "PUSH dword ptr [ESI]",
            "CALL 0x00006a97",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "POP ECX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x10"
        ],
        "function_address": {
            "start": "00007136",
            "end": "0000747a"
        },
        "variable_metadata": {
            "local_12c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00007443"
                ],
                "type": "undefined"
            },
            "local_10b": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000736e"
                ],
                "type": "undefined1"
            },
            "local_11c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000743c"
                ],
                "type": "undefined"
            },
            "local_33c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000072f0",
                    "0000731f",
                    "00007383"
                ],
                "type": "undefined"
            },
            "local_238": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000724b"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000073fb"
                ],
                "type": "undefined"
            },
            "local_124": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000744a"
                ],
                "type": "undefined"
            },
            "local_130": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000725a",
                    "00007315"
                ],
                "type": "undefined4"
            },
            "local_10c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000072c7",
                    "000072da",
                    "000072e1",
                    "00007302",
                    "0000734f",
                    "00007358",
                    "00007361",
                    "0000737b",
                    "00007395"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00007136",
        "original_name": "FUN_00007136",
        "predicted_name": "The function you provided is likely a decompiled version of the `find_file` function from the `libc` library.",
        "prediction_full_response": "The function you provided is likely a decompiled version of the `find_file` function from the `libc` library.\n\nThe function takes in a number of parameters, including a file name, a file descriptor, and a set of flags. It appears to be used for searching for a file in a directory.\n\nThe function first checks if the file name is a relative path, and if so, it converts it to an absolute path. It then checks if the file exists and is a regular file, and if so, it returns the file descriptor.\n\nIf the file does not exist or is not a regular file, the function checks if the file name is a symbolic link. If it is, the function follows the link and checks if the linked file exists and is a regular file. If it does, the function returns the file descriptor.\n\nIf the file does not exist or is not a regular file, the function checks if the file name is a directory. If it is, the function recursively searches the directory for the file. If the file is found, the function returns the file descriptor.\n\nIf the file is not found, the function returns -1.\n\nOverall"
    },
    "00005def": {
        "decomp_code": "\nint FUN_00005def(undefined4 param_1,uint *param_2)\n\n{\n  int iVar1;\n  undefined4 uStack_8;\n  \n  iVar1 = FUN_00005d8a((int)&uStack_8 + 3,1,1,param_1);\n  if (iVar1 == 1) {\n    *param_2 = uStack_8 >> 0x18;\n    return 0;\n  }\n  iVar1 = FUN_00005cc7(param_1);\n  return -(uint)(iVar1 != 0);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + -0x1]",
            "PUSH 0x1",
            "PUSH 0x1",
            "PUSH EAX",
            "CALL 0x00005d8a",
            "ADD ESP,0x10",
            "CMP EAX,0x1",
            "JNZ 0x00005e18",
            "MOVZX EAX,byte ptr [EBP + -0x1]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ECX],EAX",
            "XOR EAX,EAX",
            "LEAVE",
            "RET",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL 0x00005cc7",
            "NEG EAX",
            "POP ECX",
            "SBB EAX,EAX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00005def",
            "end": "00005e26"
        },
        "variable_metadata": {
            "local_5": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005df6",
                    "00005e0b"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00005def",
        "original_name": "FUN_00005def",
        "predicted_name": "FUN_00005d8a.",
        "prediction_full_response": "The predicted function name is FUN_00005d8a.</s>"
    },
    "0000763d": {
        "decomp_code": "\nvoid FUN_0000763d(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  FUN_00007603(param_1,param_2,param_3,0,2);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH 0x2",
            "PUSH 0x0",
            "PUSH dword ptr [ESP + 0x14]",
            "PUSH dword ptr [ESP + 0x14]",
            "PUSH dword ptr [ESP + 0x14]",
            "CALL 0x00007603",
            "ADD ESP,0x14",
            "RET"
        ],
        "function_address": {
            "start": "0000763d",
            "end": "00007655"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000763d",
        "original_name": "FUN_0000763d",
        "predicted_name": "FUN_00007603.",
        "prediction_full_response": "The predicted function name is FUN_00007603.</s>"
    },
    "00005bae": {
        "decomp_code": "\nundefined1 * FUN_00005bae(int param_1,undefined4 param_2,int param_3,undefined4 *param_4)\n\n{\n  undefined1 uVar1;\n  int iVar2;\n  int iVar3;\n  undefined1 *puVar4;\n  undefined4 uVar5;\n  bool local_6;\n  undefined1 local_5;\n  \n  if (((param_3 != 1) && (param_3 != 2)) && (param_3 != 3)) {\n    *param_4 = 0x10000;\n    return (undefined1 *)0x0;\n  }\n  *param_4 = 0;\n  local_6 = false;\n  local_5 = 0;\n  iVar2 = param_1;\n  uVar1 = 0;\n  if (param_3 != 1) {\n    iVar2 = 0;\n    if (param_3 != 2) goto LAB_00005c36;\n    iVar2 = (*pcRam00408034)(param_1,0x80000000,1,0,3,0x80,0);\n    if (iVar2 == -1) {\n      *param_4 = 0x200;\n      return (undefined1 *)0x0;\n    }\n    local_5 = 1;\n    uVar1 = local_5;\n  }\n  local_5 = uVar1;\n  iVar3 = (*pcRam004080c8)(iVar2,0,0,1);\n  local_6 = iVar3 != -1;\nLAB_00005c36:\n  puVar4 = (undefined1 *)operator_new(0x20);\n  if ((param_3 == 1) || (param_3 == 2)) {\n    *puVar4 = 1;\n    puVar4[0x10] = local_5;\n    puVar4[1] = local_6;\n    *(int *)(puVar4 + 4) = iVar2;\n    puVar4[8] = 0;\n    *(undefined4 *)(puVar4 + 0xc) = 0;\n    if (local_6 != false) {\n      uVar5 = (*pcRam004080c8)(iVar2,0,0,1);\n      *(undefined4 *)(puVar4 + 0xc) = uVar5;\n    }\n  }\n  else {\n    *puVar4 = 0;\n    *(int *)(puVar4 + 0x14) = param_1;\n    puVar4[1] = 1;\n    puVar4[0x10] = 0;\n    *(undefined4 *)(puVar4 + 0x18) = param_2;\n    *(undefined4 *)(puVar4 + 0x1c) = 0;\n    *(undefined4 *)(puVar4 + 0xc) = 0;\n  }\n  *param_4 = 0;\n  return puVar4;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "PUSH EBX",
            "PUSH ESI",
            "CMP EAX,0x1",
            "PUSH EDI",
            "JZ 0x00005bd2",
            "CMP EAX,0x2",
            "JZ 0x00005bd2",
            "CMP EAX,0x3",
            "JZ 0x00005bd2",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "MOV dword ptr [EAX],0x10000",
            "JMP 0x00005c11",
            "MOV ESI,dword ptr [EBP + 0x14]",
            "XOR EBX,EBX",
            "XOR EDI,EDI",
            "CMP EAX,0x1",
            "MOV byte ptr [EBP + -0x2],BL",
            "MOV dword ptr [ESI],EBX",
            "MOV byte ptr [EBP + -0x1],BL",
            "JZ 0x00005c18",
            "CMP EAX,0x2",
            "JNZ 0x00005c36",
            "PUSH EBX",
            "PUSH 0x80",
            "PUSH 0x3",
            "PUSH EBX",
            "PUSH 0x1",
            "PUSH 0x80000000",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x00408034]",
            "MOV EDI,EAX",
            "CMP EDI,-0x1",
            "JNZ 0x00005c20",
            "MOV dword ptr [ESI],0x200",
            "XOR EAX,EAX",
            "JMP 0x00005c9a",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "MOV byte ptr [EBP + -0x1],BL",
            "JMP 0x00005c24",
            "MOV byte ptr [EBP + -0x1],0x1",
            "PUSH 0x1",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH EDI",
            "CALL dword ptr [0x004080c8]",
            "CMP EAX,-0x1",
            "SETNZ byte ptr [EBP + -0x2]",
            "PUSH 0x20",
            "CALL 0x00007700",
            "CMP dword ptr [EBP + 0x10],0x1",
            "POP ECX",
            "MOV ESI,EAX",
            "JZ 0x00005c69",
            "CMP dword ptr [EBP + 0x10],0x2",
            "JZ 0x00005c69",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV byte ptr [ESI],BL",
            "MOV dword ptr [ESI + 0x14],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV byte ptr [ESI + 0x1],0x1",
            "MOV byte ptr [ESI + 0x10],BL",
            "MOV dword ptr [ESI + 0x18],EAX",
            "MOV dword ptr [ESI + 0x1c],EBX",
            "MOV dword ptr [ESI + 0xc],EBX",
            "JMP 0x00005c93",
            "MOV AL,byte ptr [EBP + -0x1]",
            "MOV byte ptr [ESI],0x1",
            "MOV byte ptr [ESI + 0x10],AL",
            "MOV AL,byte ptr [EBP + -0x2]",
            "CMP AL,BL",
            "MOV byte ptr [ESI + 0x1],AL",
            "MOV dword ptr [ESI + 0x4],EDI",
            "MOV byte ptr [ESI + 0x8],BL",
            "MOV dword ptr [ESI + 0xc],EBX",
            "JZ 0x00005c93",
            "PUSH 0x1",
            "PUSH EBX",
            "PUSH EBX",
            "PUSH EDI",
            "CALL dword ptr [0x004080c8]",
            "MOV dword ptr [ESI + 0xc],EAX",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "MOV dword ptr [EAX],EBX",
            "MOV EAX,ESI",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00005bae",
            "end": "00005c9e"
        },
        "variable_metadata": {
            "local_6": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005bdc",
                    "00005c32",
                    "00005c72"
                ],
                "type": "undefined1"
            },
            "local_5": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00005be1",
                    "00005c1b",
                    "00005c20",
                    "00005c69"
                ],
                "type": "undefined1"
            }
        },
        "func_name": "FUN_00005bae",
        "original_name": "FUN_00005bae",
        "predicted_name": "[PYTHON]",
        "prediction_full_response": "[PYTHON]\n\ndef get_function_name(code):\n    # Extract the function name from the code\n    name = None\n    try:\n        tree = ast.parse(code)\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef):\n                name = node.name\n                break\n    except SyntaxError:\n        pass\n    return name\n\n[/PYTHON]\n</s>"
    },
    "00001dab": {
        "decomp_code": "\nundefined4 FUN_00001dab(undefined4 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int iVar4;\n  char *pcVar5;\n  int iVar6;\n  int local_130;\n  char local_12c [296];\n  \n  iVar1 = (*pcRam00408100)(param_1,0x80a,0x40f43c);\n  if (((iVar1 != 0) && (iVar2 = (*pcRam00408074)(param_1,iVar1), iVar2 != 0)) &&\n     (iVar2 = (*pcRam00408070)(iVar2), iVar2 != 0)) {\n    uVar3 = (*pcRam0040806c)(param_1,iVar1,param_2);\n    iVar1 = FUN_000075ad(iVar2,uVar3);\n    if (iVar1 != 0) {\n      local_130 = 0;\n      pcVar5 = local_12c;\n      for (iVar2 = 0x4a; iVar2 != 0; iVar2 = iVar2 + -1) {\n        pcVar5[0] = '\\0';\n        pcVar5[1] = '\\0';\n        pcVar5[2] = '\\0';\n        pcVar5[3] = '\\0';\n        pcVar5 = pcVar5 + 4;\n      }\n      FUN_000075c4(iVar1,0xffffffff,&local_130);\n      iVar2 = local_130;\n      iVar6 = 0;\n      if (0 < local_130) {\n        do {\n          FUN_000075c4(iVar1,iVar6,&local_130);\n          iVar4 = strcmp(local_12c,(char *)0x40e010);\n          if ((iVar4 != 0) || (iVar4 = (*pcRam00408068)(local_12c), iVar4 == -1)) {\n            FUN_0000763d(iVar1,iVar6,local_12c);\n          }\n          iVar6 = iVar6 + 1;\n        } while (iVar6 < iVar2);\n      }\n      FUN_00007656(iVar1);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x12c",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH 0x40f43c",
            "PUSH 0x80a",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x00408100]",
            "MOV ESI,EAX",
            "TEST ESI,ESI",
            "JZ 0x00001e07",
            "PUSH ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x00408074]",
            "TEST EAX,EAX",
            "JZ 0x00001e07",
            "PUSH EAX",
            "CALL dword ptr [0x00408070]",
            "MOV EDI,EAX",
            "TEST EDI,EDI",
            "JZ 0x00001e07",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x0040806c]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL 0x000075ad",
            "MOV ESI,EAX",
            "ADD ESP,0xc",
            "TEST ESI,ESI",
            "JNZ 0x00001e0e",
            "XOR EAX,EAX",
            "JMP 0x00001e9a",
            "AND dword ptr [EBP + 0xfffffed4],0x0",
            "PUSH EBX",
            "PUSH 0x4a",
            "XOR EAX,EAX",
            "POP ECX",
            "LEA EDI,[EBP + 0xfffffed8]",
            "STOSD.REP ES:EDI",
            "LEA EAX,[EBP + 0xfffffed4]",
            "PUSH EAX",
            "PUSH -0x1",
            "PUSH ESI",
            "CALL 0x000075c4",
            "MOV EBX,dword ptr [EBP + 0xfffffed4]",
            "ADD ESP,0xc",
            "XOR EDI,EDI",
            "TEST EBX,EBX",
            "JLE 0x00001e8f",
            "LEA EAX,[EBP + 0xfffffed4]",
            "PUSH EAX",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x000075c4",
            "LEA EAX,[EBP + 0xfffffed8]",
            "PUSH 0x40e010",
            "PUSH EAX",
            "CALL 0x00007740",
            "ADD ESP,0x14",
            "TEST EAX,EAX",
            "JNZ 0x00001e79",
            "LEA EAX,[EBP + 0xfffffed8]",
            "PUSH EAX",
            "CALL dword ptr [0x00408068]",
            "CMP EAX,-0x1",
            "JNZ 0x00001e8a",
            "LEA EAX,[EBP + 0xfffffed8]",
            "PUSH EAX",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x0000763d",
            "ADD ESP,0xc",
            "INC EDI",
            "CMP EDI,EBX",
            "JL 0x00001e41",
            "PUSH ESI",
            "CALL 0x00007656",
            "POP ECX",
            "PUSH 0x1",
            "POP EAX",
            "POP EBX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001dab",
            "end": "00001e9d"
        },
        "variable_metadata": {
            "local_12c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001e1b",
                    "00001e4f",
                    "00001e67",
                    "00001e79"
                ],
                "type": "undefined"
            },
            "local_130": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001e0e",
                    "00001e23",
                    "00001e32",
                    "00001e41"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00001dab",
        "original_name": "FUN_00001dab",
        "predicted_name": "FUN_00007656.",
        "prediction_full_response": "The predicted function name is FUN_00007656.</s>"
    },
    "00006162": {
        "decomp_code": "\nundefined4 FUN_00006162(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    return 0xffffff9a;\n  }\n  if (param_1[0x1f] != 0) {\n    FUN_00006a97(param_1);\n  }\n  FUN_00005c9f(*param_1);\n  (*pcRam00408174)(param_1);\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "TEST ESI,ESI",
            "JNZ 0x00006170",
            "PUSH -0x66",
            "POP EAX",
            "POP ESI",
            "RET",
            "CMP dword ptr [ESI + 0x7c],0x0",
            "JZ 0x0000617d",
            "PUSH ESI",
            "CALL 0x00006a97",
            "POP ECX",
            "PUSH dword ptr [ESI]",
            "CALL 0x00005c9f",
            "PUSH ESI",
            "CALL dword ptr [0x00408174]",
            "POP ECX",
            "XOR EAX,EAX",
            "POP ECX",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00006162",
            "end": "00006190"
        },
        "variable_metadata": {},
        "func_name": "FUN_00006162",
        "original_name": "FUN_00006162",
        "predicted_name": "FUN_00005c9f.",
        "prediction_full_response": "The predicted function name is FUN_00005c9f.</s>"
    },
    "0000181b": {
        "decomp_code": "\nvoid __fastcall FUN_0000181b(undefined4 *param_1)\n\n{\n  *param_1 = 0x4081ec;\n  (*pcRam0040803c)(param_1 + 4);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV dword ptr [ECX],0x4081ec",
            "ADD ECX,0x10",
            "PUSH ECX",
            "CALL dword ptr [0x0040803c]",
            "RET"
        ],
        "function_address": {
            "start": "0000181b",
            "end": "0000182b"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000181b",
        "original_name": "FUN_0000181b",
        "predicted_name": "pcRam0040803c",
        "prediction_full_response": "The predicted function name is pcRam0040803c</s>"
    },
    "00001437": {
        "decomp_code": "\nundefined4 __thiscall FUN_00001437(int param_1,int param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 unaff_EBX;\n  undefined4 unaff_ESI;\n  \n  iVar2 = FUN_00001861(param_2);\n  if (iVar2 != 0) {\n    if (param_2 != 0) {\n      FUN_00001861(0);\n    }\n    pcVar1 = pcRam004080dc;\n    iVar2 = (*pcRam004080dc)(0,0x100000);\n    *(int *)(param_1 + 0x4c8) = iVar2;\n    if (iVar2 != 0) {\n      iVar2 = (*pcVar1)(0,0x100000);\n      *(int *)(param_1 + 0x4cc) = iVar2;\n      if (iVar2 != 0) {\n        *(undefined4 *)(param_1 + 0x4d4) = unaff_ESI;\n        *(undefined4 *)(param_1 + 0x4d0) = unaff_EBX;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV ESI,ECX",
            "PUSH dword ptr [ESP + 0x10]",
            "LEA ECX,[ESI + 0x4]",
            "CALL 0x00001861",
            "TEST EAX,EAX",
            "JZ 0x00001485",
            "XOR EDI,EDI",
            "CMP dword ptr [ESP + 0x10],EDI",
            "JZ 0x0000145d",
            "PUSH EDI",
            "LEA ECX,[ESI + 0x2c]",
            "CALL 0x00001861",
            "MOV EBX,0x100000",
            "PUSH EBX",
            "PUSH EDI",
            "MOV EDI,dword ptr [0x004080dc]",
            "CALL EDI",
            "TEST EAX,EAX",
            "MOV dword ptr [ESI + 0x4c8],EAX",
            "JZ 0x00001485",
            "PUSH EBX",
            "PUSH 0x0",
            "CALL EDI",
            "TEST EAX,EAX",
            "MOV dword ptr [ESI + 0x4cc],EAX",
            "JNZ 0x00001489",
            "XOR EAX,EAX",
            "JMP 0x000014a0",
            "MOV EAX,dword ptr [ESP + 0x14]",
            "PUSH 0x1",
            "MOV dword ptr [ESI + 0x4d4],EAX",
            "MOV EAX,dword ptr [ESP + 0x1c]",
            "MOV dword ptr [ESI + 0x4d0],EAX",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "RET 0xc"
        ],
        "function_address": {
            "start": "00001437",
            "end": "000014a5"
        },
        "variable_metadata": {},
        "func_name": "FUN_00001437",
        "original_name": "FUN_00001437",
        "predicted_name": "FUN_00001861.",
        "prediction_full_response": "The predicted function name is FUN_00001861.</s>"
    },
    "00002924": {
        "decomp_code": "\nint FUN_00002924(int *param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  ushort *puVar4;\n  int iVar5;\n  int *piVar6;\n  \n  iVar1 = param_1[1];\n  if (*(int *)(*param_1 + 0x7c) != 0) {\n    iVar5 = *(int *)(*param_1 + 0x78);\n    iVar3 = *(int *)(iVar5 + 0x18 + iVar1);\n    iVar5 = iVar5 + iVar1;\n    if ((iVar3 != 0) && (*(int *)(iVar5 + 0x14) != 0)) {\n      if ((short)(param_2 >> 0x10) == 0) {\n        if (*(uint *)(iVar5 + 0x10) <= (param_2 & 0xffff)) {\n          uVar2 = (param_2 & 0xffff) - *(uint *)(iVar5 + 0x10);\nLAB_000029ba:\n          if (uVar2 <= *(uint *)(iVar5 + 0x14)) {\n            return *(int *)(*(int *)(iVar5 + 0x1c) + uVar2 * 4 + iVar1) + iVar1;\n          }\n        }\n      }\n      else {\n        piVar6 = (int *)(*(int *)(iVar5 + 0x20) + iVar1);\n        puVar4 = (ushort *)(*(int *)(iVar5 + 0x24) + iVar1);\n        param_1 = (int *)0x0;\n        if (iVar3 != 0) {\n          do {\n            iVar3 = (*pcRam00408170)(param_2,*piVar6 + iVar1);\n            if (iVar3 == 0) {\n              uVar2 = (uint)*puVar4;\n              goto LAB_000029ba;\n            }\n            param_1 = (int *)((int)param_1 + 1);\n            piVar6 = piVar6 + 1;\n            puVar4 = puVar4 + 1;\n          } while (param_1 < *(uint *)(iVar5 + 0x18));\n        }\n      }\n    }\n  }\n  (*pcRam004080a8)(0x7f);\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH ECX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "XOR EDX,EDX",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ECX,dword ptr [EAX + 0x4]",
            "MOV EAX,dword ptr [EAX]",
            "ADD EAX,0x78",
            "PUSH EDI",
            "MOV dword ptr [EBP + -0x4],ECX",
            "CMP dword ptr [EAX + 0x4],EDX",
            "JZ 0x000029a5",
            "MOV ESI,dword ptr [EAX]",
            "MOV EAX,dword ptr [ESI + ECX*0x1 + 0x18]",
            "ADD ESI,ECX",
            "CMP EAX,EDX",
            "JZ 0x000029a5",
            "CMP dword ptr [ESI + 0x14],EDX",
            "JZ 0x000029a5",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "SHR EDI,0x10",
            "TEST DI,DI",
            "JNZ 0x0000296b",
            "MOVZX EAX,word ptr [EBP + 0xc]",
            "MOV EDX,dword ptr [ESI + 0x10]",
            "CMP EAX,EDX",
            "JC 0x000029a5",
            "SUB EAX,EDX",
            "JMP 0x000029ba",
            "MOV EDI,dword ptr [ESI + 0x20]",
            "MOV EBX,dword ptr [ESI + 0x24]",
            "ADD EDI,ECX",
            "ADD EBX,ECX",
            "CMP EAX,EDX",
            "MOV dword ptr [EBP + 0x8],EDX",
            "JBE 0x000029a5",
            "JMP 0x00002981",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV EAX,dword ptr [EDI]",
            "ADD EAX,ECX",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL dword ptr [0x00408170]",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000029b4",
            "INC dword ptr [EBP + 0x8]",
            "ADD EDI,0x4",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "INC EBX",
            "INC EBX",
            "CMP EAX,dword ptr [ESI + 0x18]",
            "JC 0x0000297e",
            "PUSH 0x7f",
            "CALL dword ptr [0x004080a8]",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET",
            "MOVZX EAX,word ptr [EBX]",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "CMP EAX,dword ptr [ESI + 0x14]",
            "JA 0x000029a5",
            "MOV EDX,dword ptr [ESI + 0x1c]",
            "LEA EAX,[EDX + EAX*0x4]",
            "MOV EAX,dword ptr [EAX + ECX*0x1]",
            "ADD EAX,ECX",
            "JMP 0x000029af"
        ],
        "function_address": {
            "start": "00002924",
            "end": "000029cb"
        },
        "variable_metadata": {
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002938",
                    "0000297e",
                    "000029b7"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00002924",
        "original_name": "FUN_00002924",
        "predicted_name": "`get_value_from_table`.",
        "prediction_full_response": "The predicted function name is `get_value_from_table`.</s>"
    },
    "00005cdd": {
        "decomp_code": "\nint FUN_00005cdd(char *param_1)\n\n{\n  int iVar1;\n  \n  if (*param_1 != '\\0') {\n    if (param_1[1] != '\\0') {\n      iVar1 = (*pcRam004080c8)(*(undefined4 *)(param_1 + 4),0,0,1);\n      return iVar1 - *(int *)(param_1 + 0xc);\n    }\n    if (*param_1 != '\\0') {\n      return 0;\n    }\n  }\n  return *(int *)(param_1 + 0x1c);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0x8]",
            "XOR ECX,ECX",
            "MOV AL,byte ptr [ESI]",
            "CMP AL,CL",
            "JZ 0x00005d09",
            "CMP byte ptr [ESI + 0x1],CL",
            "JZ 0x00005d01",
            "PUSH 0x1",
            "PUSH ECX",
            "PUSH ECX",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL dword ptr [0x004080c8]",
            "SUB EAX,dword ptr [ESI + 0xc]",
            "POP ESI",
            "RET",
            "CMP AL,CL",
            "JZ 0x00005d09",
            "XOR EAX,EAX",
            "POP ESI",
            "RET",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "POP ESI",
            "RET"
        ],
        "function_address": {
            "start": "00005cdd",
            "end": "00005d0d"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005cdd",
        "original_name": "FUN_00005cdd",
        "predicted_name": "get_int_arg",
        "prediction_full_response": "The predicted function name is get_int_arg</s>"
    },
    "0000776e": {
        "decomp_code": "\nvoid _CxxThrowException(void *pExceptionObject,ThrowInfo *pThrowInfo)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x0000776e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam00408188)();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408188]"
        ],
        "function_address": {
            "start": "0000776e",
            "end": "00007773"
        },
        "variable_metadata": {
            "pThrowInfo": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": true
                },
                "addresses": [],
                "type": "_s_ThrowInfo *"
            },
            "pExceptionObject": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            }
        },
        "func_name": "_CxxThrowException",
        "original_name": "_CxxThrowException",
        "predicted_name": "__CxxFrameHandler3",
        "prediction_full_response": "The predicted function name is __CxxFrameHandler3</s>"
    },
    "000021bd": {
        "decomp_code": "\nvoid FUN_000021bd(undefined4 param_1,undefined4 param_2)\n\n{\n  FUN_000021e9(param_1,param_2,0x40216e,0x402185,0x402198,0x4021a3,0x4021b2,0);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH 0x0",
            "PUSH 0x4021b2",
            "PUSH 0x4021a3",
            "PUSH 0x402198",
            "PUSH 0x402185",
            "PUSH 0x40216e",
            "PUSH dword ptr [ESP + 0x20]",
            "PUSH dword ptr [ESP + 0x20]",
            "CALL 0x000021e9",
            "ADD ESP,0x20",
            "RET"
        ],
        "function_address": {
            "start": "000021bd",
            "end": "000021e8"
        },
        "variable_metadata": {},
        "func_name": "FUN_000021bd",
        "original_name": "FUN_000021bd",
        "predicted_name": "FUN_000021e9.",
        "prediction_full_response": "The predicted function name is FUN_000021e9.</s>"
    },
    "00002e7e": {
        "decomp_code": "\nvoid __thiscall FUN_00002e7e(int param_1,uint *param_2,byte *param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined1 local_2c [12];\n  int local_20;\n  uint local_18;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  int local_8;\n  \n  if (*(char *)(param_1 + 4) != '\\0') {\n    local_14 = ((uint)*(byte *)param_2 << 0x18 | (uint)*(byte *)((int)param_2 + 1) << 0x10 |\n                (uint)*(byte *)((int)param_2 + 2) << 8 | (uint)*(byte *)((int)param_2 + 3)) ^\n               *(uint *)(param_1 + 8);\n    local_10 = ((uint)*(byte *)((int)param_2 + 4) << 0x18 |\n                (uint)*(byte *)((int)param_2 + 5) << 0x10 | (uint)*(byte *)((int)param_2 + 6) << 8 |\n               (uint)*(byte *)((int)param_2 + 7)) ^ *(uint *)(param_1 + 0xc);\n    uVar4 = ((uint)*(byte *)((int)param_2 + 8) << 0x18 | (uint)*(byte *)((int)param_2 + 9) << 0x10 |\n             (uint)*(byte *)((int)param_2 + 10) << 8 | (uint)*(byte *)((int)param_2 + 0xb)) ^\n            *(uint *)(param_1 + 0x10);\n    iVar1 = *(int *)(param_1 + 0x410);\n    local_c = ((uint)CONCAT11(*(byte *)((int)param_2 + 0xe),*(byte *)((int)param_2 + 0xf)) |\n              (uint)*(byte *)((int)param_2 + 0xc) << 0x18 |\n              (uint)*(byte *)((int)param_2 + 0xd) << 0x10) ^ *(uint *)(param_1 + 0x14);\n    if (1 < iVar1) {\n      local_8 = iVar1 + -1;\n      param_2 = (uint *)(param_1 + 0x30);\n      local_18 = uVar4;\n      do {\n        uVar5 = *(uint *)((local_c >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_18 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_10 >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_14 & 0xff) * 4 + 0x4097fc) ^ param_2[-1];\n        uVar4 = *(uint *)((local_c >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_18 >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_14 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_10 & 0xff) * 4 + 0x4097fc) ^ *param_2;\n        uVar3 = *(uint *)((local_c >> 0x18) * 4 + 0x408bfc) ^\n                *(uint *)((local_10 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                *(uint *)((local_14 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                *(uint *)((local_18 & 0xff) * 4 + 0x4097fc) ^ param_2[1];\n        local_14 = *(uint *)((local_18 >> 8 & 0xff) * 4 + 0x4093fc) ^\n                   *(uint *)((local_10 >> 0x10 & 0xff) * 4 + 0x408ffc) ^\n                   *(uint *)((local_14 >> 0x18) * 4 + 0x408bfc) ^\n                   *(uint *)((local_c & 0xff) * 4 + 0x4097fc) ^ param_2[-2];\n        local_8 = local_8 + -1;\n        param_2 = param_2 + 8;\n        local_18 = uVar4;\n        local_10 = uVar5;\n        local_c = uVar3;\n      } while (local_8 != 0);\n    }\n    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 8 + param_1);\n    param_1 = iVar1 * 0x20 + 8 + param_1;\n    *param_3 = *(byte *)((local_14 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[1] = *(byte *)((local_10 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[2] = *(byte *)((uVar4 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[3] = *(byte *)((local_c & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 4);\n    param_3[4] = *(byte *)((local_10 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[5] = *(byte *)((uVar4 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[6] = *(byte *)((local_c >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[7] = *(byte *)((local_14 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 8);\n    param_3[8] = *(byte *)((uVar4 >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[9] = *(byte *)((local_c >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[10] = *(byte *)((local_14 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xb] = *(byte *)((local_10 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    uVar2 = *(undefined4 *)(param_1 + 0xc);\n    param_3[0xc] = *(byte *)((local_c >> 0x18) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x18);\n    param_3[0xd] = *(byte *)((local_14 >> 0x10 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 0x10);\n    param_3[0xe] = *(byte *)((local_10 >> 8 & 0xff) + 0x4089fc) ^ (byte)((uint)uVar2 >> 8);\n    local_8._0_1_ = (byte)uVar2;\n    param_3[0xf] = *(byte *)((uVar4 & 0xff) + 0x4089fc) ^ (byte)local_8;\n    return;\n  }\n  local_20 = param_1;\n  (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_2c,(ThrowInfo *)0x40d570);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x28",
            "PUSH EDI",
            "MOV EDI,ECX",
            "MOV dword ptr [EBP + -0x1c],EDI",
            "CMP byte ptr [EDI + 0x4],0x0",
            "JNZ 0x00002eac",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0x28]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0x28]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH EBX",
            "PUSH ESI",
            "XOR EBX,EBX",
            "MOVZX EDX,byte ptr [EAX]",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SHL EDX,0x18",
            "INC EAX",
            "SHL ECX,0x10",
            "OR EDX,ECX",
            "INC EAX",
            "XOR ECX,ECX",
            "MOV CH,byte ptr [EAX]",
            "OR EDX,ECX",
            "INC EAX",
            "MOVZX ECX,byte ptr [EAX]",
            "MOVZX ESI,byte ptr [EAX + 0x1]",
            "OR EDX,ECX",
            "INC EAX",
            "XOR EDX,dword ptr [EDI + 0x8]",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "SHL ESI,0x18",
            "INC EAX",
            "MOV dword ptr [EBP + -0x10],EDX",
            "SHL ECX,0x10",
            "OR ESI,ECX",
            "INC EAX",
            "XOR ECX,ECX",
            "MOV CH,byte ptr [EAX]",
            "OR ESI,ECX",
            "INC EAX",
            "MOVZX ECX,byte ptr [EAX]",
            "OR ESI,ECX",
            "INC EAX",
            "XOR ESI,dword ptr [EDI + 0xc]",
            "MOVZX ECX,byte ptr [EAX]",
            "SHL ECX,0x18",
            "INC EAX",
            "MOV dword ptr [EBP + -0xc],ESI",
            "MOVZX ESI,byte ptr [EAX]",
            "MOV BH,byte ptr [EAX + 0x1]",
            "SHL ESI,0x10",
            "OR ECX,ESI",
            "INC EAX",
            "OR ECX,EBX",
            "INC EAX",
            "MOVZX ESI,byte ptr [EAX]",
            "OR ECX,ESI",
            "INC EAX",
            "XOR ECX,dword ptr [EDI + 0x10]",
            "MOVZX ESI,byte ptr [EAX]",
            "MOVZX EBX,byte ptr [EAX + 0x1]",
            "SHL ESI,0x18",
            "INC EAX",
            "MOV dword ptr [EBP + -0x14],ECX",
            "SHL EBX,0x10",
            "OR ESI,EBX",
            "INC EAX",
            "XOR EBX,EBX",
            "MOV BH,byte ptr [EAX]",
            "MOV BL,byte ptr [EAX + 0x1]",
            "MOV EAX,dword ptr [EDI + 0x410]",
            "OR EBX,ESI",
            "MOV dword ptr [EBP + -0x18],EAX",
            "XOR EBX,dword ptr [EDI + 0x14]",
            "CMP EAX,0x1",
            "MOV ESI,0xff",
            "MOV dword ptr [EBP + -0x8],EBX",
            "JLE 0x00003056",
            "ADD EDI,0x30",
            "DEC EAX",
            "MOV dword ptr [EBP + 0x8],EDI",
            "MOV dword ptr [EBP + -0x4],EAX",
            "XOR EAX,EAX",
            "XOR EBX,EBX",
            "MOV AL,byte ptr [EBP + -0x7]",
            "MOV BL,byte ptr [EBP + -0x12]",
            "MOV EDI,dword ptr [EAX*0x4 + 0x4093fc]",
            "XOR EAX,EAX",
            "XOR EDI,dword ptr [EBX*0x4 + 0x408ffc]",
            "MOV AL,byte ptr [EBP + -0x9]",
            "XOR EBX,EBX",
            "XOR EDI,dword ptr [EAX*0x4 + 0x408bfc]",
            "MOV EAX,EDX",
            "AND EAX,ESI",
            "MOV BL,byte ptr [EBP + -0x11]",
            "XOR EDI,dword ptr [EAX*0x4 + 0x4097fc]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "XOR EDI,dword ptr [EAX + -0x4]",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EBP + -0x6]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x408ffc]",
            "XOR EAX,dword ptr [EBX*0x4 + 0x408bfc]",
            "XOR EBX,EBX",
            "MOV BL,DH",
            "MOV EDX,dword ptr [EBP + -0xc]",
            "AND EDX,ESI",
            "XOR EAX,dword ptr [EBX*0x4 + 0x4093fc]",
            "MOV EBX,dword ptr [EBP + 0x8]",
            "ADD EBX,0x20",
            "XOR EAX,dword ptr [EDX*0x4 + 0x4097fc]",
            "MOV EDX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [EBP + 0x8],EBX",
            "XOR EAX,dword ptr [EDX]",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xb]",
            "MOV dword ptr [EBP + -0x14],EAX",
            "XOR EAX,EAX",
            "MOV AL,byte ptr [EBP + -0x5]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x408bfc]",
            "XOR EAX,dword ptr [EDX*0x4 + 0x4093fc]",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xe]",
            "XOR EAX,dword ptr [EDX*0x4 + 0x408ffc]",
            "MOV EDX,ECX",
            "AND EDX,ESI",
            "XOR EAX,dword ptr [EDX*0x4 + 0x4097fc]",
            "XOR EDX,EDX",
            "MOV DL,CH",
            "XOR ECX,ECX",
            "MOV CL,byte ptr [EBP + -0xa]",
            "XOR EAX,dword ptr [EBX + -0x1c]",
            "MOV EDX,dword ptr [EDX*0x4 + 0x4093fc]",
            "MOV dword ptr [EBP + -0xc],EDI",
            "XOR EDX,dword ptr [ECX*0x4 + 0x408ffc]",
            "XOR ECX,ECX",
            "MOV CL,byte ptr [EBP + -0xd]",
            "XOR EDX,dword ptr [ECX*0x4 + 0x408bfc]",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "AND ECX,ESI",
            "MOV dword ptr [EBP + -0x8],EAX",
            "XOR EDX,dword ptr [ECX*0x4 + 0x4097fc]",
            "MOV ECX,dword ptr [EBP + -0x14]",
            "MOV dword ptr [EBP + -0x14],ECX",
            "XOR EDX,dword ptr [EBX + -0x28]",
            "DEC dword ptr [EBP + -0x4]",
            "MOV dword ptr [EBP + -0x10],EDX",
            "JNZ 0x00002f5f",
            "MOV EAX,dword ptr [EBP + -0x18]",
            "MOV EDI,dword ptr [EBP + -0x1c]",
            "SHL EAX,0x5",
            "MOV EDX,dword ptr [EAX + EDI*0x1 + 0x8]",
            "LEA EDI,[EAX + EDI*0x1 + 0x8]",
            "XOR EAX,EAX",
            "MOV EBX,EDX",
            "MOV AL,byte ptr [EBP + -0xd]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EBX,0x18",
            "MOV AL,byte ptr [EAX + 0x4089fc]",
            "XOR AL,BL",
            "MOV BL,AL",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV byte ptr [EAX],BL",
            "XOR EBX,EBX",
            "MOV BL,byte ptr [EBP + -0xa]",
            "SAR EDX,0x10",
            "MOV BL,byte ptr [EBX + 0x4089fc]",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV byte ptr [EAX + 0x1],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,CH",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "XOR EBX,EBX",
            "MOV byte ptr [EAX + 0x2],DL",
            "MOV EDX,dword ptr [EBP + -0x8]",
            "AND EDX,ESI",
            "MOV BL,byte ptr [EBP + -0x9]",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x3],DL",
            "MOV EDX,dword ptr [EDI + 0x4]",
            "MOV BL,byte ptr [EBX + 0x4089fc]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EDX,0x18",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x12]",
            "MOV byte ptr [EAX + 0x4],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "SAR EBX,0x10",
            "XOR DL,BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x5],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x7]",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "XOR EBX,EBX",
            "MOV byte ptr [EAX + 0x6],DL",
            "MOV EDX,dword ptr [EBP + -0x10]",
            "AND EDX,ESI",
            "MOV BL,byte ptr [EBP + -0x11]",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x7],DL",
            "MOV EDX,dword ptr [EDI + 0x8]",
            "MOV BL,byte ptr [EBX + 0x4089fc]",
            "MOV dword ptr [EBP + -0x4],EDX",
            "SAR EDX,0x18",
            "XOR BL,DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0x6]",
            "MOV byte ptr [EAX + 0x8],BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "SAR EBX,0x10",
            "XOR DL,BL",
            "MOV EBX,dword ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0x9],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xf]",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "MOV byte ptr [EAX + 0xa],DL",
            "MOV EDX,dword ptr [EBP + -0xc]",
            "AND ECX,ESI",
            "AND EDX,ESI",
            "POP ESI",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,byte ptr [EBP + -0x4]",
            "MOV byte ptr [EAX + 0xb],DL",
            "MOV EDI,dword ptr [EDI + 0xc]",
            "XOR EDX,EDX",
            "MOV EBX,EDI",
            "MOV DL,byte ptr [EBP + -0x5]",
            "MOV dword ptr [EBP + -0x4],EDI",
            "SAR EBX,0x18",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "MOV EBX,EDI",
            "MOV byte ptr [EAX + 0xc],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xe]",
            "SAR EBX,0x10",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "MOV EBX,EDI",
            "MOV byte ptr [EAX + 0xd],DL",
            "XOR EDX,EDX",
            "MOV DL,byte ptr [EBP + -0xb]",
            "SAR EBX,0x8",
            "MOV DL,byte ptr [EDX + 0x4089fc]",
            "XOR DL,BL",
            "POP EBX",
            "MOV byte ptr [EAX + 0xe],DL",
            "MOV CL,byte ptr [ECX + 0x4089fc]",
            "XOR CL,byte ptr [EBP + -0x4]",
            "POP EDI",
            "MOV byte ptr [EAX + 0xf],CL",
            "LEAVE",
            "RET 0x8"
        ],
        "function_address": {
            "start": "00002e7e",
            "end": "000031bb"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002f4c",
                    "0000302c",
                    "00003031",
                    "000030a7",
                    "00002f63",
                    "000030ea",
                    "00002f9b",
                    "00003124",
                    "00002fdb",
                    "0000316c"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002f3e",
                    "00003050"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002e95",
                    "00002e9e"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002f5c",
                    "00003044",
                    "00003068",
                    "00003092",
                    "000030b5",
                    "000030c4",
                    "000030d4",
                    "000030e2",
                    "0000310b",
                    "0000311a",
                    "0000312a",
                    "00003138",
                    "0000315f",
                    "0000316f",
                    "000031b1"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002f26",
                    "00002fd6",
                    "0000303b",
                    "0000303e",
                    "00002f66",
                    "000030ce",
                    "00002f89",
                    "00003102"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002f00",
                    "00002fb0",
                    "00003016",
                    "00003151",
                    "00002fd3",
                    "00003199",
                    "00003009",
                    "0000307f",
                    "00002f79",
                    "000030ac"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002e87",
                    "00003053"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00002ee0",
                    "00003047",
                    "000030fd",
                    "00003140",
                    "00002fee",
                    "00003184",
                    "00003022",
                    "00003065"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00002e7e",
        "original_name": "FUN_00002e7e",
        "predicted_name": "decrypt_aes_128_cbc.",
        "prediction_full_response": "The predicted function name is decrypt_aes_128_cbc.</s>"
    },
    "00007656": {
        "decomp_code": "\nundefined4 FUN_00007656(int *param_1)\n\n{\n  void *pvVar1;\n  \n  if (param_1 == (int *)0x0) {\n    uRam0040f938 = 0x10000;\n  }\n  else {\n    if (*param_1 == 1) {\n      pvVar1 = (void *)param_1[1];\n      uRam0040f938 = FUN_0000747b();\n      if (pvVar1 != (void *)0x0) {\n        FUN_00007572();\n        operator_delete(pvVar1);\n      }\n      operator_delete(param_1);\n      return uRam0040f938;\n    }\n    uRam0040f938 = 0x80000;\n  }\n  return uRam0040f938;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EDI",
            "MOV EDI,dword ptr [ESP + 0x8]",
            "TEST EDI,EDI",
            "JNZ 0x00007666",
            "MOV EAX,0x10000",
            "JMP 0x00007670",
            "CMP dword ptr [EDI],0x1",
            "JZ 0x00007677",
            "MOV EAX,0x80000",
            "MOV [0x0040f938],EAX",
            "POP EDI",
            "RET",
            "PUSH ESI",
            "MOV ESI,dword ptr [EDI + 0x4]",
            "MOV ECX,ESI",
            "CALL 0x0000747b",
            "TEST ESI,ESI",
            "MOV [0x0040f938],EAX",
            "JZ 0x00007699",
            "MOV ECX,ESI",
            "CALL 0x00007572",
            "PUSH ESI",
            "CALL 0x000076e8",
            "POP ECX",
            "PUSH EDI",
            "CALL 0x000076e8",
            "MOV EAX,[0x0040f938]",
            "POP ECX",
            "POP ESI",
            "POP EDI",
            "RET"
        ],
        "function_address": {
            "start": "00007656",
            "end": "000076a7"
        },
        "variable_metadata": {},
        "func_name": "FUN_00007656",
        "original_name": "FUN_00007656",
        "predicted_name": "operator_new",
        "prediction_full_response": "The predicted function name is operator_new</s>"
    },
    "00003cc8": {
        "decomp_code": "\nvoid FUN_00003cc8(undefined1 param_1,undefined1 param_2,undefined4 param_3,undefined4 param_4,\n                 int param_5)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)(**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),1,0x1c);\n  if (puVar1 != (undefined4 *)0x0) {\n    *puVar1 = 0;\n    *(undefined1 *)(puVar1 + 4) = param_1;\n    *(undefined1 *)((int)puVar1 + 0x11) = param_2;\n    puVar1[5] = param_3;\n    puVar1[6] = param_4;\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV EAX,dword ptr [EBP + 0x18]",
            "PUSH 0x1c",
            "PUSH 0x1",
            "PUSH dword ptr [EAX + 0x28]",
            "CALL dword ptr [EAX + 0x20]",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x00003cfa",
            "MOV CL,byte ptr [EBP + 0x8]",
            "AND dword ptr [EAX],0x0",
            "MOV byte ptr [EAX + 0x10],CL",
            "MOV CL,byte ptr [EBP + 0xc]",
            "MOV byte ptr [EAX + 0x11],CL",
            "MOV ECX,dword ptr [EBP + 0x10]",
            "MOV dword ptr [EAX + 0x14],ECX",
            "MOV ECX,dword ptr [EBP + 0x14]",
            "MOV dword ptr [EAX + 0x18],ECX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00003cc8",
            "end": "00003cfb"
        },
        "variable_metadata": {},
        "func_name": "FUN_00003cc8",
        "original_name": "FUN_00003cc8",
        "predicted_name": "lib_set_error_handler.",
        "prediction_full_response": "The predicted function name is lib_set_error_handler.</s>"
    },
    "0000170a": {
        "decomp_code": "\nundefined4 FUN_0000170a(void)\n\n{\n  code *pcVar1;\n  int iVar2;\n  \n  iVar2 = FUN_00001a45();\n  if (iVar2 != 0) {\n    if (iRam0040f878 != 0) {\n      return 1;\n    }\n    iVar2 = (*pcRam004080e0)(0x40ebe8);\n    pcVar1 = pcRam004080e4;\n    if (iVar2 != 0) {\n      iRam0040f878 = (*pcRam004080e4)(iVar2,0x40ebdc);\n      iRam0040f87c = (*pcVar1)(iVar2,0x40ebd0);\n      iRam0040f880 = (*pcVar1)(iVar2,0x40ebc4);\n      iRam0040f884 = (*pcVar1)(iVar2,0x40ebb8);\n      iRam0040f888 = (*pcVar1)(iVar2,0x40ebac);\n      iRam0040f88c = (*pcVar1)(iVar2,0x40eba0);\n      iRam0040f890 = (*pcVar1)(iVar2,0x40eb94);\n      if ((((iRam0040f878 != 0) && (iRam0040f87c != 0)) && (iRam0040f880 != 0)) &&\n         (((iRam0040f884 != 0 && (iRam0040f888 != 0)) &&\n          ((iRam0040f88c != 0 && (iRam0040f890 != 0)))))) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "PUSH EDI",
            "CALL 0x00001a45",
            "TEST EAX,EAX",
            "JZ 0x000017d8",
            "XOR EBX,EBX",
            "CMP dword ptr [0x0040f878],EBX",
            "JNZ 0x000017d3",
            "PUSH 0x40ebe8",
            "CALL dword ptr [0x004080e0]",
            "MOV EDI,EAX",
            "CMP EDI,EBX",
            "JZ 0x000017d8",
            "PUSH ESI",
            "MOV ESI,dword ptr [0x004080e4]",
            "PUSH 0x40ebdc",
            "PUSH EDI",
            "CALL ESI",
            "PUSH 0x40ebd0",
            "PUSH EDI",
            "MOV [0x0040f878],EAX",
            "CALL ESI",
            "PUSH 0x40ebc4",
            "PUSH EDI",
            "MOV [0x0040f87c],EAX",
            "CALL ESI",
            "PUSH 0x40ebb8",
            "PUSH EDI",
            "MOV [0x0040f880],EAX",
            "CALL ESI",
            "PUSH 0x40ebac",
            "PUSH EDI",
            "MOV [0x0040f884],EAX",
            "CALL ESI",
            "PUSH 0x40eba0",
            "PUSH EDI",
            "MOV [0x0040f888],EAX",
            "CALL ESI",
            "PUSH 0x40eb94",
            "PUSH EDI",
            "MOV [0x0040f88c],EAX",
            "CALL ESI",
            "CMP dword ptr [0x0040f878],EBX",
            "MOV [0x0040f890],EAX",
            "POP ESI",
            "JZ 0x000017d8",
            "CMP dword ptr [0x0040f87c],EBX",
            "JZ 0x000017d8",
            "CMP dword ptr [0x0040f880],EBX",
            "JZ 0x000017d8",
            "CMP dword ptr [0x0040f884],EBX",
            "JZ 0x000017d8",
            "CMP dword ptr [0x0040f888],EBX",
            "JZ 0x000017d8",
            "CMP dword ptr [0x0040f88c],EBX",
            "JZ 0x000017d8",
            "CMP EAX,EBX",
            "JZ 0x000017d8",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x000017da",
            "XOR EAX,EAX",
            "POP EDI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "0000170a",
            "end": "000017dc"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000170a",
        "original_name": "FUN_0000170a",
        "predicted_name": "FUN_00001a45.",
        "prediction_full_response": "The predicted function name is FUN_00001a45.</s>"
    },
    "000076fa": {
        "decomp_code": "\nvoid __cdecl local_unwind2(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000076fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*pcRam0040814c)();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x0040814c]"
        ],
        "function_address": {
            "start": "000076fa",
            "end": "000076ff"
        },
        "variable_metadata": {},
        "func_name": "local_unwind2",
        "original_name": "local_unwind2",
        "predicted_name": "SYS_Reset",
        "prediction_full_response": "The predicted function name is SYS_Reset</s>"
    },
    "00007780": {
        "decomp_code": "\n/* Library Function - Single Match\n    __allmul\n   \n   Library: Visual Studio */\n\nlonglong __allmul(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if (param_4 == 0 && param_2 == 0) {\n    return (ulonglong)param_1 * (ulonglong)param_3;\n  }\n  return CONCAT44((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +\n                  param_2 * param_3 + param_1 * param_4,\n                  (int)((ulonglong)param_1 * (ulonglong)param_3));\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x8]",
            "MOV ECX,dword ptr [ESP + 0x10]",
            "OR ECX,EAX",
            "MOV ECX,dword ptr [ESP + 0xc]",
            "JNZ 0x00007799",
            "MOV EAX,dword ptr [ESP + 0x4]",
            "MUL ECX",
            "RET 0x10",
            "PUSH EBX",
            "MUL ECX",
            "MOV EBX,EAX",
            "MOV EAX,dword ptr [ESP + 0x8]",
            "MUL dword ptr [ESP + 0x14]",
            "ADD EBX,EAX",
            "MOV EAX,dword ptr [ESP + 0x8]",
            "MUL ECX",
            "ADD EDX,EBX",
            "POP EBX",
            "RET 0x10"
        ],
        "function_address": {
            "start": "00007780",
            "end": "000077b3"
        },
        "variable_metadata": {},
        "func_name": "__allmul",
        "original_name": "__allmul",
        "predicted_name": "__allmul.",
        "prediction_full_response": "The predicted function name is __allmul.</s>"
    },
    "00007940": {
        "decomp_code": "\nuint __cdecl _controlfp(uint _NewValue,uint _Mask)\n\n{\n  uint uVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007940. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  uVar1 = (*pcRam004081c8)();\n  return uVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x004081c8]"
        ],
        "function_address": {
            "start": "00007940",
            "end": "00007945"
        },
        "variable_metadata": {
            "_NewValue": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            },
            "_Mask": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            }
        },
        "func_name": "_controlfp",
        "original_name": "_controlfp",
        "predicted_name": "Get_Ram_Value",
        "prediction_full_response": "The predicted function name is Get_Ram_Value</s>"
    },
    "00005122": {
        "decomp_code": "\nundefined4\nFUN_00005122(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined4 *param_4)\n\n{\n  *param_1 = 9;\n  *param_2 = 5;\n  *param_3 = 0x40bcf0;\n  *param_4 = 0x40ccf0;\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "MOV dword ptr [EAX],0x9",
            "MOV EAX,dword ptr [ESP + 0x8]",
            "MOV dword ptr [EAX],0x5",
            "MOV EAX,dword ptr [ESP + 0xc]",
            "MOV dword ptr [EAX],0x40bcf0",
            "MOV EAX,dword ptr [ESP + 0x10]",
            "MOV dword ptr [EAX],0x40ccf0",
            "XOR EAX,EAX",
            "RET"
        ],
        "function_address": {
            "start": "00005122",
            "end": "0000514c"
        },
        "variable_metadata": {},
        "func_name": "FUN_00005122",
        "original_name": "FUN_00005122",
        "predicted_name": "get_symbol_info",
        "prediction_full_response": "The predicted function name is get_symbol_info</s>"
    },
    "000055c4": {
        "decomp_code": "\nuint FUN_000055c4(uint param_1,byte *param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  int iVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  int iVar18;\n  \n  uVar3 = param_1 & 0xffff;\n  param_1 = param_1 >> 0x10;\n  if (param_2 == (byte *)0x0) {\n    uVar3 = 1;\n  }\n  else {\n    if (param_3 != 0) {\n      do {\n        uVar2 = 0x15b0;\n        if (param_3 < 0x15b0) {\n          uVar2 = param_3;\n        }\n        param_3 = param_3 - uVar2;\n        if (0xf < (int)uVar2) {\n          uVar1 = uVar2 >> 4;\n          uVar2 = uVar2 + uVar1 * -0x10;\n          do {\n            iVar4 = uVar3 + *param_2;\n            iVar5 = iVar4 + (uint)param_2[1];\n            iVar6 = iVar5 + (uint)param_2[2];\n            iVar7 = iVar6 + (uint)param_2[3];\n            iVar8 = iVar7 + (uint)param_2[4];\n            iVar9 = iVar8 + (uint)param_2[5];\n            iVar10 = iVar9 + (uint)param_2[6];\n            iVar11 = iVar10 + (uint)param_2[7];\n            iVar12 = iVar11 + (uint)param_2[8];\n            iVar13 = iVar12 + (uint)param_2[9];\n            iVar14 = iVar13 + (uint)param_2[10];\n            iVar15 = iVar14 + (uint)param_2[0xb];\n            iVar16 = iVar15 + (uint)param_2[0xc];\n            iVar17 = iVar16 + (uint)param_2[0xd];\n            iVar18 = iVar17 + (uint)param_2[0xe];\n            uVar3 = iVar18 + (uint)param_2[0xf];\n            param_1 = param_1 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 +\n                      iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;\n            param_2 = param_2 + 0x10;\n            uVar1 = uVar1 - 1;\n          } while (uVar1 != 0);\n        }\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n          uVar3 = uVar3 + *param_2;\n          param_2 = param_2 + 1;\n          param_1 = param_1 + uVar3;\n        }\n        uVar3 = uVar3 % 0xfff1;\n        param_1 = param_1 % 0xfff1;\n      } while (param_3 != 0);\n    }\n    uVar3 = param_1 << 0x10 | uVar3;\n  }\n  return uVar3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "MOV ESI,EDI",
            "AND ESI,0xffff",
            "SHR EDI,0x10",
            "TEST ECX,ECX",
            "JNZ 0x000055e6",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x000056d9",
            "CMP dword ptr [EBP + 0x10],0x0",
            "JBE 0x000056d2",
            "PUSH EBX",
            "MOV EDX,0x15b0",
            "CMP dword ptr [EBP + 0x10],EDX",
            "JNC 0x000055fe",
            "MOV EDX,dword ptr [EBP + 0x10]",
            "SUB dword ptr [EBP + 0x10],EDX",
            "CMP EDX,0x10",
            "JL 0x000056a1",
            "MOV EAX,EDX",
            "SHR EAX,0x4",
            "MOV EBX,EAX",
            "NEG EBX",
            "SHL EBX,0x4",
            "ADD EDX,EBX",
            "MOVZX EBX,byte ptr [ECX]",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x1]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x2]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x3]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x4]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x5]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x6]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x7]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x8]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0x9]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xa]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xb]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xc]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xd]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xe]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "MOVZX EBX,byte ptr [ECX + 0xf]",
            "ADD EDI,ESI",
            "ADD ESI,EBX",
            "ADD EDI,ESI",
            "ADD ECX,0x10",
            "DEC EAX",
            "JNZ 0x00005618",
            "TEST EDX,EDX",
            "JZ 0x000056b0",
            "MOVZX EAX,byte ptr [ECX]",
            "ADD ESI,EAX",
            "INC ECX",
            "ADD EDI,ESI",
            "DEC EDX",
            "JNZ 0x000056a5",
            "MOV EBX,0xfff1",
            "MOV EAX,ESI",
            "XOR EDX,EDX",
            "MOV ESI,EBX",
            "DIV ESI",
            "MOV EAX,EDI",
            "MOV ESI,EDX",
            "XOR EDX,EDX",
            "DIV EBX",
            "CMP dword ptr [EBP + 0x10],0x0",
            "MOV EDI,EDX",
            "JA 0x000055f1",
            "POP EBX",
            "MOV EAX,EDI",
            "SHL EAX,0x10",
            "OR EAX,ESI",
            "POP EDI",
            "POP ESI",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "000055c4",
            "end": "000056dc"
        },
        "variable_metadata": {},
        "func_name": "FUN_000055c4",
        "original_name": "FUN_000055c4",
        "predicted_name": "crc32_be.",
        "prediction_full_response": "The predicted function name is crc32_be.</s>"
    },
    "00001a45": {
        "decomp_code": "\nundefined4 FUN_00001a45(void)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 uVar3;\n  \n  if (iRam0040f894 == 0) {\n    iVar2 = (*pcRam004080e0)(0x40e020);\n    pcVar1 = pcRam004080e4;\n    if (iVar2 != 0) {\n      iRam0040f894 = (*pcRam004080e4)(iVar2,0x40f110);\n      iRam0040f898 = (*pcVar1)(iVar2,0x40f100);\n      iRam0040f89c = (*pcVar1)(iVar2,0x40f0f0);\n      iRam0040f8a0 = (*pcVar1)(iVar2,0x40f0e0);\n      iRam0040f8a4 = (*pcVar1)(iVar2,0x40f0d0);\n      iRam0040f8a8 = (*pcVar1)(iVar2,0x40f0c4);\n      if ((((iRam0040f894 != 0) && (iRam0040f898 != 0)) && (iRam0040f89c != 0)) &&\n         (((iRam0040f8a0 != 0 && (iRam0040f8a4 != 0)) && (iRam0040f8a8 != 0)))) goto LAB_00001aec;\n    }\n    uVar3 = 0;\n  }\n  else {\nLAB_00001aec:\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "XOR EBX,EBX",
            "CMP dword ptr [0x0040f894],EBX",
            "PUSH EDI",
            "JNZ 0x00001aec",
            "PUSH 0x40e020",
            "CALL dword ptr [0x004080e0]",
            "MOV EDI,EAX",
            "CMP EDI,EBX",
            "JZ 0x00001af1",
            "PUSH ESI",
            "MOV ESI,dword ptr [0x004080e4]",
            "PUSH 0x40f110",
            "PUSH EDI",
            "CALL ESI",
            "PUSH 0x40f100",
            "PUSH EDI",
            "MOV [0x0040f894],EAX",
            "CALL ESI",
            "PUSH 0x40f0f0",
            "PUSH EDI",
            "MOV [0x0040f898],EAX",
            "CALL ESI",
            "PUSH 0x40f0e0",
            "PUSH EDI",
            "MOV [0x0040f89c],EAX",
            "CALL ESI",
            "PUSH 0x40f0d0",
            "PUSH EDI",
            "MOV [0x0040f8a0],EAX",
            "CALL ESI",
            "PUSH 0x40f0c4",
            "PUSH EDI",
            "MOV [0x0040f8a4],EAX",
            "CALL ESI",
            "CMP dword ptr [0x0040f894],EBX",
            "MOV [0x0040f8a8],EAX",
            "POP ESI",
            "JZ 0x00001af1",
            "CMP dword ptr [0x0040f898],EBX",
            "JZ 0x00001af1",
            "CMP dword ptr [0x0040f89c],EBX",
            "JZ 0x00001af1",
            "CMP dword ptr [0x0040f8a0],EBX",
            "JZ 0x00001af1",
            "CMP dword ptr [0x0040f8a4],EBX",
            "JZ 0x00001af1",
            "CMP EAX,EBX",
            "JZ 0x00001af1",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x00001af3",
            "XOR EAX,EAX",
            "POP EDI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "00001a45",
            "end": "00001af5"
        },
        "variable_metadata": {},
        "func_name": "FUN_00001a45",
        "original_name": "FUN_00001a45",
        "predicted_name": "init_ram_for_test",
        "prediction_full_response": "The predicted function name is init_ram_for_test</s>"
    },
    "000043b6": {
        "decomp_code": "\nvoid FUN_000043b6(uint *param_1,int *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  \n  uVar1 = param_1[0xd];\n  iVar2 = param_2[1];\n  iVar3 = *param_2;\n  if (*param_1 < 10) {\n                    /* WARNING: Could not emulate address calculation at 0x00004408 */\n                    /* WARNING: Treating indirect jump as call */\n    (**(code **)(*param_1 * 4 + 0x404bbd))();\n    return;\n  }\n  param_1[8] = param_1[8];\n  param_1[7] = param_1[7];\n  param_2[1] = iVar2;\n  iVar2 = *param_2;\n  *param_2 = iVar3;\n  param_2[2] = param_2[2] + (iVar3 - iVar2);\n  param_1[0xd] = uVar1;\n  FUN_00003bd6(param_1,param_2,0xfffffffe);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x2c",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0xc]",
            "MOV EDX,dword ptr [ESI + 0x34]",
            "MOV EAX,dword ptr [EDI + 0x4]",
            "MOV EBX,dword ptr [EDI]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [ESI + 0x20]",
            "MOV dword ptr [EBP + 0x8],EAX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [ESI + 0x30]",
            "CMP EDX,EAX",
            "MOV dword ptr [EBP + -0x8],EDX",
            "JNC 0x000043ed",
            "SUB EAX,EDX",
            "DEC EAX",
            "MOV ECX,EAX",
            "JMP 0x000043f2",
            "MOV ECX,dword ptr [ESI + 0x2c]",
            "SUB ECX,EDX",
            "MOV EAX,dword ptr [ESI]",
            "MOV dword ptr [EBP + -0x10],ECX",
            "CMP EAX,0x9",
            "JA 0x000049c2",
            "JMP 0x00004408",
            "MOV ECX,dword ptr [EBP + -0x10]",
            "MOV EDX,dword ptr [EBP + -0x8]",
            "JMP dword ptr [EAX*0x4 + 0x404bbd]",
            "CMP dword ptr [EBP + 0xc],0x3",
            "JNC 0x00004438",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EAX,byte ptr [EBX]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x8],EAX",
            "INC EBX",
            "ADD dword ptr [EBP + 0xc],0x8",
            "JMP 0x0000440f",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "AND EAX,0x7",
            "MOV ECX,EAX",
            "SHR EAX,0x1",
            "AND ECX,0x1",
            "SUB EAX,0x0",
            "MOV dword ptr [ESI + 0x18],ECX",
            "JZ 0x000044b9",
            "DEC EAX",
            "JZ 0x00004470",
            "DEC EAX",
            "JZ 0x0000445f",
            "DEC EAX",
            "JZ 0x000049f4",
            "JMP 0x000049b7",
            "SHR dword ptr [EBP + 0x8],0x3",
            "PUSH 0x3",
            "POP EAX",
            "SUB dword ptr [EBP + 0xc],EAX",
            "MOV dword ptr [ESI],EAX",
            "JMP 0x000049b7",
            "LEA EAX,[EBP + -0x18]",
            "PUSH EDI",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x20]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x24]",
            "PUSH EAX",
            "CALL 0x00005122",
            "PUSH EDI",
            "PUSH dword ptr [EBP + -0x18]",
            "PUSH dword ptr [EBP + -0x1c]",
            "PUSH dword ptr [EBP + -0x20]",
            "PUSH dword ptr [EBP + -0x24]",
            "CALL 0x00003cc8",
            "ADD ESP,0x28",
            "MOV dword ptr [ESI + 0x4],EAX",
            "TEST EAX,EAX",
            "JZ 0x00004b1c",
            "SHR dword ptr [EBP + 0x8],0x3",
            "SUB dword ptr [EBP + 0xc],0x3",
            "MOV dword ptr [ESI],0x6",
            "JMP 0x000049b7",
            "SUB dword ptr [EBP + 0xc],0x3",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI],0x1",
            "AND ECX,0x7",
            "SHR EAX,0x3",
            "SHR EAX,CL",
            "SUB dword ptr [EBP + 0xc],ECX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JMP 0x000049b7",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "CMP ECX,0x20",
            "JNC 0x00004506",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EAX,byte ptr [EBX]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x8],EAX",
            "INC EBX",
            "ADD ECX,0x8",
            "MOV dword ptr [EBP + 0xc],ECX",
            "JMP 0x000044df",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "NOT ECX",
            "AND EAX,0xffff",
            "SHR ECX,0x10",
            "XOR ECX,EAX",
            "JNZ 0x00004a12",
            "MOV dword ptr [ESI + 0x4],EAX",
            "XOR EAX,EAX",
            "CMP dword ptr [ESI + 0x4],EAX",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JZ 0x0000461c",
            "PUSH 0x2",
            "POP EAX",
            "JMP 0x00004469",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "TEST ECX,ECX",
            "JNZ 0x000045d7",
            "MOV ECX,dword ptr [ESI + 0x2c]",
            "CMP EDX,ECX",
            "JNZ 0x00004575",
            "MOV EAX,dword ptr [ESI + 0x30]",
            "MOV EDX,dword ptr [ESI + 0x28]",
            "CMP EDX,EAX",
            "JZ 0x00004575",
            "MOV dword ptr [EBP + -0x8],EDX",
            "JNC 0x0000456a",
            "SUB EAX,EDX",
            "DEC EAX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JMP 0x0000456f",
            "SUB ECX,EDX",
            "MOV dword ptr [EBP + -0x10],ECX",
            "CMP dword ptr [EBP + -0x10],0x0",
            "JNZ 0x000045d7",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x00003bd6",
            "MOV ECX,dword ptr [ESI + 0x30]",
            "MOV dword ptr [EBP + 0x10],EAX",
            "MOV EAX,dword ptr [ESI + 0x34]",
            "ADD ESP,0xc",
            "CMP EAX,ECX",
            "MOV dword ptr [EBP + -0x8],EAX",
            "JNC 0x000045a3",
            "MOV EAX,ECX",
            "SUB EAX,dword ptr [EBP + -0x8]",
            "DEC EAX",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JMP 0x000045ac",
            "MOV EDX,dword ptr [ESI + 0x2c]",
            "SUB EDX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [EBP + -0x10],EDX",
            "MOV EDX,dword ptr [ESI + 0x2c]",
            "CMP dword ptr [EBP + -0x8],EDX",
            "JNZ 0x000045cd",
            "MOV EAX,dword ptr [ESI + 0x28]",
            "CMP EAX,ECX",
            "JZ 0x000045cd",
            "MOV dword ptr [EBP + -0x8],EAX",
            "JNC 0x000045c8",
            "SUB ECX,EAX",
            "DEC ECX",
            "MOV dword ptr [EBP + -0x10],ECX",
            "JMP 0x000045cd",
            "SUB EDX,EAX",
            "MOV dword ptr [EBP + -0x10],EDX",
            "CMP dword ptr [EBP + -0x10],0x0",
            "JZ 0x00004a44",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "AND dword ptr [EBP + 0x10],0x0",
            "CMP EAX,ECX",
            "MOV dword ptr [EBP + -0xc],EAX",
            "JBE 0x000045eb",
            "MOV dword ptr [EBP + -0xc],ECX",
            "MOV EAX,dword ptr [EBP + -0x10]",
            "CMP dword ptr [EBP + -0xc],EAX",
            "JBE 0x000045f6",
            "MOV dword ptr [EBP + -0xc],EAX",
            "PUSH dword ptr [EBP + -0xc]",
            "PUSH EBX",
            "PUSH dword ptr [EBP + -0x8]",
            "CALL 0x00007706",
            "MOV EAX,dword ptr [EBP + -0xc]",
            "ADD ESP,0xc",
            "SUB dword ptr [EBP + -0x4],EAX",
            "ADD dword ptr [EBP + -0x8],EAX",
            "SUB dword ptr [EBP + -0x10],EAX",
            "ADD EBX,EAX",
            "SUB dword ptr [ESI + 0x4],EAX",
            "JNZ 0x000049b7",
            "MOV EAX,dword ptr [ESI + 0x18]",
            "NEG EAX",
            "SBB EAX,EAX",
            "AND EAX,0x7",
            "JMP 0x00004469",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "CMP ECX,0xe",
            "JNC 0x00004655",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EAX,byte ptr [EBX]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x8],EAX",
            "INC EBX",
            "ADD ECX,0x8",
            "MOV dword ptr [EBP + 0xc],ECX",
            "JMP 0x0000462e",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "AND EAX,0x3fff",
            "MOV ECX,EAX",
            "MOV dword ptr [ESI + 0x4],EAX",
            "AND ECX,0x1f",
            "CMP ECX,0x1d",
            "JA 0x00004a7f",
            "MOV EDX,EAX",
            "AND EDX,0x3e0",
            "CMP EDX,0x3a0",
            "JA 0x00004a7f",
            "SHR EAX,0x5",
            "AND EAX,0x1f",
            "PUSH 0x4",
            "LEA EAX,[EAX + ECX*0x1 + 0x102]",
            "PUSH EAX",
            "PUSH dword ptr [EDI + 0x28]",
            "CALL dword ptr [EDI + 0x20]",
            "ADD ESP,0xc",
            "MOV dword ptr [ESI + 0xc],EAX",
            "TEST EAX,EAX",
            "JZ 0x00004b1c",
            "SHR dword ptr [EBP + 0x8],0xe",
            "SUB dword ptr [EBP + 0xc],0xe",
            "AND dword ptr [ESI + 0x8],0x0",
            "MOV dword ptr [ESI],0x4",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "SHR EAX,0xa",
            "ADD EAX,0x4",
            "CMP dword ptr [ESI + 0x8],EAX",
            "JNC 0x00004721",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "CMP ECX,0x3",
            "JNC 0x000046f0",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EAX,byte ptr [EBX]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EAX,CL",
            "OR dword ptr [EBP + 0x8],EAX",
            "INC EBX",
            "ADD ECX,0x8",
            "MOV dword ptr [EBP + 0xc],ECX",
            "JMP 0x000046c9",
            "MOV ECX,dword ptr [ESI + 0x8]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV EDX,dword ptr [ESI + 0xc]",
            "AND EAX,0x7",
            "MOV ECX,dword ptr [ECX*0x4 + 0x40cdf0]",
            "SUB dword ptr [EBP + 0xc],0x3",
            "SHR dword ptr [EBP + 0x8],0x3",
            "MOV dword ptr [EDX + ECX*0x4],EAX",
            "MOV ECX,dword ptr [ESI + 0x4]",
            "INC dword ptr [ESI + 0x8]",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "SHR ECX,0xa",
            "ADD ECX,0x4",
            "CMP EAX,ECX",
            "JC 0x000046c6",
            "CMP dword ptr [ESI + 0x8],0x13",
            "JNC 0x0000473d",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "MOV ECX,dword ptr [ESI + 0xc]",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40cdf0]",
            "AND dword ptr [ECX + EAX*0x4],0x0",
            "INC dword ptr [ESI + 0x8]",
            "JMP 0x00004721",
            "PUSH EDI",
            "LEA ECX,[ESI + 0x14]",
            "PUSH dword ptr [ESI + 0x24]",
            "LEA EAX,[ESI + 0x10]",
            "PUSH ECX",
            "PUSH EAX",
            "PUSH dword ptr [ESI + 0xc]",
            "MOV dword ptr [EAX],0x7",
            "CALL 0x00004fa0",
            "ADD ESP,0x14",
            "MOV dword ptr [EBP + -0xc],EAX",
            "TEST EAX,EAX",
            "JNZ 0x00004a8e",
            "AND dword ptr [ESI + 0x8],EAX",
            "MOV dword ptr [ESI],0x5",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV ECX,dword ptr [ESI + 0x8]",
            "MOV EDX,EAX",
            "AND EAX,0x1f",
            "SHR EDX,0x5",
            "AND EDX,0x1f",
            "LEA EAX,[EDX + EAX*0x1 + 0x102]",
            "CMP ECX,EAX",
            "JNC 0x000048b2",
            "MOV EAX,dword ptr [ESI + 0x10]",
            "CMP dword ptr [EBP + 0xc],EAX",
            "JNC 0x000047b9",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EDX,byte ptr [EBX]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EDX,CL",
            "OR dword ptr [EBP + 0x8],EDX",
            "INC EBX",
            "ADD dword ptr [EBP + 0xc],0x8",
            "JMP 0x00004791",
            "MOV EAX,dword ptr [EAX*0x4 + 0x40bca8]",
            "MOV ECX,dword ptr [ESI + 0x14]",
            "AND EAX,dword ptr [EBP + 0x8]",
            "MOV EDX,dword ptr [ECX + EAX*0x8 + 0x4]",
            "LEA EAX,[ECX + EAX*0x8]",
            "CMP EDX,0x10",
            "MOV dword ptr [EBP + -0x14],EDX",
            "MOVZX ECX,byte ptr [EAX + 0x1]",
            "MOV dword ptr [EBP + -0xc],ECX",
            "JNC 0x000047f5",
            "SHR dword ptr [EBP + 0x8],CL",
            "MOV EAX,ECX",
            "MOV ECX,dword ptr [ESI + 0xc]",
            "SUB dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "MOV dword ptr [ECX + EAX*0x4],EDX",
            "INC dword ptr [ESI + 0x8]",
            "JMP 0x0000476e",
            "CMP EDX,0x12",
            "JNZ 0x000047ff",
            "PUSH 0x7",
            "POP EAX",
            "JMP 0x00004802",
            "LEA EAX,[EDX + -0xe]",
            "XOR ECX,ECX",
            "CMP EDX,0x12",
            "SETNZ CL",
            "DEC ECX",
            "AND ECX,0x8",
            "ADD ECX,0x3",
            "MOV dword ptr [EBP + -0x10],ECX",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "LEA EDX,[EAX + ECX*0x1]",
            "CMP dword ptr [EBP + 0xc],EDX",
            "JNC 0x00004842",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x00004a58",
            "MOVZX EDX,byte ptr [EBX]",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "AND dword ptr [EBP + 0x10],0x0",
            "DEC dword ptr [EBP + -0x4]",
            "SHL EDX,CL",
            "OR dword ptr [EBP + 0x8],EDX",
            "INC EBX",
            "ADD dword ptr [EBP + 0xc],0x8",
            "JMP 0x00004814",
            "SHR dword ptr [EBP + 0x8],CL",
            "MOV ECX,dword ptr [EAX*0x4 + 0x40bca8]",
            "AND ECX,dword ptr [EBP + 0x8]",
            "ADD dword ptr [EBP + -0x10],ECX",
            "MOV ECX,EAX",
            "SHR dword ptr [EBP + 0x8],CL",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "ADD EAX,ECX",
            "MOV ECX,dword ptr [ESI + 0x8]",
            "SUB dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "MOV EDX,EAX",
            "AND EAX,0x1f",
            "SHR EDX,0x5",
            "AND EDX,0x1f",
            "LEA EAX,[EDX + EAX*0x1 + 0x102]",
            "MOV EDX,dword ptr [EBP + -0x10]",
            "ADD EDX,ECX",
            "CMP EDX,EAX",
            "JA 0x00004a94",
            "CMP dword ptr [EBP + -0x14],0x10",
            "JNZ 0x0000489c",
            "CMP ECX,0x1",
            "JC 0x00004a94",
            "MOV EAX,dword ptr [ESI + 0xc]",
            "MOV EAX,dword ptr [EAX + ECX*0x4 + -0x4]",
            "JMP 0x0000489e",
            "XOR EAX,EAX",
            "MOV EDX,dword ptr [ESI + 0xc]",
            "MOV dword ptr [EDX + ECX*0x4],EAX",
            "INC ECX",
            "DEC dword ptr [EBP + -0x10]",
            "JNZ 0x0000489e",
            "MOV dword ptr [ESI + 0x8],ECX",
            "JMP 0x0000476e",
            "PUSH EDI",
            "LEA ECX,[EBP + -0x28]",
            "PUSH dword ptr [ESI + 0x24]",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "AND dword ptr [ESI + 0x14],0x0",
            "MOV dword ptr [EBP + -0x14],0x9",
            "PUSH ECX",
            "LEA ECX,[EBP + -0x2c]",
            "PUSH ECX",
            "LEA ECX,[EBP + -0x10]",
            "PUSH ECX",
            "LEA ECX,[EBP + -0x14]",
            "PUSH ECX",
            "MOV ECX,EAX",
            "PUSH dword ptr [ESI + 0xc]",
            "AND EAX,0x1f",
            "SHR ECX,0x5",
            "AND ECX,0x1f",
            "ADD EAX,0x101",
            "INC ECX",
            "MOV dword ptr [EBP + -0x10],0x6",
            "PUSH ECX",
            "PUSH EAX",
            "CALL 0x0000501f",
            "ADD ESP,0x24",
            "MOV dword ptr [EBP + -0xc],EAX",
            "TEST EAX,EAX",
            "JNZ 0x00004adc",
            "PUSH EDI",
            "PUSH dword ptr [EBP + -0x28]",
            "PUSH dword ptr [EBP + -0x2c]",
            "PUSH dword ptr [EBP + -0x10]",
            "PUSH dword ptr [EBP + -0x14]",
            "CALL 0x00003cc8",
            "ADD ESP,0x14",
            "TEST EAX,EAX",
            "JZ 0x00004b1c",
            "PUSH dword ptr [ESI + 0xc]",
            "MOV dword ptr [ESI + 0x4],EAX",
            "PUSH dword ptr [EDI + 0x28]",
            "CALL dword ptr [EDI + 0x24]",
            "POP ECX",
            "MOV dword ptr [ESI],0x6",
            "POP ECX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "PUSH EDI",
            "MOV dword ptr [EDI],EBX",
            "PUSH ESI",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "CALL 0x00003cfc",
            "ADD ESP,0xc",
            "CMP EAX,0x1",
            "JNZ 0x00004b89",
            "AND dword ptr [EBP + 0x10],0x0",
            "PUSH EDI",
            "PUSH dword ptr [ESI + 0x4]",
            "CALL 0x000042af",
            "MOV EAX,dword ptr [EDI + 0x4]",
            "MOV EBX,dword ptr [EDI]",
            "MOV dword ptr [EBP + -0x4],EAX",
            "MOV EAX,dword ptr [ESI + 0x20]",
            "POP ECX",
            "MOV dword ptr [EBP + 0x8],EAX",
            "MOV EAX,dword ptr [ESI + 0x1c]",
            "POP ECX",
            "MOV ECX,dword ptr [ESI + 0x34]",
            "MOV dword ptr [EBP + 0xc],EAX",
            "MOV EAX,dword ptr [ESI + 0x30]",
            "MOV dword ptr [EBP + -0x8],ECX",
            "CMP ECX,EAX",
            "JNC 0x000049a1",
            "SUB EAX,ECX",
            "DEC EAX",
            "JMP 0x000049a7",
            "MOV EAX,dword ptr [ESI + 0x2c]",
            "SUB EAX,dword ptr [EBP + -0x8]",
            "CMP dword ptr [ESI + 0x18],0x0",
            "MOV dword ptr [EBP + -0x10],EAX",
            "JNZ 0x00004b44",
            "AND dword ptr [ESI],0x0",
            "MOV EAX,dword ptr [ESI]",
            "CMP EAX,0x9",
            "JBE 0x00004402",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH -0x2",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x00003bd6",
            "ADD ESP,0xc",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI],0x9",
            "SHR EAX,0x3",
            "MOV dword ptr [EDI + 0x18],0x40f6ac",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "ADD EAX,-0x3",
            "JMP 0x00004a28",
            "MOV dword ptr [ESI],0x9",
            "MOV dword ptr [EDI + 0x18],0x40f68c",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "PUSH -0x3",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x000049e5",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "JMP 0x00004a68",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "AND dword ptr [EDI + 0x4],0x0",
            "MOV EAX,EBX",
            "PUSH dword ptr [EBP + 0x10]",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x000049e5",
            "MOV dword ptr [ESI],0x9",
            "MOV dword ptr [EDI + 0x18],0x40f668",
            "JMP 0x00004a1f",
            "CMP dword ptr [EBP + -0xc],-0x3",
            "JMP 0x00004ae0",
            "PUSH dword ptr [ESI + 0xc]",
            "PUSH dword ptr [EDI + 0x28]",
            "CALL dword ptr [EDI + 0x24]",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI],0x9",
            "MOV dword ptr [EDI + 0x18],0x40f64c",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "PUSH -0x3",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "PUSH EDI",
            "MOV dword ptr [EDI],EBX",
            "PUSH ESI",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "CALL 0x00003bd6",
            "ADD ESP,0x14",
            "JMP 0x000049ef",
            "CMP dword ptr [EBP + -0xc],-0x3",
            "JNZ 0x00004af3",
            "PUSH dword ptr [ESI + 0xc]",
            "PUSH dword ptr [EDI + 0x28]",
            "CALL dword ptr [EDI + 0x24]",
            "POP ECX",
            "MOV dword ptr [ESI],0x9",
            "POP ECX",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH dword ptr [EBP + -0xc]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x000049e5",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH -0x4",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x000049e5",
            "MOV dword ptr [ESI],0x7",
            "PUSH dword ptr [EBP + 0x10]",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x00003bd6",
            "MOV ECX,dword ptr [ESI + 0x34]",
            "ADD ESP,0xc",
            "CMP dword ptr [ESI + 0x30],ECX",
            "MOV dword ptr [EBP + -0x8],ECX",
            "JZ 0x00004b8f",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOV dword ptr [ESI + 0x20],ECX",
            "MOV ECX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],ECX",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],ECX",
            "MOV ECX,EBX",
            "SUB ECX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],ECX",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],ECX",
            "PUSH EAX",
            "JMP 0x000049e5",
            "MOV dword ptr [ESI],0x8",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "PUSH 0x1",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + -0x4]",
            "MOV dword ptr [EDI + 0x4],EAX",
            "MOV EAX,EBX",
            "SUB EAX,dword ptr [EDI]",
            "MOV dword ptr [EDI],EBX",
            "ADD dword ptr [EDI + 0x8],EAX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x000049e5"
        ],
        "function_address": {
            "start": "000043b6",
            "end": "00004bbc"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000043e1",
                    "00004405",
                    "0000455d",
                    "00004578",
                    "00004593",
                    "0000459a",
                    "000045a6",
                    "000045af",
                    "000045bb",
                    "000045fa",
                    "0000460b",
                    "00004955",
                    "00004995",
                    "000049a4",
                    "000049df",
                    "00004a3c",
                    "00004a74",
                    "00004ac9",
                    "00004b11",
                    "00004b39",
                    "00004b4d",
                    "00004b63",
                    "00004b83",
                    "00004bb2"
                ],
                "type": "undefined4"
            },
            "local_1c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004470",
                    "00004487"
                ],
                "type": "undefined4"
            },
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000048b3",
                    "00004905"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000043cd",
                    "00004415",
                    "00004429",
                    "000044e4",
                    "000044f5",
                    "0000453a",
                    "000045da",
                    "00004608",
                    "00004633",
                    "00004644",
                    "000046ce",
                    "000046df",
                    "00004796",
                    "000047aa",
                    "0000481f",
                    "00004833",
                    "00004944",
                    "0000497e",
                    "000049d0",
                    "00004a2b",
                    "00004a50",
                    "00004ab8",
                    "00004b02",
                    "00004b2a",
                    "00004b74",
                    "00004ba3"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000047d0",
                    "00004884",
                    "000048c0",
                    "000048d0",
                    "0000490e"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000447d",
                    "00004490"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000045e3",
                    "000045e8",
                    "000045ee",
                    "000045f3",
                    "000045f6",
                    "00004602",
                    "0000475a",
                    "000047d7",
                    "00004814",
                    "00004857",
                    "000048f9",
                    "00004a8e",
                    "00004adc",
                    "00004af6"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004475",
                    "0000448a"
                ],
                "type": "undefined4"
            },
            "local_30": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000048c8",
                    "00004908"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000043f4",
                    "00004402",
                    "00004565",
                    "0000456c",
                    "0000456f",
                    "0000459e",
                    "000045a9",
                    "000045c3",
                    "000045ca",
                    "000045cd",
                    "000045eb",
                    "0000460e",
                    "00004811",
                    "0000484f",
                    "00004877",
                    "000048a5",
                    "000048cc",
                    "000048e8",
                    "0000490b",
                    "000049ab"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00004479",
                    "0000448d"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000043b6",
        "original_name": "FUN_000043b6",
        "predicted_name": "FUN_00003bd6.",
        "prediction_full_response": "The predicted function name is FUN_00003bd6.</s>"
    },
    "0000792a": {
        "decomp_code": "\nvoid FUN_0000792a(void)\n\n{\n  _controlfp(0x10000,0x30000);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH 0x30000",
            "PUSH 0x10000",
            "CALL 0x00007940",
            "POP ECX",
            "POP ECX",
            "RET"
        ],
        "function_address": {
            "start": "0000792a",
            "end": "0000793b"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000792a",
        "original_name": "FUN_0000792a",
        "predicted_name": "disable_floating_point_exceptions.",
        "prediction_full_response": "The predicted function name is disable_floating_point_exceptions.</s>"
    },
    "0000671d": {
        "decomp_code": "\nundefined4 FUN_0000671d(int *param_1,char *param_2)\n\n{\n  int *piVar1;\n  undefined1 uVar2;\n  int iVar3;\n  int *piVar4;\n  undefined4 uVar5;\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  piVar1 = param_1;\n  if ((param_1 == (int *)0x0) || (param_1[6] == 0)) {\n    uVar5 = 0xffffff9a;\n  }\n  else {\n    if (param_1[0x1f] != 0) {\n      FUN_00006a97(param_1);\n    }\n    iVar3 = FUN_0000657a(param_1,&local_10,&local_8,&local_c);\n    if (iVar3 == 0) {\n      piVar4 = (int *)(*pcRam00408178)(0x84);\n      if (piVar4 != (int *)0x0) {\n        iVar3 = (*pcRam00408178)(0x4000);\n        *piVar4 = iVar3;\n        piVar4[0x11] = local_8;\n        piVar4[0x12] = local_c;\n        piVar4[0x13] = 0;\n        if (iVar3 != 0) {\n          piVar4[0x10] = 0;\n          iVar3 = param_1[0xd];\n          piVar4[0x15] = param_1[0xf];\n          piVar4[0x14] = 0;\n          piVar4[0x19] = param_1[0xd];\n          piVar4[0x18] = *param_1;\n          piVar4[0x1a] = param_1[3];\n          piVar4[6] = 0;\n          if (iVar3 != 0) {\n            piVar4[9] = 0;\n            piVar4[10] = 0;\n            piVar4[0xb] = 0;\n            iVar3 = FUN_00005777(piVar4 + 1);\n            if (iVar3 == 0) {\n              piVar4[0x10] = 1;\n            }\n          }\n          piVar4[0x16] = param_1[0x10];\n          piVar4[0x17] = param_1[0x11];\n          *(byte *)(piVar4 + 0x1b) = *(byte *)(param_1 + 0xc) & 1;\n          if (((uint)param_1[0xc] >> 3 & 1) == 0) {\n            uVar2 = (undefined1)((uint)param_1[0xf] >> 0x18);\n          }\n          else {\n            uVar2 = (undefined1)((uint)param_1[0xe] >> 8);\n          }\n          *(undefined1 *)(piVar4 + 0x20) = uVar2;\n          piVar4[0x1d] = 0x23456789;\n          piVar4[0x1f] = -(uint)((char)piVar4[0x1b] != '\\0') & 0xc;\n          piVar4[0x1c] = 0x12345678;\n          piVar4[0x1e] = 0x34567890;\n          param_1 = (int *)param_2;\n          if (param_2 != (char *)0x0) {\n            do {\n              if (*(char *)param_1 == '\\0') break;\n              FUN_00005535(piVar4 + 0x1c,CONCAT31((int3)((uint)param_1 >> 8),*(char *)param_1));\n              param_1 = (int *)((int)param_1 + 1);\n            } while (param_1 != (int *)0x0);\n          }\n          iVar3 = piVar1[0x1e];\n          piVar4[2] = 0;\n          piVar4[0xf] = iVar3 + 0x1e + local_10;\n          piVar1[0x1f] = (int)piVar4;\n          return 0;\n        }\n        (*pcRam00408174)(piVar4);\n      }\n      uVar5 = 0xffffff98;\n    }\n    else {\n      uVar5 = 0xffffff99;\n    }\n  }\n  return uVar5;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xc",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "XOR EBX,EBX",
            "CMP EDI,EBX",
            "JNZ 0x00006733",
            "PUSH -0x66",
            "JMP 0x0000679e",
            "CMP dword ptr [EDI + 0x18],EBX",
            "JZ 0x0000672f",
            "CMP dword ptr [EDI + 0x7c],EBX",
            "JZ 0x00006744",
            "PUSH EDI",
            "CALL 0x00006a97",
            "POP ECX",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "LEA EAX,[EBP + -0xc]",
            "PUSH EAX",
            "PUSH EDI",
            "CALL 0x0000657a",
            "ADD ESP,0x10",
            "TEST EAX,EAX",
            "JZ 0x00006761",
            "PUSH -0x67",
            "JMP 0x0000679e",
            "PUSH 0x84",
            "CALL dword ptr [0x00408178]",
            "MOV ESI,EAX",
            "POP ECX",
            "CMP ESI,EBX",
            "JZ 0x0000679c",
            "PUSH 0x4000",
            "CALL dword ptr [0x00408178]",
            "POP ECX",
            "MOV dword ptr [ESI],EAX",
            "MOV ECX,dword ptr [EBP + -0x4]",
            "CMP EAX,EBX",
            "MOV dword ptr [ESI + 0x44],ECX",
            "MOV ECX,dword ptr [EBP + -0x8]",
            "MOV dword ptr [ESI + 0x48],ECX",
            "MOV dword ptr [ESI + 0x4c],EBX",
            "JNZ 0x000067a4",
            "PUSH ESI",
            "CALL dword ptr [0x00408174]",
            "POP ECX",
            "PUSH -0x68",
            "POP EAX",
            "JMP 0x0000687b",
            "MOV dword ptr [ESI + 0x40],EBX",
            "MOV ECX,dword ptr [EDI + 0x3c]",
            "XOR EAX,EAX",
            "CMP dword ptr [EDI + 0x34],EBX",
            "MOV dword ptr [ESI + 0x54],ECX",
            "MOV dword ptr [ESI + 0x50],EBX",
            "MOV ECX,dword ptr [EDI + 0x34]",
            "MOV dword ptr [ESI + 0x64],ECX",
            "MOV ECX,dword ptr [EDI]",
            "SETZ AL",
            "MOV dword ptr [ESI + 0x60],ECX",
            "MOV ECX,dword ptr [EDI + 0xc]",
            "CMP EAX,EBX",
            "MOV dword ptr [ESI + 0x68],ECX",
            "MOV dword ptr [ESI + 0x18],EBX",
            "JNZ 0x000067ee",
            "LEA EAX,[ESI + 0x4]",
            "MOV dword ptr [ESI + 0x24],EBX",
            "PUSH EAX",
            "MOV dword ptr [ESI + 0x28],EBX",
            "MOV dword ptr [ESI + 0x2c],EBX",
            "CALL 0x00005777",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x000067ee",
            "MOV dword ptr [ESI + 0x40],0x1",
            "MOV EAX,dword ptr [EDI + 0x40]",
            "MOV dword ptr [ESI + 0x58],EAX",
            "MOV EAX,dword ptr [EDI + 0x44]",
            "MOV dword ptr [ESI + 0x5c],EAX",
            "MOV AL,byte ptr [EDI + 0x30]",
            "AND AL,0x1",
            "MOV byte ptr [ESI + 0x6c],AL",
            "MOV EAX,dword ptr [EDI + 0x30]",
            "SHR EAX,0x3",
            "TEST AL,0x1",
            "JZ 0x00006814",
            "MOV EAX,dword ptr [EDI + 0x38]",
            "SHR EAX,0x8",
            "JMP 0x0000681a",
            "MOV EAX,dword ptr [EDI + 0x3c]",
            "SHR EAX,0x18",
            "MOV byte ptr [ESI + 0x80],AL",
            "MOV AL,byte ptr [ESI + 0x6c]",
            "NEG AL",
            "SBB EAX,EAX",
            "LEA EBX,[ESI + 0x70]",
            "AND EAX,0xc",
            "MOV dword ptr [ESI + 0x74],0x23456789",
            "MOV dword ptr [ESI + 0x7c],EAX",
            "MOV EAX,dword ptr [EBP + 0xc]",
            "TEST EAX,EAX",
            "MOV dword ptr [EBX],0x12345678",
            "MOV dword ptr [ESI + 0x78],0x34567890",
            "MOV dword ptr [EBP + 0x8],EAX",
            "JZ 0x00006865",
            "MOV EAX,dword ptr [EBP + 0x8]",
            "MOV AL,byte ptr [EAX]",
            "TEST AL,AL",
            "JZ 0x00006865",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x00005535",
            "INC dword ptr [EBP + 0x8]",
            "POP ECX",
            "POP ECX",
            "JNZ 0x0000684e",
            "MOV EAX,dword ptr [EDI + 0x78]",
            "MOV ECX,dword ptr [EBP + -0xc]",
            "AND dword ptr [ESI + 0x8],0x0",
            "LEA EAX,[EAX + ECX*0x1 + 0x1e]",
            "MOV dword ptr [ESI + 0x3c],EAX",
            "MOV dword ptr [EDI + 0x7c],ESI",
            "XOR EAX,EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "0000671d",
            "end": "0000687f"
        },
        "variable_metadata": {
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006744",
                    "00006789"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006748",
                    "00006781"
                ],
                "type": "undefined4"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000674c",
                    "00006868"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_0000671d",
        "original_name": "FUN_0000671d",
        "predicted_name": "",
        "prediction_full_response": ""
    },
    "0000182c": {
        "decomp_code": "\nundefined4 __fastcall FUN_0000182c(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  do {\n    iVar1 = (*pcRam0040f894)(param_1 + 4,0,-(uint)(iVar2 != 0) & 0x40f08c,0x18,0xf0000000);\n    if (iVar1 != 0) {\n      return 1;\n    }\n    iVar2 = iVar2 + 1;\n  } while (iVar2 < 2);\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH ESI",
            "PUSH EDI",
            "XOR EDI,EDI",
            "LEA ESI,[ECX + 0x4]",
            "MOV EAX,EDI",
            "PUSH 0xf0000000",
            "NEG EAX",
            "SBB EAX,EAX",
            "PUSH 0x18",
            "AND EAX,0x40f08c",
            "PUSH EAX",
            "PUSH 0x0",
            "PUSH ESI",
            "CALL dword ptr [0x0040f894]",
            "TEST EAX,EAX",
            "JNZ 0x0000185c",
            "INC EDI",
            "CMP EDI,0x2",
            "JL 0x00001833",
            "POP EDI",
            "POP ESI",
            "RET",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x00001859"
        ],
        "function_address": {
            "start": "0000182c",
            "end": "00001860"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000182c",
        "original_name": "FUN_0000182c",
        "predicted_name": "pcRam0040f894",
        "prediction_full_response": "The predicted function name is pcRam0040f894</s>"
    },
    "00006b02": {
        "decomp_code": "\nvoid FUN_00006b02(uint param_1)\n\n{\n  __allmul(param_1 + 0xb6109100,((int)param_1 >> 0x1f) + 2 + (uint)(0x49ef6eff < param_1),10000000,0\n          );\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV EAX,dword ptr [ESP + 0x4]",
            "PUSH 0x0",
            "CDQ",
            "ADD EAX,0xb6109100",
            "PUSH 0x989680",
            "ADC EDX,0x2",
            "PUSH EDX",
            "PUSH EAX",
            "CALL 0x00007780",
            "MOV ECX,EDX",
            "SAR ECX,0x1f",
            "RET"
        ],
        "function_address": {
            "start": "00006b02",
            "end": "00006b22"
        },
        "variable_metadata": {},
        "func_name": "FUN_00006b02",
        "original_name": "FUN_00006b02",
        "predicted_name": "__allmul_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_100",
        "prediction_full_response": "The predicted function name is __allmul_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000_100"
    },
    "00003a77": {
        "decomp_code": "\nvoid __thiscall FUN_00003a77(int param_1,void *param_2,int param_3,uint param_4,uint param_5)\n\n{\n  uint uVar1;\n  bool bVar2;\n  undefined1 local_10 [12];\n  \n  if (*(char *)(param_1 + 4) == '\\0') {\n    (*pcRam00408184)(0x40f570);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n  }\n  if (param_4 != 0) {\n    uVar1 = *(uint *)(param_1 + 0x3cc);\n    if ((int)((ulonglong)param_4 % (ulonglong)uVar1) == 0) {\n      if (param_5 == 1) {\n        param_5 = 0;\n        if ((int)(((ulonglong)param_4 % (ulonglong)uVar1 << 0x20 | (ulonglong)param_4) /\n                 (ulonglong)uVar1) != 0) {\n          do {\n            FUN_00003797(param_2,param_3);\n            FUN_00003a28(param_3,param_1 + 0x3f0);\n            memcpy((void *)(param_1 + 0x3f0),param_2,*(size_t *)(param_1 + 0x3cc));\n            uVar1 = *(uint *)(param_1 + 0x3cc);\n            param_2 = (void *)((int)param_2 + uVar1);\n            param_3 = param_3 + uVar1;\n            param_5 = param_5 + 1;\n          } while (param_5 < param_4 / uVar1);\n        }\n      }\n      else {\n        bVar2 = param_5 == 2;\n        param_5 = 0;\n        if (bVar2) {\n          if (param_4 / uVar1 != 0) {\n            do {\n              FUN_0000350f(param_1 + 0x3f0,param_3);\n              FUN_00003a28(param_3,param_2);\n              memcpy((void *)(param_1 + 0x3f0),param_2,*(size_t *)(param_1 + 0x3cc));\n              uVar1 = *(uint *)(param_1 + 0x3cc);\n              param_2 = (void *)((int)param_2 + uVar1);\n              param_3 = param_3 + uVar1;\n              param_5 = param_5 + 1;\n            } while (param_5 < param_4 / uVar1);\n          }\n        }\n        else if (param_4 / uVar1 != 0) {\n          do {\n            FUN_00003797(param_2,param_3);\n            uVar1 = *(uint *)(param_1 + 0x3cc);\n            param_2 = (void *)((int)param_2 + uVar1);\n            param_3 = param_3 + uVar1;\n            param_5 = param_5 + 1;\n          } while (param_5 < param_4 / uVar1);\n        }\n      }\n      return;\n    }\n  }\n  (*pcRam00408184)(0x40f574);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_10,(ThrowInfo *)0x40d570);\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0xc",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,ECX",
            "XOR EBX,EBX",
            "PUSH EDI",
            "CMP byte ptr [ESI + 0x4],BL",
            "JNZ 0x00003aa5",
            "PUSH 0x40f570",
            "LEA ECX,[EBP + -0xc]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0xc]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "CMP EAX,EBX",
            "JZ 0x00003bba",
            "MOV ECX,dword ptr [ESI + 0x3cc]",
            "XOR EDX,EDX",
            "DIV ECX",
            "TEST EDX,EDX",
            "JNZ 0x00003bba",
            "CMP dword ptr [EBP + 0x14],0x1",
            "JNZ 0x00003b28",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "DIV ECX",
            "MOV dword ptr [EBP + 0x14],EBX",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "TEST EAX,EAX",
            "JBE 0x00003b21",
            "PUSH EBX",
            "PUSH EDI",
            "MOV ECX,ESI",
            "CALL 0x00003797",
            "LEA EAX,[ESI + 0x3f0]",
            "MOV ECX,ESI",
            "PUSH EAX",
            "PUSH EBX",
            "CALL 0x00003a28",
            "PUSH dword ptr [ESI + 0x3cc]",
            "LEA EAX,[ESI + 0x3f0]",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x00007706",
            "MOV ECX,dword ptr [ESI + 0x3cc]",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "XOR EDX,EDX",
            "ADD ESP,0xc",
            "DIV ECX",
            "ADD EDI,ECX",
            "ADD EBX,ECX",
            "INC dword ptr [EBP + 0x14]",
            "CMP dword ptr [EBP + 0x14],EAX",
            "JC 0x00003ada",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET 0x10",
            "CMP dword ptr [EBP + 0x14],0x2",
            "MOV EDI,dword ptr [EBP + 0x8]",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "MOV dword ptr [EBP + 0x14],EBX",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "JNZ 0x00003b8b",
            "XOR EDX,EDX",
            "DIV ECX",
            "TEST EAX,EAX",
            "JBE 0x00003b21",
            "LEA EAX,[ESI + 0x3f0]",
            "PUSH EBX",
            "PUSH EAX",
            "MOV ECX,ESI",
            "CALL 0x0000350f",
            "PUSH EDI",
            "PUSH EBX",
            "MOV ECX,ESI",
            "CALL 0x00003a28",
            "PUSH dword ptr [ESI + 0x3cc]",
            "LEA EAX,[ESI + 0x3f0]",
            "PUSH EDI",
            "PUSH EAX",
            "CALL 0x00007706",
            "MOV ECX,dword ptr [ESI + 0x3cc]",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "XOR EDX,EDX",
            "ADD ESP,0xc",
            "DIV ECX",
            "ADD EDI,ECX",
            "ADD EBX,ECX",
            "INC dword ptr [EBP + 0x14]",
            "CMP dword ptr [EBP + 0x14],EAX",
            "JC 0x00003b42",
            "JMP 0x00003b21",
            "XOR EDX,EDX",
            "DIV ECX",
            "TEST EAX,EAX",
            "JBE 0x00003b21",
            "PUSH EBX",
            "PUSH EDI",
            "MOV ECX,ESI",
            "CALL 0x00003797",
            "MOV ECX,dword ptr [ESI + 0x3cc]",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "XOR EDX,EDX",
            "ADD EDI,ECX",
            "DIV ECX",
            "ADD EBX,ECX",
            "INC dword ptr [EBP + 0x14]",
            "CMP dword ptr [EBP + 0x14],EAX",
            "JC 0x00003b93",
            "JMP 0x00003b21",
            "PUSH 0x40f574",
            "LEA ECX,[EBP + -0xc]",
            "CALL dword ptr [0x00408184]",
            "LEA EAX,[EBP + -0xc]",
            "PUSH 0x40d570",
            "PUSH EAX",
            "CALL 0x0000776e"
        ],
        "function_address": {
            "start": "00003a77",
            "end": "00003bd5"
        },
        "variable_metadata": {
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00003a8e",
                    "00003a97",
                    "00003bbf",
                    "00003bc8"
                ],
                "type": "undefined"
            }
        },
        "func_name": "FUN_00003a77",
        "original_name": "FUN_00003a77",
        "predicted_name": "_ZN10__cxxabiv117__class_type_info13__do_catch_auxEPKcPvjj",
        "prediction_full_response": "The predicted function name is _ZN10__cxxabiv117__class_type_info13__do_catch_auxEPKcPvjj</s>"
    },
    "00001af6": {
        "decomp_code": "\nundefined4 FUN_00001af6(undefined4 param_1,undefined4 param_2,int param_3)\n\n{\n  code *pcVar1;\n  code *pcVar2;\n  int iVar3;\n  uint uVar4;\n  \n  pcVar2 = pcRam0040805c;\n  (*pcRam0040805c)(param_1,0);\n  pcVar1 = pcRam00408058;\n  iVar3 = (*pcRam00408058)(param_1);\n  if (iVar3 != 0) {\n    (*pcVar2)(param_2,0);\n    iVar3 = (*pcVar1)(param_2);\n    if (iVar3 != 0) {\n      uVar4 = (*pcRam0040802c)(param_2);\n      (*pcRam00408054)(param_2,uVar4 | 6);\n      if (param_3 != 0) {\n        (*pcRam00408154)(param_3,0x40eb88,param_1,param_2);\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [0x0040805c]",
            "PUSH EDI",
            "PUSH 0x0",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL ESI",
            "PUSH dword ptr [EBP + 0x8]",
            "MOV EDI,dword ptr [0x00408058]",
            "CALL EDI",
            "TEST EAX,EAX",
            "JZ 0x00001b27",
            "MOV EBX,dword ptr [EBP + 0xc]",
            "PUSH 0x0",
            "PUSH EBX",
            "CALL ESI",
            "PUSH EBX",
            "CALL EDI",
            "TEST EAX,EAX",
            "JNZ 0x00001b2b",
            "XOR EAX,EAX",
            "JMP 0x00001b5a",
            "PUSH EBX",
            "CALL dword ptr [0x0040802c]",
            "OR AL,0x6",
            "PUSH EAX",
            "PUSH EBX",
            "CALL dword ptr [0x00408054]",
            "CMP dword ptr [EBP + 0x10],0x0",
            "JZ 0x00001b57",
            "PUSH EBX",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH 0x40eb88",
            "PUSH dword ptr [EBP + 0x10]",
            "CALL dword ptr [0x00408154]",
            "ADD ESP,0x10",
            "PUSH 0x1",
            "POP EAX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "POP EBP",
            "RET"
        ],
        "function_address": {
            "start": "00001af6",
            "end": "00001b5e"
        },
        "variable_metadata": {},
        "func_name": "FUN_00001af6",
        "original_name": "FUN_00001af6",
        "predicted_name": "\"compare_and_swap_int\".",
        "prediction_full_response": "The predicted function name is \"compare_and_swap_int\".</s>"
    },
    "000056dd": {
        "decomp_code": "\nvoid FUN_000056dd(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  (*pcRam0040818c)(param_2,param_3);\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH dword ptr [ESP + 0xc]",
            "PUSH dword ptr [ESP + 0xc]",
            "CALL dword ptr [0x0040818c]",
            "POP ECX",
            "POP ECX",
            "RET"
        ],
        "function_address": {
            "start": "000056dd",
            "end": "000056ed"
        },
        "variable_metadata": {},
        "func_name": "FUN_000056dd",
        "original_name": "FUN_000056dd",
        "predicted_name": "pcRam0040818c_0040818c",
        "prediction_full_response": "The predicted function name is pcRam0040818c_0040818c</s>"
    },
    "00001b5f": {
        "decomp_code": "\nbool FUN_00001b5f(undefined4 param_1)\n\n{\n  code *pcVar1;\n  undefined2 *puVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined2 local_4dc;\n  undefined4 local_4da;\n  undefined2 local_2d4;\n  undefined4 local_2d2 [129];\n  undefined2 local_cc;\n  undefined4 local_ca [49];\n  \n  local_4dc = uRam0040f874;\n  puVar4 = &local_4da;\n  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  local_2d4 = uRam0040f874;\n  puVar4 = local_2d2;\n  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  local_cc = uRam0040f874;\n  puVar4 = local_ca;\n  for (iVar3 = 0x31; iVar3 != 0; iVar3 = iVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  *(undefined2 *)puVar4 = 0;\n  (*pcRam00408078)(0,0,0x40f8ac,0xffffffff,&local_cc,99);\n  (*pcRam00408064)(&local_4dc,0x104);\n  pcVar1 = pcRam00408154;\n  local_4da._2_2_ = 0;\n  (*pcRam00408154)(&local_2d4,0x40f40c,&local_4dc);\n  iVar3 = (*pcRam0040802c)(&local_2d4);\n  if ((iVar3 == -1) || (iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1), iVar3 == 0)) {\n    (*pcVar1)(&local_2d4,0x40f3f8,&local_4dc);\n    iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1);\n    if ((iVar3 == 0) && (iVar3 = FUN_00001af6(&local_4dc,&local_cc,param_1), iVar3 == 0)) {\n      (*pcRam00408060)(0x104,&local_2d4);\n      pcVar1 = pcRam00408150;\n      iVar3 = (*pcRam00408150)(&local_2d4,0x5c);\n      if (iVar3 != 0) {\n        puVar2 = (undefined2 *)(*pcVar1)(&local_2d4,0x5c);\n        *puVar2 = 0;\n      }\n      iVar3 = FUN_00001af6(&local_2d4,&local_cc,param_1);\n      return iVar3 != 0;\n    }\n  }\n  return true;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x4d8",
            "MOV DX,word ptr [0x0040f874]",
            "PUSH ESI",
            "MOV ESI,0x81",
            "PUSH EDI",
            "MOV ECX,ESI",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffb2a]",
            "MOV word ptr [EBP + 0xfffffb28],DX",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "MOV ECX,ESI",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffd32]",
            "MOV word ptr [EBP + 0xfffffd30],DX",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "PUSH 0x31",
            "XOR EAX,EAX",
            "POP ECX",
            "LEA EDI,[EBP + 0xffffff3a]",
            "MOV word ptr [EBP + 0xffffff38],DX",
            "PUSH 0x63",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "LEA EAX,[EBP + 0xffffff38]",
            "PUSH EAX",
            "PUSH -0x1",
            "PUSH 0x40f8ac",
            "PUSH 0x0",
            "PUSH 0x0",
            "CALL dword ptr [0x00408078]",
            "MOV ESI,0x104",
            "LEA EAX,[EBP + 0xfffffb28]",
            "PUSH ESI",
            "PUSH EAX",
            "CALL dword ptr [0x00408064]",
            "MOV EDI,dword ptr [0x00408154]",
            "AND word ptr [EBP + 0xfffffb2c],0x0",
            "LEA EAX,[EBP + 0xfffffb28]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH 0x40f40c",
            "PUSH EAX",
            "CALL EDI",
            "ADD ESP,0xc",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH EAX",
            "CALL dword ptr [0x0040802c]",
            "CMP EAX,-0x1",
            "JZ 0x00001c40",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0xffffff38]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH EAX",
            "CALL 0x00001af6",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x00001c40",
            "PUSH 0x1",
            "POP EAX",
            "JMP 0x00001ce4",
            "LEA EAX,[EBP + 0xfffffb28]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH 0x40f3f8",
            "PUSH EAX",
            "CALL EDI",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0xffffff38]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH EAX",
            "CALL 0x00001af6",
            "ADD ESP,0x18",
            "TEST EAX,EAX",
            "JNZ 0x00001c38",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0xffffff38]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffb28]",
            "PUSH EAX",
            "CALL 0x00001af6",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JNZ 0x00001c38",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL dword ptr [0x00408060]",
            "MOV ESI,dword ptr [0x00408150]",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH 0x5c",
            "PUSH EAX",
            "CALL ESI",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00001cc5",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH 0x5c",
            "PUSH EAX",
            "CALL ESI",
            "AND word ptr [EAX],0x0",
            "POP ECX",
            "POP ECX",
            "PUSH dword ptr [EBP + 0x8]",
            "LEA EAX,[EBP + 0xffffff38]",
            "PUSH EAX",
            "LEA EAX,[EBP + 0xfffffd30]",
            "PUSH EAX",
            "CALL 0x00001af6",
            "ADD ESP,0xc",
            "NEG EAX",
            "SBB EAX,EAX",
            "NEG EAX",
            "POP EDI",
            "POP ESI",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001b5f",
            "end": "00001ce7"
        },
        "variable_metadata": {
            "local_2d4": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001b95",
                    "00001bf8",
                    "00001c09",
                    "00001c25",
                    "00001c47",
                    "00001c5f",
                    "00001c8f",
                    "00001ca3",
                    "00001cb4",
                    "00001ccf"
                ],
                "type": "undefined2"
            },
            "local_2d2": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001b8f"
                ],
                "type": "undefined"
            },
            "local_4dc": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001b80",
                    "00001bd5",
                    "00001bf1",
                    "00001c40",
                    "00001c7c"
                ],
                "type": "undefined2"
            },
            "local_4da": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001b7a"
                ],
                "type": "undefined"
            },
            "local_ca": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001ba5"
                ],
                "type": "undefined"
            },
            "local_4d8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001be9"
                ],
                "type": "undefined2"
            },
            "local_cc": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001bab",
                    "00001bb8",
                    "00001c1e",
                    "00001c58",
                    "00001c75",
                    "00001cc8"
                ],
                "type": "undefined2"
            }
        },
        "func_name": "FUN_00001b5f",
        "original_name": "FUN_00001b5f",
        "predicted_name": "\"check_for_valid_magic_number\".",
        "prediction_full_response": "The predicted function name is \"check_for_valid_magic_number\".</s>"
    },
    "00007700": {
        "decomp_code": "\nvoid * __cdecl operator_new(uint param_1)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007700. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam00408158)();\n  return pvVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408158]"
        ],
        "function_address": {
            "start": "00007700",
            "end": "00007705"
        },
        "variable_metadata": {
            "param_1": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            }
        },
        "func_name": "operator_new",
        "original_name": "operator_new",
        "predicted_name": "_mu_alloc_malloc",
        "prediction_full_response": "The predicted function name is _mu_alloc_malloc</s>"
    },
    "00001f5d": {
        "decomp_code": "\nundefined4 FUN_00001f5d(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined1 local_20c;\n  undefined4 local_20b;\n  \n  local_20c = uRam0040f910;\n  puVar2 = &local_20b;\n  for (iVar1 = 0x81; iVar1 != 0; iVar1 = iVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  *(undefined2 *)puVar2 = 0;\n  *(undefined1 *)((int)puVar2 + 2) = 0;\n  (*pcRam00408084)(0x40f4d8,0x208,&local_20c,0);\n  iVar1 = FUN_00001ce8(&local_20c);\n  if ((iVar1 != 0) && (iVar1 = FUN_00001eff(0x3c), iVar1 != 0)) {\n    return 1;\n  }\n  iVar1 = FUN_00001064(&local_20c,0,0);\n  if ((iVar1 != 0) && (iVar1 = FUN_00001eff(0x3c), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x208",
            "MOV AL,[0x0040f910]",
            "PUSH EDI",
            "MOV byte ptr [EBP + 0xfffffdf8],AL",
            "MOV ECX,0x81",
            "XOR EAX,EAX",
            "LEA EDI,[EBP + 0xfffffdf9]",
            "STOSD.REP ES:EDI",
            "STOSW ES:EDI",
            "STOSB ES:EDI",
            "LEA EAX,[EBP + 0xfffffdf8]",
            "PUSH 0x0",
            "PUSH EAX",
            "PUSH 0x208",
            "PUSH 0x40f4d8",
            "CALL dword ptr [0x00408084]",
            "LEA EAX,[EBP + 0xfffffdf8]",
            "PUSH EAX",
            "CALL 0x00001ce8",
            "POP ECX",
            "POP EDI",
            "TEST EAX,EAX",
            "JZ 0x00001fbb",
            "PUSH 0x3c",
            "CALL 0x00001eff",
            "TEST EAX,EAX",
            "POP ECX",
            "JNZ 0x00001fde",
            "PUSH 0x0",
            "LEA EAX,[EBP + 0xfffffdf8]",
            "PUSH 0x0",
            "PUSH EAX",
            "CALL 0x00001064",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x00001fe3",
            "PUSH 0x3c",
            "CALL 0x00001eff",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00001fe3",
            "PUSH 0x1",
            "POP EAX",
            "LEAVE",
            "RET",
            "XOR EAX,EAX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00001f5d",
            "end": "00001fe6"
        },
        "variable_metadata": {
            "local_20b": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001f79"
                ],
                "type": "undefined"
            },
            "local_20c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001f6c",
                    "00001f84",
                    "00001f9d",
                    "00001fbd"
                ],
                "type": "undefined1"
            }
        },
        "func_name": "FUN_00001f5d",
        "original_name": "FUN_00001f5d",
        "predicted_name": "FUN_00001064.",
        "prediction_full_response": "The predicted function name is FUN_00001064.</s>"
    },
    "00007706": {
        "decomp_code": "\nvoid * __cdecl memcpy(void *_Dst,void *_Src,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00007706. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = (void *)(*pcRam0040815c)();\n  return pvVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x0040815c]"
        ],
        "function_address": {
            "start": "00007706",
            "end": "0000770b"
        },
        "variable_metadata": {
            "_Size": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "uint"
            },
            "_Src": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            },
            "_Dst": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "void *"
            }
        },
        "func_name": "memcpy",
        "original_name": "memcpy",
        "predicted_name": "memcpy_s",
        "prediction_full_response": "The predicted function name is memcpy_s</s>"
    },
    "000029cc": {
        "decomp_code": "\nvoid FUN_000029cc(int *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  if (param_1 != (int *)0x0) {\n    if (param_1[4] != 0) {\n      (*(code *)(*(int *)(*param_1 + 0x28) + param_1[1]))(param_1[1],0,0);\n    }\n    if (param_1[2] != 0) {\n      iVar3 = 0;\n      if (0 < param_1[3]) {\n        do {\n          iVar1 = *(int *)(param_1[2] + iVar3 * 4);\n          if (iVar1 != 0) {\n            (*(code *)param_1[0xb])(iVar1,param_1[0xc]);\n          }\n          iVar3 = iVar3 + 1;\n        } while (iVar3 < param_1[3]);\n      }\n      (*pcRam00408174)(param_1[2]);\n    }\n    if (param_1[1] != 0) {\n      (*(code *)param_1[8])(param_1[1],0,0x8000,param_1[0xc]);\n    }\n    uVar2 = (*pcRam004080a0)(0,param_1);\n    (*pcRam004080b4)(uVar2);\n  }\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [ESP + 0xc]",
            "XOR EBX,EBX",
            "CMP ESI,EBX",
            "JZ 0x00002a43",
            "CMP dword ptr [ESI + 0x10],EBX",
            "JZ 0x000029ec",
            "MOV ECX,dword ptr [ESI]",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "PUSH EBX",
            "PUSH EBX",
            "MOV ECX,dword ptr [ECX + 0x28]",
            "PUSH EAX",
            "ADD ECX,EAX",
            "CALL ECX",
            "CMP dword ptr [ESI + 0x8],EBX",
            "JZ 0x00002a1d",
            "PUSH EDI",
            "XOR EDI,EDI",
            "CMP dword ptr [ESI + 0xc],EBX",
            "JLE 0x00002a12",
            "MOV EAX,dword ptr [ESI + 0x8]",
            "MOV EAX,dword ptr [EAX + EDI*0x4]",
            "CMP EAX,EBX",
            "JZ 0x00002a0c",
            "PUSH dword ptr [ESI + 0x30]",
            "PUSH EAX",
            "CALL dword ptr [ESI + 0x2c]",
            "POP ECX",
            "POP ECX",
            "INC EDI",
            "CMP EDI,dword ptr [ESI + 0xc]",
            "JL 0x000029f9",
            "PUSH dword ptr [ESI + 0x8]",
            "CALL dword ptr [0x00408174]",
            "POP ECX",
            "POP EDI",
            "MOV EAX,dword ptr [ESI + 0x4]",
            "CMP EAX,EBX",
            "JZ 0x00002a34",
            "PUSH dword ptr [ESI + 0x30]",
            "PUSH 0x8000",
            "PUSH EBX",
            "PUSH EAX",
            "CALL dword ptr [ESI + 0x20]",
            "ADD ESP,0x10",
            "PUSH ESI",
            "PUSH EBX",
            "CALL dword ptr [0x004080a0]",
            "PUSH EAX",
            "CALL dword ptr [0x004080b4]",
            "POP ESI",
            "POP EBX",
            "RET"
        ],
        "function_address": {
            "start": "000029cc",
            "end": "00002a45"
        },
        "variable_metadata": {},
        "func_name": "FUN_000029cc",
        "original_name": "FUN_000029cc",
        "predicted_name": "\"free_param\".",
        "prediction_full_response": "The predicted function name is \"free_param\".</s>"
    },
    "00005fe2": {
        "decomp_code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint * FUN_00005fe2(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  int *piVar5;\n  int *piVar6;\n  int local_94 [2];\n  undefined1 local_8c [4];\n  int local_88;\n  int local_78;\n  int local_74;\n  int local_70 [22];\n  undefined4 local_18;\n  undefined1 local_14 [4];\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  iVar4 = param_1;\n  if (param_1 == 0) {\n    return (int *)0x0;\n  }\n  if (cRam0040d454 == ' ') {\n    param_1 = 0;\n    iVar1 = FUN_00005edf(iVar4);\n    if (iVar1 == -1) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005d0e(iVar4,iVar1,0);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e6b(iVar4,local_14);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_8);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_10);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,local_94 + 1);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,&local_c);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    if (((local_c != local_94[1]) || (local_10 != 0)) || (local_8 != 0)) {\n      param_1 = -0x67;\n    }\n    iVar2 = FUN_00005e6b(iVar4,&local_74);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e6b(iVar4,local_70);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    iVar2 = FUN_00005e27(iVar4,local_8c);\n    if (iVar2 != 0) {\n      param_1 = -1;\n    }\n    if ((uint)(*(int *)(iVar4 + 0xc) + iVar1) < (uint)(local_74 + local_70[0])) {\n      if (param_1 != 0) goto LAB_00006112;\n      param_1 = -0x67;\n    }\n    if (param_1 == 0) {\n      local_94[0] = iVar4;\n      local_18 = 0;\n      local_88 = ((*(int *)(iVar4 + 0xc) - local_74) - local_70[0]) + iVar1;\n      *(undefined4 *)(iVar4 + 0xc) = 0;\n      local_78 = iVar1;\n      piVar3 = (int *)(*pcRam00408178)(0x80);\n      piVar5 = local_94;\n      piVar6 = piVar3;\n      for (iVar4 = 0x20; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar6 = *piVar5;\n        piVar5 = piVar5 + 1;\n        piVar6 = piVar6 + 1;\n      }\n      FUN_000064e2(piVar3);\n      return piVar3;\n    }\n  }\nLAB_00006112:\n  FUN_00005c9f(iVar4);\n  return (int *)0x0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x90",
            "PUSH EBX",
            "PUSH ESI",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "PUSH EDI",
            "TEST ESI,ESI",
            "JZ 0x00006119",
            "CMP byte ptr [0x0040d454],0x20",
            "JNZ 0x00006112",
            "AND dword ptr [EBP + 0x8],0x0",
            "PUSH ESI",
            "CALL 0x00005edf",
            "MOV EDI,EAX",
            "OR EBX,0xffffffff",
            "CMP EDI,EBX",
            "POP ECX",
            "JNZ 0x0000601d",
            "MOV dword ptr [EBP + 0x8],EBX",
            "PUSH 0x0",
            "PUSH EDI",
            "PUSH ESI",
            "CALL 0x00005d0e",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x00006030",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + -0x10]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006043",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + -0x4]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006056",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + -0xc]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006069",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + 0xffffff74]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000607f",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + -0x8]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00006092",
            "MOV dword ptr [EBP + 0x8],EBX",
            "MOV EAX,dword ptr [EBP + -0x8]",
            "CMP EAX,dword ptr [EBP + 0xffffff74]",
            "JNZ 0x000060a9",
            "CMP dword ptr [EBP + -0xc],0x0",
            "JNZ 0x000060a9",
            "CMP dword ptr [EBP + -0x4],0x0",
            "JZ 0x000060b0",
            "MOV dword ptr [EBP + 0x8],0xffffff99",
            "LEA EAX,[EBP + -0x70]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000060c3",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + -0x6c]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e6b",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000060d6",
            "MOV dword ptr [EBP + 0x8],EBX",
            "LEA EAX,[EBP + 0xffffff78]",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00005e27",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x000060ec",
            "MOV dword ptr [EBP + 0x8],EBX",
            "MOV EAX,dword ptr [ESI + 0xc]",
            "MOV ECX,dword ptr [EBP + -0x6c]",
            "MOV EBX,dword ptr [EBP + -0x70]",
            "LEA EDX,[EAX + EDI*0x1]",
            "ADD EBX,ECX",
            "CMP EDX,EBX",
            "JNC 0x0000610b",
            "CMP dword ptr [EBP + 0x8],0x0",
            "JNZ 0x00006112",
            "MOV dword ptr [EBP + 0x8],0xffffff99",
            "XOR EDX,EDX",
            "CMP dword ptr [EBP + 0x8],EDX",
            "JZ 0x0000611d",
            "PUSH ESI",
            "CALL 0x00005c9f",
            "POP ECX",
            "XOR EAX,EAX",
            "JMP 0x0000615d",
            "SUB EAX,dword ptr [EBP + -0x70]",
            "PUSH 0x80",
            "MOV dword ptr [EBP + 0xffffff70],ESI",
            "MOV dword ptr [EBP + -0x74],EDI",
            "SUB EAX,ECX",
            "MOV dword ptr [EBP + -0x14],EDX",
            "ADD EAX,EDI",
            "MOV dword ptr [ESI + 0xc],EDX",
            "MOV dword ptr [EBP + 0xffffff7c],EAX",
            "CALL dword ptr [0x00408178]",
            "MOV EBX,EAX",
            "PUSH 0x20",
            "POP ECX",
            "LEA ESI,[EBP + 0xffffff70]",
            "MOV EDI,EBX",
            "PUSH EBX",
            "MOVSD.REP ES:EDI,ESI",
            "CALL 0x000064e2",
            "POP ECX",
            "MOV EAX,EBX",
            "POP ECX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "00005fe2",
            "end": "00006161"
        },
        "variable_metadata": {
            "local_90": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006069",
                    "00006095"
                ],
                "type": "undefined4"
            },
            "local_c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000607f",
                    "00006092"
                ],
                "type": "undefined4"
            },
            "local_94": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006125",
                    "00006149"
                ],
                "type": "undefined4"
            },
            "local_70": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000060c3",
                    "000060ef"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006043",
                    "000060a3"
                ],
                "type": "undefined4"
            },
            "local_18": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006130"
                ],
                "type": "undefined4"
            },
            "local_8c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000060d6"
                ],
                "type": "undefined"
            },
            "local_10": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006056",
                    "0000609d"
                ],
                "type": "undefined4"
            },
            "local_74": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000060b0",
                    "000060f2",
                    "0000611d"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006030"
                ],
                "type": "undefined"
            },
            "local_78": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000612b"
                ],
                "type": "undefined4"
            },
            "local_88": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00006138"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_00005fe2",
        "original_name": "FUN_00005fe2",
        "predicted_name": "[PYTHON]",
        "prediction_full_response": "[PYTHON]\ndef get_file_size(file_path: str) -> int:\n    \"\"\"\n    Returns the size of a file in bytes.\n    \"\"\"\n    return os.path.getsize(file_path)\n[/PYTHON]\n</s>"
    },
    "00007950": {
        "decomp_code": "\nvoid Unwind_00407950(void)\n\n{\n  FUN_0000181b();\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [EBP + -0x10]",
            "ADD ECX,0x4",
            "JMP 0x0000181b"
        ],
        "function_address": {
            "start": "00007950",
            "end": "0000795a"
        },
        "variable_metadata": {},
        "func_name": "Unwind@00407950",
        "original_name": "Unwind@00407950",
        "predicted_name": "FUN_0000181b",
        "prediction_full_response": "The predicted function name is FUN_0000181b</s>"
    },
    "000077b4": {
        "decomp_code": "\nchar * __cdecl strcat(char *_Dest,char *_Source)\n\n{\n  char *pcVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000077b4. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pcVar1 = (char *)(*pcRam00408190)();\n  return pcVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "JMP dword ptr [0x00408190]"
        ],
        "function_address": {
            "start": "000077b4",
            "end": "000077b9"
        },
        "variable_metadata": {
            "_Dest": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            },
            "_Source": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [],
                "type": "char *"
            }
        },
        "func_name": "strcat",
        "original_name": "strcat",
        "predicted_name": "strcpy",
        "prediction_full_response": "The predicted function name is strcpy</s>"
    },
    "000021e9": {
        "decomp_code": "\nint * FUN_000021e9(short *param_1,undefined4 param_2,code *param_3,code *param_4,int param_5,\n                  code *param_6,int param_7,int param_8)\n\n{\n  uint uVar1;\n  int iVar2;\n  code *pcVar3;\n  int *piVar4;\n  int iVar5;\n  void *_Dst;\n  uint uVar6;\n  int *piVar7;\n  undefined4 uVar8;\n  undefined1 local_2c [4];\n  int local_28;\n  uint local_8;\n  \n  local_8 = 0;\n  iVar2 = FUN_00002457(param_2,0x40);\n  if (iVar2 == 0) {\n    return (int *)0x0;\n  }\n  if (*param_1 == 0x5a4d) {\n    iVar2 = FUN_00002457(param_2,*(int *)(param_1 + 0x1e) + 0xf8);\n    if (iVar2 == 0) {\n      return (int *)0x0;\n    }\n    piVar7 = (int *)(*(int *)(param_1 + 0x1e) + (int)param_1);\n    if (((*piVar7 == 0x4550) && ((short)piVar7[1] == 0x14c)) && ((piVar7[0xe] & 1U) == 0)) {\n      uVar6 = (uint)*(ushort *)((int)piVar7 + 6);\n      if (uVar6 != 0) {\n        piVar4 = (int *)((int)piVar7 + *(ushort *)(piVar7 + 5) + 0x24);\n        do {\n          uVar1 = piVar4[1];\n          if (uVar1 == 0) {\n            uVar1 = piVar7[0xe];\n          }\n          if (local_8 < *piVar4 + uVar1) {\n            local_8 = *piVar4 + uVar1;\n          }\n          piVar4 = piVar4 + 10;\n          uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n      }\n      iVar2 = (*pcRam004080a4)(0x40ebe8);\n      if (iVar2 == 0) {\n        return (int *)0x0;\n      }\n      pcVar3 = (code *)(*param_6)(iVar2,0x40f55c,0);\n      if (pcVar3 == (code *)0x0) {\n        return (int *)0x0;\n      }\n      (*pcVar3)(local_2c);\n      uVar6 = piVar7[0x14] + -1 + local_28 & ~(local_28 - 1U);\n      if (uVar6 == (local_28 + -1 + local_8 & ~(local_28 - 1U))) {\n        iVar2 = (*param_3)(piVar7[0xd],uVar6,0x3000,4,param_8);\n        if ((iVar2 != 0) || (iVar2 = (*param_3)(0,uVar6,0x3000,4,param_8), iVar2 != 0)) {\n          uVar8 = (*pcRam004080a0)(8,0x3c);\n          piVar4 = (int *)(*pcRam0040809c)(uVar8);\n          if (piVar4 != (int *)0x0) {\n            piVar4[1] = iVar2;\n            piVar4[5] = (*(ushort *)((int)piVar7 + 0x16) & 0x2000) >> 0xd;\n            piVar4[7] = (int)param_3;\n            piVar4[8] = (int)param_4;\n            piVar4[9] = param_5;\n            piVar4[10] = (int)param_6;\n            piVar4[0xb] = param_7;\n            piVar4[0xc] = param_8;\n            piVar4[0xe] = local_28;\n            iVar5 = FUN_00002457(param_2,piVar7[0x15]);\n            if (iVar5 != 0) {\n              _Dst = (void *)(*param_3)(iVar2,piVar7[0x15],0x1000,4,param_8);\n              memcpy(_Dst,param_1,piVar7[0x15]);\n              iVar5 = *(int *)(param_1 + 0x1e);\n              *piVar4 = iVar5 + (int)_Dst;\n              *(int *)(iVar5 + (int)_Dst + 0x34) = iVar2;\n              iVar5 = FUN_00002470(param_1,param_2,piVar7,piVar4);\n              if (iVar5 != 0) {\n                iVar5 = *(int *)(*piVar4 + 0x34) - piVar7[0xd];\n                if (iVar5 == 0) {\n                  piVar4[6] = 1;\n                }\n                else {\n                  iVar5 = FUN_00002758(piVar4,iVar5);\n                  piVar4[6] = iVar5;\n                }\n                iVar5 = FUN_000027df(piVar4);\n                if (((iVar5 != 0) && (iVar5 = FUN_0000254b(piVar4), iVar5 != 0)) &&\n                   (iVar5 = FUN_0000271d(piVar4), iVar5 != 0)) {\n                  iVar5 = *(int *)(*piVar4 + 0x28);\n                  if (iVar5 == 0) {\n                    piVar4[0xd] = 0;\n                    return piVar4;\n                  }\n                  if (piVar4[5] == 0) {\n                    piVar4[0xd] = iVar5 + iVar2;\n                    return piVar4;\n                  }\n                  iVar2 = (*(code *)(iVar5 + iVar2))(iVar2,1,0);\n                  if (iVar2 != 0) {\n                    piVar4[4] = 1;\n                    return piVar4;\n                  }\n                  (*pcRam004080a8)(0x45a);\n                }\n              }\n            }\n            FUN_000029cc(piVar4);\n            return (int *)0x0;\n          }\n          (*param_4)(iVar2,0,0x8000,param_8);\n        }\n        uVar8 = 0xe;\n        goto LAB_00002219;\n      }\n    }\n  }\n  uVar8 = 0xc1;\nLAB_00002219:\n  (*pcRam004080a8)(uVar8);\n  return (int *)0x0;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "SUB ESP,0x28",
            "AND dword ptr [EBP + -0x4],0x0",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "PUSH 0x40",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00002457",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000243d",
            "MOV ESI,dword ptr [EBP + 0x8]",
            "CMP word ptr [ESI],0x5a4d",
            "JZ 0x00002224",
            "PUSH 0xc1",
            "CALL dword ptr [0x004080a8]",
            "JMP 0x0000243d",
            "MOV EAX,dword ptr [ESI + 0x3c]",
            "ADD EAX,0xf8",
            "PUSH EAX",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00002457",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x0000243d",
            "MOV EDI,dword ptr [ESI + 0x3c]",
            "ADD EDI,ESI",
            "CMP dword ptr [EDI],0x4550",
            "JNZ 0x00002214",
            "CMP word ptr [EDI + 0x4],0x14c",
            "JNZ 0x00002214",
            "MOV EBX,dword ptr [EDI + 0x38]",
            "TEST BL,0x1",
            "JNZ 0x00002214",
            "MOVZX EAX,word ptr [EDI + 0x14]",
            "MOVZX EDX,word ptr [EDI + 0x6]",
            "TEST EDX,EDX",
            "LEA EAX,[EAX + EDI*0x1 + 0x18]",
            "JBE 0x0000228c",
            "LEA ECX,[EAX + 0xc]",
            "MOV ESI,dword ptr [ECX + 0x4]",
            "MOV EAX,dword ptr [ECX]",
            "TEST ESI,ESI",
            "JNZ 0x0000227c",
            "ADD EAX,EBX",
            "JMP 0x0000227e",
            "ADD EAX,ESI",
            "CMP EAX,dword ptr [EBP + -0x4]",
            "JBE 0x00002286",
            "MOV dword ptr [EBP + -0x4],EAX",
            "ADD ECX,0x28",
            "DEC EDX",
            "JNZ 0x0000226f",
            "PUSH 0x40ebe8",
            "CALL dword ptr [0x004080a4]",
            "TEST EAX,EAX",
            "JZ 0x0000243d",
            "PUSH 0x0",
            "PUSH 0x40f55c",
            "PUSH EAX",
            "CALL dword ptr [EBP + 0x1c]",
            "ADD ESP,0xc",
            "TEST EAX,EAX",
            "JZ 0x0000243d",
            "LEA ECX,[EBP + -0x28]",
            "PUSH ECX",
            "CALL EAX",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "MOV EDX,dword ptr [EDI + 0x50]",
            "LEA ESI,[EDX + EAX*0x1 + -0x1]",
            "MOV EDX,dword ptr [EBP + -0x4]",
            "LEA ECX,[EAX + -0x1]",
            "NOT ECX",
            "LEA EAX,[EAX + EDX*0x1 + -0x1]",
            "AND ESI,ECX",
            "AND EAX,ECX",
            "CMP ESI,EAX",
            "JNZ 0x00002214",
            "PUSH dword ptr [EBP + 0x24]",
            "PUSH 0x4",
            "PUSH 0x3000",
            "PUSH ESI",
            "PUSH dword ptr [EDI + 0x34]",
            "CALL dword ptr [EBP + 0x10]",
            "MOV EBX,EAX",
            "ADD ESP,0x14",
            "TEST EBX,EBX",
            "JNZ 0x0000230f",
            "PUSH dword ptr [EBP + 0x24]",
            "PUSH 0x4",
            "PUSH 0x3000",
            "PUSH ESI",
            "PUSH EAX",
            "CALL dword ptr [EBP + 0x10]",
            "MOV EBX,EAX",
            "ADD ESP,0x14",
            "TEST EBX,EBX",
            "JZ 0x00002336",
            "PUSH 0x3c",
            "PUSH 0x8",
            "CALL dword ptr [0x004080a0]",
            "PUSH EAX",
            "CALL dword ptr [0x0040809c]",
            "MOV ESI,EAX",
            "TEST ESI,ESI",
            "JNZ 0x0000233d",
            "PUSH dword ptr [EBP + 0x24]",
            "PUSH 0x8000",
            "PUSH EAX",
            "PUSH EBX",
            "CALL dword ptr [EBP + 0x14]",
            "ADD ESP,0x10",
            "PUSH 0xe",
            "JMP 0x00002219",
            "MOV dword ptr [ESI + 0x4],EBX",
            "MOV AX,word ptr [EDI + 0x16]",
            "SHR EAX,0xd",
            "AND EAX,0x1",
            "MOV dword ptr [ESI + 0x14],EAX",
            "MOV EAX,dword ptr [EBP + 0x10]",
            "MOV dword ptr [ESI + 0x1c],EAX",
            "MOV EAX,dword ptr [EBP + 0x14]",
            "MOV dword ptr [ESI + 0x20],EAX",
            "MOV EAX,dword ptr [EBP + 0x18]",
            "MOV dword ptr [ESI + 0x24],EAX",
            "MOV EAX,dword ptr [EBP + 0x1c]",
            "MOV dword ptr [ESI + 0x28],EAX",
            "MOV EAX,dword ptr [EBP + 0x20]",
            "MOV dword ptr [ESI + 0x2c],EAX",
            "MOV EAX,dword ptr [EBP + 0x24]",
            "MOV dword ptr [ESI + 0x30],EAX",
            "MOV EAX,dword ptr [EBP + -0x24]",
            "MOV dword ptr [ESI + 0x38],EAX",
            "PUSH dword ptr [EDI + 0x54]",
            "PUSH dword ptr [EBP + 0xc]",
            "CALL 0x00002457",
            "POP ECX",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00002436",
            "PUSH dword ptr [EBP + 0x24]",
            "PUSH 0x4",
            "PUSH 0x1000",
            "PUSH dword ptr [EDI + 0x54]",
            "PUSH EBX",
            "CALL dword ptr [EBP + 0x10]",
            "PUSH dword ptr [EDI + 0x54]",
            "MOV dword ptr [EBP + 0x24],EAX",
            "PUSH dword ptr [EBP + 0x8]",
            "PUSH EAX",
            "CALL 0x00007706",
            "MOV ECX,dword ptr [EBP + 0x8]",
            "MOV EDX,dword ptr [EBP + 0x24]",
            "PUSH ESI",
            "PUSH EDI",
            "MOV EAX,dword ptr [ECX + 0x3c]",
            "PUSH dword ptr [EBP + 0xc]",
            "ADD EAX,EDX",
            "MOV dword ptr [ESI],EAX",
            "PUSH ECX",
            "MOV dword ptr [EAX + 0x34],EBX",
            "CALL 0x00002470",
            "ADD ESP,0x30",
            "TEST EAX,EAX",
            "JZ 0x00002436",
            "MOV EAX,dword ptr [ESI]",
            "MOV EAX,dword ptr [EAX + 0x34]",
            "SUB EAX,dword ptr [EDI + 0x34]",
            "JZ 0x000023e9",
            "PUSH EAX",
            "PUSH ESI",
            "CALL 0x00002758",
            "POP ECX",
            "MOV dword ptr [ESI + 0x18],EAX",
            "POP ECX",
            "PUSH 0x1",
            "POP EDI",
            "JMP 0x000023ef",
            "PUSH 0x1",
            "POP EDI",
            "MOV dword ptr [ESI + 0x18],EDI",
            "PUSH ESI",
            "CALL 0x000027df",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00002436",
            "PUSH ESI",
            "CALL 0x0000254b",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00002436",
            "PUSH ESI",
            "CALL 0x0000271d",
            "TEST EAX,EAX",
            "POP ECX",
            "JZ 0x00002436",
            "MOV EAX,dword ptr [ESI]",
            "XOR ECX,ECX",
            "MOV EAX,dword ptr [EAX + 0x28]",
            "CMP EAX,ECX",
            "JZ 0x0000244d",
            "CMP dword ptr [ESI + 0x14],ECX",
            "JZ 0x00002446",
            "PUSH ECX",
            "PUSH EDI",
            "ADD EAX,EBX",
            "PUSH EBX",
            "CALL EAX",
            "TEST EAX,EAX",
            "JNZ 0x00002441",
            "PUSH 0x45a",
            "CALL dword ptr [0x004080a8]",
            "PUSH ESI",
            "CALL 0x000029cc",
            "POP ECX",
            "XOR EAX,EAX",
            "JMP 0x00002452",
            "MOV dword ptr [ESI + 0x10],EDI",
            "JMP 0x00002450",
            "ADD EAX,EBX",
            "MOV dword ptr [ESI + 0x34],EAX",
            "JMP 0x00002450",
            "MOV dword ptr [ESI + 0x34],ECX",
            "MOV EAX,ESI",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000021e9",
            "end": "00002456"
        },
        "variable_metadata": {
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000022b5"
                ],
                "type": "undefined"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000021ef",
                    "0000227e",
                    "00002283",
                    "000022c5"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000022bb",
                    "00002371"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000021e9",
        "original_name": "FUN_000021e9",
        "predicted_name": "\"pe_load_exe\".",
        "prediction_full_response": "The predicted function name is \"pe_load_exe\".</s>"
    },
    "000018f9": {
        "decomp_code": "\nundefined4 FUN_000018f9(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined4 local_20 [3];\n  undefined4 local_14;\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  undefined4 local_8;\n  \n  uStack_c = 0x4081f0;\n  uStack_10 = 0x4076f4;\n  local_14 = puRamffdff000;\n  uVar4 = 0;\n  local_20[0] = 0;\n  local_8 = 0;\n  puRamffdff000 = &local_14;\n  iVar1 = (*pcRam00408034)(param_3,0x80000000,1,0,3,0,0);\n  if (iVar1 != -1) {\n    uVar2 = (*pcRam00408044)(iVar1,0);\n    if ((uVar2 != 0xffffffff) && (uVar2 < 0x19001)) {\n      iVar3 = (*pcRam004080dc)(0,uVar2);\n      if (iVar3 != 0) {\n        iVar1 = (*pcRam00408040)(iVar1,iVar3,uVar2,local_20,0);\n        if (iVar1 != 0) {\n          iVar1 = (*pcRam0040f898)(param_1,iVar3,local_20[0],0,0,param_2);\n          if (iVar1 != 0) {\n            uVar4 = 1;\n          }\n        }\n      }\n    }\n  }\n  local_unwind2(&local_14,0xffffffff);\n  puRamffdff000 = (undefined4 *)local_14;\n  return uVar4;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "PUSH EBP",
            "MOV EBP,ESP",
            "PUSH -0x1",
            "PUSH 0x4081f0",
            "PUSH 0x4076f4",
            "MOV EAX,FS:[0x0]",
            "PUSH EAX",
            "MOV dword ptr FS:[0x0],ESP",
            "SUB ESP,0x18",
            "PUSH EBX",
            "PUSH ESI",
            "PUSH EDI",
            "OR dword ptr [EBP + -0x28],0xffffffff",
            "XOR ESI,ESI",
            "MOV dword ptr [EBP + -0x1c],ESI",
            "MOV dword ptr [EBP + -0x20],ESI",
            "MOV dword ptr [EBP + -0x4],ESI",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH 0x3",
            "PUSH ESI",
            "PUSH 0x1",
            "PUSH 0x80000000",
            "PUSH dword ptr [EBP + 0x10]",
            "CALL dword ptr [0x00408034]",
            "MOV dword ptr [EBP + -0x28],EAX",
            "CMP EAX,-0x1",
            "JZ 0x000019a0",
            "PUSH ESI",
            "PUSH EAX",
            "CALL dword ptr [0x00408044]",
            "MOV EDI,EAX",
            "MOV dword ptr [EBP + -0x24],EDI",
            "CMP EDI,-0x1",
            "JZ 0x000019a0",
            "CMP EDI,0x19000",
            "JA 0x000019a0",
            "PUSH EDI",
            "PUSH ESI",
            "CALL dword ptr [0x004080dc]",
            "MOV EBX,EAX",
            "MOV dword ptr [EBP + -0x20],EBX",
            "CMP EBX,ESI",
            "JZ 0x000019a0",
            "PUSH ESI",
            "LEA EAX,[EBP + -0x1c]",
            "PUSH EAX",
            "PUSH EDI",
            "PUSH EBX",
            "PUSH dword ptr [EBP + -0x28]",
            "CALL dword ptr [0x00408040]",
            "TEST EAX,EAX",
            "JZ 0x000019a0",
            "PUSH dword ptr [EBP + 0xc]",
            "PUSH ESI",
            "PUSH ESI",
            "PUSH dword ptr [EBP + -0x1c]",
            "PUSH EBX",
            "PUSH dword ptr [EBP + 0x8]",
            "CALL dword ptr [0x0040f898]",
            "TEST EAX,EAX",
            "JZ 0x000019a0",
            "PUSH 0x1",
            "POP ESI",
            "PUSH -0x1",
            "LEA EAX,[EBP + -0x10]",
            "PUSH EAX",
            "CALL 0x000076fa",
            "POP ECX",
            "POP ECX",
            "MOV EAX,ESI",
            "JMP 0x000019d2",
            "MOV ECX,dword ptr [EBP + -0x10]",
            "MOV dword ptr FS:[0x0],ECX",
            "POP EDI",
            "POP ESI",
            "POP EBX",
            "LEAVE",
            "RET"
        ],
        "function_address": {
            "start": "000018f9",
            "end": "000019e0"
        },
        "variable_metadata": {
            "local_2c": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "0000191c",
                    "00001940",
                    "0000197a"
                ],
                "type": "undefined4"
            },
            "local_8": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001928"
                ],
                "type": "undefined4"
            },
            "local_28": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001952"
                ],
                "type": "undefined4"
            },
            "local_20": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001922",
                    "00001974",
                    "0000198c"
                ],
                "type": "undefined4"
            },
            "local_14": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "000019a2",
                    "000019d2"
                ],
                "type": "undefined4"
            },
            "local_24": {
                "agg": {
                    "is_enum": false,
                    "is_union": false,
                    "is_struct": false
                },
                "addresses": [
                    "00001925",
                    "0000196c"
                ],
                "type": "undefined4"
            }
        },
        "func_name": "FUN_000018f9",
        "original_name": "FUN_000018f9",
        "predicted_name": "pf_ram_write_block.",
        "prediction_full_response": "The predicted function name is pf_ram_write_block.</s>"
    },
    "0000264f": {
        "decomp_code": "\nint FUN_0000264f(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_2 + 0x10);\n  if (iVar1 == 0) {\n    if ((*(uint *)(param_2 + 0x24) & 0x40) != 0) {\n      return *(int *)(*param_1 + 0x20);\n    }\n    if ((*(uint *)(param_2 + 0x24) & 0x80) != 0) {\n      iVar1 = *(int *)(*param_1 + 0x24);\n    }\n  }\n  return iVar1;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "MOV ECX,dword ptr [ESP + 0x8]",
            "MOV EAX,dword ptr [ECX + 0x10]",
            "TEST EAX,EAX",
            "JNZ 0x0000267a",
            "MOV ECX,dword ptr [ECX + 0x24]",
            "TEST CL,0x40",
            "JZ 0x0000266c",
            "MOV EAX,dword ptr [ESP + 0x4]",
            "MOV EAX,dword ptr [EAX]",
            "MOV EAX,dword ptr [EAX + 0x20]",
            "RET",
            "TEST CL,0x80",
            "JZ 0x0000267a",
            "MOV EAX,dword ptr [ESP + 0x4]",
            "MOV EAX,dword ptr [EAX]",
            "MOV EAX,dword ptr [EAX + 0x24]",
            "RET"
        ],
        "function_address": {
            "start": "0000264f",
            "end": "0000267a"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000264f",
        "original_name": "FUN_0000264f",
        "predicted_name": "get_socket_fd",
        "prediction_full_response": "The predicted function name is get_socket_fd</s>"
    },
    "0000793f": {
        "decomp_code": "\nvoid FUN_0000793f(void)\n\n{\n  return;\n}\n\n",
        "args_metadata": {},
        "assembly": [
            "RET"
        ],
        "function_address": {
            "start": "0000793f",
            "end": "0000793f"
        },
        "variable_metadata": {},
        "func_name": "FUN_0000793f",
        "original_name": "FUN_0000793f",
        "predicted_name": "mu_stream_close_null.",
        "prediction_full_response": "The predicted function name is mu_stream_close_null.</s>"
    }
}